// import "./style.css";
"use strict";
// import "bootstrap";
// import "popper";
// import "";
// import "../src/bootstrap-5.0.2-dist/js/bootstrap.js";
// import "../src/plugins/popper.min.js";
// import "../src/plugins/common/common.min.js";
// import "../src/js/custom.min.js";
// import "../src/js/settings.js";
// import "../src/js/gleek.js";
// import "../src/js/styleSwitcher.js";
// import "../src/plugins/circle-progress/circle-progress.min.js";

// import * as THREE from "three";
// import * as CSG from "./three-master/three-csg.js";
// import { OrbitControls } from "./controls/OrbitControls.js";
// import { RGBELoader } from "./loaders/RGBELoader";
// import MeshReflectorMaterial from "./MeshReflectorMaterial.js";
// import { TransformControls } from "./controls/TransformControls.js";
// import { Reflector } from './objects/Reflector.js'
// import * as dat from "lil-gui";
// import * as dat from "dat";

// import { OrbitControls } from './jsm/controls/OrbitControls.js';
// import { Refractor } from "./objects/Refractor.js";
// import { RectAreaLightHelper } from "./helpers/RectAreaLightHelper.js";
// import { RectAreaLightUniformsLib } from "./lights/RectAreaLightUniformsLib.js";

// import { OBJLoader } from "./loaders/OBJLoader.js";
// import { GLTFLoader } from "gltf";

// import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/loaders/GLTFLoader.js";

// import { MTLLoader } from "./loaders/MTLLoader.js";
// import { DragControls } from "./controls/DragControls.js";
// import { CSS3DObject } from "./renderers/CSS3DRenderer.js";
// import { TextGeometry } from "./geometries/TextGeometry.js";
// import { FontLoader } from "./loaders/FontLoader.js";
// import { OBJExporter } from "./exporters/OBJExporter.js";
/**
 * Base
 */
let obj, value, valueZ;
let gltfSave;
let loaderr;
let wallWidth = 0.1;
let controls;
let dragControls;
let wallsOpen = false;
let mixer = null,
  mixer2 = null,
  mixer3 = null,
  mixer4 = null;
let objectsAltered = [];
let uuidOfMeasures = 0;
let heightText = 0;
let heightTopText = 0;
let heightBottomText = 0;

let textTop,
  textBottom,
  textLeft,
  textRight,
  lineTop,
  lineBottom,
  lineRight,
  lineLeft;
let backOpenings = [];
let frontOpenings = [];
let leftOpenings = [];
let rightOpenings = [];
let fillers = [];
window.fillers = fillers;
let LC = 0,
  RC = 0,
  FC = 0,
  BC = 0; // [Left , Right , Front , Back] Count
let dragLeftWall;
let dragRightWall;
let dragBackWall;
let dragFrontWall;

let RightWallLine;
let LeftWallLine;

let isUpdatedBeside = false;

let worktopsColor = "MC8";

// const gui = new dat.GUI();

const textureLoader = new TextureLoader();
// const textureBottom = textureLoader.load("/kitchencolors/Oak.jpg");
const textureBottom = textureLoader.load("./kitchencolors/Oak.jpg");
// const textureBottom = textureLoader.load('./kitchencolors/vitrified-parking-tiles-org-23458256064925803.jpg')
const texture = textureLoader.load("./colors/MC3.png");
let textureCeiling = textureLoader.load("./colors/MC3.png");
let textureWalls = textureLoader.load("./colors/MC1.png");
let textureFloor = textureLoader.load("./colors/MC2.png");
let Init = textureLoader.load("./colors/MC1.png");
let textureCorpus = textureLoader.load("./colors/MC3.png");
let textureFront = textureLoader.load("./kitchencolors/Walnut.jpg");
let textureToekick = textureLoader.load("./kitchencolors/Walnut.jpg");
let textureWorktops = textureLoader.load("./kitchencolors/Walnut.jpg");
const textureLoader2 = new TextureLoader();
let is2D = false;

const materialObjects = new LineBasicMaterial({ color: 0xff0000 });
const materialRight = new LineBasicMaterial({ color: 0x000000 });
let planeRightCoordinates = {
  scale: 0,
  position: 0,
};
let planeLeftCoordinates = {
  scale: 0,
  position: 0,
};

let planeBackCoordinates = {
  scale: 0,
  position: 0,
};
// For finish Top and filler
let objBeside = null;
let objBesideLeft = null;
let objBesideRight = null;

let savedElement;

const textureTest = textureLoader2.load("./kitchencolors/Fabric.jpeg");
texture.wrapS = texture.wrapT = RepeatWrapping;
textureWalls.wrapS = textureWalls.wrapT = RepeatWrapping;
textureCeiling.wrapS = textureCeiling.wrapT = RepeatWrapping;
textureFloor.wrapS = textureFloor.wrapT = RepeatWrapping;
// textureFloor.wrapS = textureFloor.wrapT = RepeatWrapping;
// textureCorpus.wrapS = textureCorpus.wrapT = RepeatWrapping;
// textureFront.wrapS = textureFront.wrapT = RepeatWrapping;
// textureToekick.wrapS = textureToekick.wrapT = RepeatWrapping;
// textureWorktops.wrapS = textureWorktops.wrapT = RepeatWrapping;
Init.wrapS = Init.wrapT = RepeatWrapping;
textureTest.wrapS = textureTest.wrapT = RepeatWrapping;
// texture.repeat.set(10, 10);
// textureFloor.offset.set(0.02, 0.02);
// textureFloor.repeat.set(0.02, 0.02);
// textureWalls.repeat.set(0.02, 0.02);
// textureWalls.offset.set(0.02, 0.02);
// textureCeiling.offset.set(0.02, 0.02);
// textureCeiling.repeat.set(0.02, 0.02);
let uuidsLeft = [],
  uuidsRight = [];
texture.repeat.set(0.02, 0.02);
texture.offset.set(0.2, 0.2);
// textureCorpus.repeat.set(0.02, 0.02);
textureCorpus.offset.set(0.02, 0.02);
textureFront.offset.set(0.02, 0.02);
// let height2d;
// textureFront.repeat.set(0.02, 0.02);
// textureFront.offset.set(0.2, 0.2);
// textureToekick.repeat.set(0.02, 0.02);
textureToekick.offset.set(0.02, 0.02);
// textureWorktops.repeat.set(0.02, 0.02);
textureWorktops.offset.set(0.02, 0.02);
Init.repeat.set(0.02, 0.02);
Init.offset.set(0.2, 0.2);

textureTest.repeat.set(0.02, 0.02);
// console.log(texture);
const raycaster = new Raycaster();
let epse = 0.5;
let objects = [];
const handles = [];
let leftCovers = [];
let rightCovers = [];
let backCovers = [];
let wallPanels = [];
let finishTops = [];
let uuids = [];
const decoStrips = [];
const Cornices = [];
const lightObjects = [];
const directions = [];
const ovens = [];
const sinks = [];

let flagTest = false;

window.leftCovers = leftCovers;
window.rightCovers = rightCovers;
window.backCovers = backCovers;
window.wallPanels = wallPanels;
window.finishTops = finishTops;
window.decoStrips = decoStrips;
window.Cornices = Cornices;
window.lightObjects = lightObjects;
window.ovens = ovens;
window.sinks = sinks;
// window.directions = directions;

// window.ovens = ovens;

let emptying = [];

const worktops = [];

let camera, renderer, clock;
let enableSelection = false;
// let refractor;

// var projector = new Projector(),
//     mouse_vector = new Vector3(),
//     mouse = { x: 0, y: 0, z: 1 },
//     ray = new Raycaster( new Vector3(0,0,0), new Vector3(0,0,0) ),
var intersects = [];
let uuidSelected = [];

let INTERSECTED;
// let theta = 0;

const pointer = new Vector2();

const mouseCoords = new Vector2();
let height = 3.1;

let length = 3.1;
let width = 4.1;
const measures = {
  height,
  width,
  length,
};

let measuresXG = {
  min: -2.1,
  max: 2.1,
};
let measuresZG = {
  min: -2.1,
  max: 2.1,
};
let t = 0,
  k = 9;

// let timescale = 0.039;
let mainLight, greenLight, redLight, frontLight, whiteLight, backLight;
let planeGeo,
  planeGeoBack,
  planeGeoLR,
  planeTop,
  planeBottom,
  planeBack,
  planeRight,
  planeLeft,
  planeFront;

// let object;
// Debug
// const gui = new dat.GUI();
class Measures {
  line1X = 0;
  line2X = 0;
  line1Z = 0;
  line2Z = 0;
  object = null;
  valX = 0;
  valZ = 0;

  constructor() {}
  setValX() {
    // console.log("this.line1X   ", this.line1X);
    // console.log("this.line2X   ", this.line2X);
    if (this.line1X != this.line2X) this.valX = (this.line1X + this.line2X) / 2;
    else this.valX = this.line1X;
  }

  setValZ() {
    // console.log("this.line1Z   ", this.line1Z);
    // console.log("this.line2Z   ", this.line2Z);
    if (this.line1Z != this.line2Z) this.valZ = (this.line1Z + this.line2Z) / 2;
    else this.valZ = this.line1Z;
  }

  getValue() {
    if (this.line1X != this.line2X)
      return (
        Math.max(this.line1X, this.line2X) - Math.min(this.line1X, this.line2X)
      );
    else if (this.line1Z != this.line2Z)
      return (
        Math.max(this.line1Z, this.line2Z) - Math.min(this.line1Z, this.line2Z)
      );
    // return (
    //   Math.max(this.line1Z, this.line2Z) - Math.min(this.line1Z, this.line2Z)
    // );
  }
}

// let line1X,line2X;
// let line1Z,line2Z;
// Lines Measures
let RightLine = null;
let LeftLine = null;
let FrontLine = null;
let BackLine = null;
let TopLine = null;
let BottomLine = null;
let WallLeftLine = null;
let WallRightLine = null;

async function setChanges(type = null) {
  // console.log(scene.children);
  window.W = measuresXG.max - measuresXG.min;
  window.L = measuresZG.max - measuresZG.min;
  if (is2D) {
    await LinesAndText2D(true);
    // scene.background = new Color(0xfffff8);
    // camera.position.set(0, 5, 0);
    // controls.target.set(0, 0, 0);
    // controls.enabled = false;
    // to2D();
    // to2D();
  }

  let i = 0;
  let flag = false;

  for (let index = 0; index < scene.children.length; index++) {
    if (
      (scene.children[index].type === "Mesh" ||
        scene.children[index].type === "PointLight" ||
        scene.children[index].type === "DirectionalLight") &&
      scene.children[index].name != type
    ) {
      // console.log("scene.children[i].type  ", scene.children[index].type);
      scene.remove(scene.children[index]);
      index = index - 1;
    }
  }
}
// Canvas
let canvas = document.querySelector("canvas.webgl");
//var canvas;

// document.body.addEventListener('mousedown',function(e) {
//   // myfunc(mEvent)
//   console.log('x ' , e.clientX);
//   console.log('y ' , e.clientY);
// },false);
// let body = document.getElementsByTagName('body');
// body.addEventListener('mousedown', function(e) {
//  console.log('x ' , e.clientX);
//  console.log('y ' , e.clientY);
//   // e.clientX
// });

//  receive data from flutter
window.parent.addEventListener("message", handleMessage, false);

function handleMessage(e) {
  var data = JSON.parse(e.data);

  if (data.hasOwnProperty("addObject")) {
    addObjects(
      data["addObject"].objName,
      data["addObject"].measures,
      data["addObject"].type,
      data["addObject"].isElement,
      null,
      data["addObject"].heightable ?? null,
      data["addObject"].directional ?? null
    );
  } else if (data.hasOwnProperty("applyColorCeiling")) {
    applyColorCeiling(data["applyColorCeiling"].color);
  } else if (data.hasOwnProperty("applyColorWalls")) {
    applyColorWalls(data["applyColorWalls"].color);
  } else if (data.hasOwnProperty("applyColorFloor")) {
    applyColorFloor(data["applyColorFloor"].color);
  } else if (data.hasOwnProperty("applyColorCorpus")) {
    applyColorCorpus(
      data["applyColorCorpus"].color,
      data["applyColorCorpus"].type
    );
  } else if (data.hasOwnProperty("applyColorFront")) {
    applyColorFront(
      data["applyColorFront"].color,
      data["applyColorFront"].type
    );
  } else if (data.hasOwnProperty("applyColorToekick")) {
    applyColorToekick(data["applyColorToekick"].color);
  } else if (data.hasOwnProperty("applyColorWorktops")) {
    applyColorWorktops(data["applyColorWorktops"].color);
  } else if (data.hasOwnProperty("updateDimensionsElements")) {
    updateDimensionsElements(
      parseInt(data["updateDimensionsElements"].width) / 1000,
      parseInt(data["updateDimensionsElements"].height) / 1000,
      parseInt(data["updateDimensionsElements"].depth) / 1000,
      data["updateDimensionsElements"].wallSide
    );
  } else if (data.hasOwnProperty("applyHandle")) {
    applyHandle(data["applyHandle"].handle);
  } else if (data.hasOwnProperty("applyDoor")) {
    applyDoor(data["applyDoor"].door);
  } else if (data.hasOwnProperty("applyLeftCover")) {
    applyLeftCover(data["applyLeftCover"].type);
  } else if (data.hasOwnProperty("applyRightCover")) {
    applyRightCover(data["applyRightCover"].type);
  } else if (data.hasOwnProperty("applyBackCover")) {
    applyBackCover(data["applyBackCover"].type);
  } else if (data.hasOwnProperty("applyDrawer")) {
    applyDrawer(data["applyDrawer"].drawer);
  } else if (data.hasOwnProperty("applyDecoStrip")) {
    applyDecoStrip(data["applyDecoStrip"].color, data["applyDecoStrip"].state);
  } else if (data.hasOwnProperty("applyCornice")) {
    applyCornice(data["applyCornice"].color, data["applyCornice"].state);
  } else if (data.hasOwnProperty("applyDecoLight")) {
    applyDecoLight(data["applyDecoLight"].state);
  } else if (data.hasOwnProperty("applyCorniceLight")) {
    applyCorniceLight(data["applyCorniceLight"].state);
  } else if (data.hasOwnProperty("changeWallPanelHeight")) {
    changeWallPanelHeight(data["changeWallPanelHeight"].height);
  } else if (data.hasOwnProperty("applyWallPanel")) {
    applyWallPanel(data["applyWallPanel"].color, data["applyWallPanel"].state);
  } else if (data.hasOwnProperty("applyOven")) {
    applyOven(data["applyOven"].oven);
  } else if (data.hasOwnProperty("applySink")) {
    applySink(data["applySink"].sink);
  } else if (data.hasOwnProperty("applySkirtingLight")) {
    applySkirtingLight(data["applySkirtingLight"].type);
  } else if (data.hasOwnProperty("changeWallOffset")) {
    changeWallOffset(data["changeWallOffset"].offset);
  } else if (data.hasOwnProperty("applyMeasures")) {
    window.clearMeasuresLines();
    window.calcMeasuresFunc();
  } else if (data.hasOwnProperty("applyDelete")) {
    window.deleteObject();
  } else if (data.hasOwnProperty("to2D")) {
    window.to2D(false, true);
  } else if (data.hasOwnProperty("ScreenShot")) {
    getScreenShot();
  } else {
  }
  if (data.hasOwnProperty("requestOrder")) {
    postData();
  } else {
    console.log("no");
  }
}
//   if()
//for(var i =0 ; i<= data.length ;i++){
//}
//     if(e.data[i].addObject){
//     print('okkkay');
//     }
//}
// canvas.addEventListener('mousedown', function(e) {

//   // var xformControl = new TransformControls(camera, renderer.domElement);
//   // scene.add(xformControls);
//   // // assuming you add "myObj" to your scene...
//   // xformControl.attach(planeBottom);
//   // // and then later...
//   // xformControl.detatch();
//   // console.log('position  ',planeBottom.position);
//   const vector = new Vector3(250, 250, 250);
//   // const canvas2 = renderer.domElement; // `renderer` is a WebGLRenderer

//   // vector.project(camera); // `camera` is a PerspectiveCamera

//   // vector.x = Math.round((0.5 + vector.x / 2) * (canvas2.width / window.devicePixelRatio));
//   // vector.y = Math.round((0.5 - vector.y / 2) * (canvas2.height / window.devicePixelRatio));
//   // console.log('vector ',vector);
//   // let vector = new Vector3();
//   // vector.project( camera );

// vector.project( camera );
// vector.x = ( vector.x + 1) * renderer.domElement.width / 2;
// vector.y = - ( vector.y - 1) * renderer.domElement.height / 2;
// vector.z = 0

//   // vector.x = ( vector.x + 1) * $("canvas").width() / 2;
//   // vector.y = - ( vector.y - 1) * $("canvas").height() / 2;
//   // vector.z = 0;
//   console.log('vector ',vector);
//             })

// Scene

let scene = new Scene();
window.scene = scene;
let group = new Group();
scene.add(group);
var ambientLight = new AmbientLight(0x303030);
scene.add(ambientLight);

window.addEventListener("keypress", onKeyPress);
window.addEventListener("mousedown", onKeyDown);
window.addEventListener("mouseup", onKeyUp);
// scene.background = new Color(0xbfd1e5);

const loader1 = new CubeTextureLoader();
const textureBackground = loader1.load([
  "./colors/background/posx.jpg",
  "./colors/background/negx.jpg",
  "./colors/background/posy.jpg",
  "./colors/background/negy.jpg",
  "./colors/background/posz.jpg",
  "./colors/background/negz.jpg",
]);
// scene.background = new Color(0xffffff);
//setTimeout(() => {
//const iframe = document.getElementById("myIframe");
//const iWindow = iframe.contentWindow;
//const iDocument = iWindow.document;
//canvas= iDocument.getElementsByTagName("canvas")[0];
////  console.log(element);
//  // console.log(document.getElementById('myIframe').contentWindow.document.body);
//
////  canvas = element;
//    canvas.addEventListener("mousedown", onDocumentMouseDown, false);
init();

//},2000);
// init();
// gui
//   .add(measures, "height")
//   .min(2)
//   .max(6)
//   .name("Ceiling height")
//   .step(0.5)
//   .onFinishChange(async () => {
//     // console.log(planeGeoBack.parameters.height);
//     await setChanges();
//     // console.log(scene.children.length);
//     walls();
//     // console.log("start rendered");
//     // await init();
//     render();
//     // planeGeoBack = new PlaneGeometry(width, height);
//     // planeGeoLR = new PlaneGeometry(length, height);

//     // planeBack.position.z = - length / 2;
//     // planeBack.position.y = height / 2;
//   });

// let widthGui = gui.add(measures, "width").min(2).max(6).step(0.5)
//   .onFinishChange(async () => {
//     // console.log(planeGeoBack.parameters.height);
//     await setChanges();
//     // console.log(scene.children.length);

//     walls();
//     // console.log("start rendered");
//     // await init();

//     render();
//     // planeGeoBack = new PlaneGeometry(width, height);
//     // planeGeoLR = new PlaneGeometry(length, height);

//     // planeBack.position.z = - length / 2;
//     // planeBack.position.y = height / 2;
//   });
// let lengthGui = gui.add(measures, "length").min(2).max(6).step(0.5)
//   .onFinishChange(async () => {
//     await setChanges();

//     walls();

//     render();
//   });

/**
 * init function
 */
async function init() {
  /**
   *




			let orbit;

			init();
			render();

			function init() {

				const aspect = window.innerWidth / window.innerHeight;


				scene.add( new GridHelper( 1000, 10, 0x888888, 0x444444 ) );


				const texture = new TextureLoader().load( 'textures/crate.gif', render );
				texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

				const geometry = new BoxGeometry( 200, 200, 200 );
				const material = new MeshLambertMaterial( { map: texture, transparent: true } );

				orbit = new OrbitControls( currentCamera, renderer.domElement );
				orbit.update();
				orbit.addEventListener( 'change', render );

				control = new TransformControls( currentCamera, renderer.domElement );
				control.addEventListener( 'change', render );

				control.addEventListener( 'dragging-changed', function ( event ) {

					orbit.enabled = ! event.value;

				} );

				const mesh = new Mesh( geometry, material );
				scene.add( mesh );

				control.attach( mesh );
				scene.add( control );


			}


   */

  // const loaderr = new GLTFLoader();
  // loaderr.load("/obj/newObjects/handle_direction.glb", function (gltf) {
  //   let object = gltf.scene;

  //   object.scale.x = 0.3;
  //   object.scale.y = 0.2;
  //   object.scale.z = 0.2;
  //   object.position.x = 1;
  //   object.position.y = 1;
  //   object.position.z = 1;

  //   scene.add(object);

  //   // console.log("object   ",object);
  //   // console.log("scene   ",scene);

  // });
  // const trackShape = new Shape()
  // .moveTo( 4, 4 )
  // .lineTo( 4, 16 )
  // .absarc( 6, 16, 2, Math.PI, 0, true )
  // .lineTo( 8, 4 )
  // .absarc( 6, 4, 2,  Math.PI, Math.PI, true );
  // const fishShape = new Shape()
  // 				.moveTo( 0, 3 )
  // 				.quadraticCurveTo(  5, 8,  9, 1 );
  // 				// .quadraticCurveTo( 10, 10, 1.5,  4 )
  // 				// .quadraticCurveTo(  10.5, 0.1,  1.5, 4 )
  // 				// .quadraticCurveTo(  1,  1, 0.1 + 9, 1 )
  // 				// .quadraticCurveTo(  5,  8, 0.1, 0.1 );
  // // scene.add(trackShape);

  // let geometry = new ShapeGeometry( fishShape );

  // let mesh = new Mesh( geometry, new MeshPhongMaterial( { side: DoubleSide, map: textureFloor } ) );
  // mesh.position.set( 0, 0, 0);
  // // mesh.rotation.set( rx, ry, rz );
  // mesh.scale.set( 0.1, 0.1, 0.1 );
  // scene.add( mesh );
  // const container = document.getElementById('container');
  // scene.background = textureBackground;
  scene.background = new Color(0xfaf9f6);
  clock = new Clock();

  // renderer
  renderer = new WebGLRenderer({
    canvas: canvas,
    antialias: true,
    preserveDrawingBuffer: true,
    powerPreference: "high-performance",
  });
  renderer.setPixelRatio(window.devicePixelRati);
  renderer.setSize(window.innerWidth, window.innerHeight);
  // container.appendChild(renderer.domElement);
  renderer.shadowMap.enabled = true;

  renderer.shadowMap.type = PCFSoftShadowMap;

  renderer.localClippingEnabled = true;
  // renderer.domElement.addEventListener('webglcontextrestored', function() {

  //   camera.update(renderer, scene);

  // });
  //   canvas.addEventListener("webglcontextlost", function(event) {
  //     event.preventDefault();
  // }, false);
  //   renderer.domElement.addEventListener( 'webglcontextlost', function() {
  //     renderer.restoreContext();
  // } );
  // scene
  // scene = new Scene();

  // camera
  camera = new PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.set(-3, 1, 9);

  //  camera = new OrthographicCamera( -2, 2, -10, 2, 1, 1000 );
  //  scene.add( camera );

  controls = new OrbitControls(camera, renderer.domElement);
  controls.target.set(0, 1, 0);
  controls.enablePan = false;
  controls.maxPolarAngle = Math.PI / 2;
  // controls.enableDamping = true;
  controls.addEventListener("change", async () => {
    if (RightLine) {
      if (document.getElementById("Right").style.display != "none")
        await showText(RightLine, "Right", heightText);
      if (document.getElementById("Left").style.display != "none")
        await showText(LeftLine, "Left", heightText);
      if (document.getElementById("Front").style.display != "none")
        await showText(FrontLine, "Front", heightText);
      if (document.getElementById("Back").style.display != "none")
        await showText(BackLine, "Back", heightText);
      if (document.getElementById("Top").style.display != "none")
        await showText(TopLine, "Top", heightTopText);
      if (document.getElementById("Bottom").style.display != "none")
        await showText(BottomLine, "Bottom", heightBottomText);
      if (document.getElementById("RightWall").style.display != "none")
        await showText(RightWallLine, "RightWall", measures.height);
      if (document.getElementById("LeftWall").style.display != "none")
        await showText(LeftWallLine, "LeftWall", measures.height);
    }
  });
  // controls.maxDistance = 400;
  // controls.minDistance = 10;
  controls.minDistance = 0;
  controls.maxDistance = 8;
  controls.rotateSpeed = 2.5;
  controls.zoomSpeed = 6;
  controls.panSpeed = 3.5;
  controls.update();

  // // let control;
  // // // scene.add( new GridHelper( 1000, 10, 0x888888, 0x444444 ) );
  // // const geometry = new BoxGeometry( 1, 1, 1 );
  // // const material = new MeshLambertMaterial( { color: '#ddffaa', transparent: true } );

  // // let orbit = new OrbitControls( camera, renderer.domElement );
  // // orbit.update();
  // // orbit.addEventListener( 'change', render );

  // // control = new TransformControls( camera, renderer.domElement );
  // // control.showZ = false;
  // // control.size = 0.5;
  // // control.addEventListener( 'change', render );

  // // control.addEventListener( 'dragging-changed', function ( event ) {

  // //   orbit.enabled = ! event.value;
  // //   controls.enabled = ! event.value;
  // //   // controls

  // // } );

  // const mesh = new Mesh( geometry, material );
  // scene.add( mesh );

  // control.attach( mesh );
  // scene.add( control );
  // const refractorGeometry = new PlaneGeometry(90, 90);

  // refractor = new Refractor(refractorGeometry, {
  //   color: 0x99fff9,
  //   textureWidth: 1024,
  //   textureHeight: 1024,
  //   shader: WaterRefractionShader,
  // });

  // refractor.position.set( 0, 50, 0 );

  // scene.add( refractor );

  // load dudv map for distortion effect

  // const dudvMap = new TextureLoader().load( 'textures/waterdudv.jpg', function () {
  //
  // 	animate();
  //
  // } );
  //
  // dudvMap.wrapS = dudvMap.wrapT = RepeatWrapping;
  // refractor.material.uniforms.tDudv.value = dudvMap;

  //

  // gui.add(height,'height').min(50).max(1000).step(1);
  // walls
  walls(null, true);

  // const planeFront = new Mesh( planeGeo, new MeshPhongMaterial( { color: 0x8a5a44 } ) );
  // planeFront.position.z =  50;
  // planeFront.position.y = 50;
  // scene.add( planeFront );

  // document.addEventListener( 'mousemove', onPointerMove );
  window.addEventListener("resize", onWindowResize);
  // window.addEventListener( 'pointerdown', function ( event ) {

  // mouseCoords.set(
  // 	( event.clientX / window.innerWidth ) * 2 - 1,
  // 	- ( event.clientY / window.innerHeight ) * 2 + 1
  // );
  //
  // raycaster.setFromCamera( mouseCoords, camera );
  // const mt = new MeshBasicMaterial({ color: "#6b705c" });
  // const mt1 = new MeshBasicMaterial({ color: "#ffe8d6" });
  // const mt3 = new MeshBasicMaterial({ color: "#7f5539" });
  // const mt2 = new MeshBasicMaterial({ color: "#f8edeb" });

  // const loaderr = new OBJLoader();
  // // loaderr.load('/obj/Base Cabinet 600.obj', function (Objobject) {
  // loaderr.load("/obj/BU-45.obj", function (Objobject) {
  //   // loaderr.load('./models/obj/emerald.obj', function (Objobject) {

  //   // Objobject.geometry.parameters.width = 1;
  //   // Objobject.geometry.parameters.height = 1;
  //   // Objobject.geometry.parameters.depth = 1;
  //   // var box = new Box3().setFromObject(Objobject);
  //   // let radius = box.getBoundingSphere().radius;
  //   // let scale = 200/radius;
  //   // console.log(scale);
  //   // Objobject.scale.multiplyScalar(scale);

  //   Objobject.scale.x = 0.00125;
  //   Objobject.scale.y = 0.00125;
  //   Objobject.scale.z = 0.00125;
  //   // Objobject.scale.z= 0.001;
  //   // Objobject.scale.setScalar(0.00125);
  //   // Objobject.rotation.x= 270.2;
  //   // Objobject.position.y -=1
  //   console.log(Objobject.position.y);
  //   Objobject.rotation.x = Math.PI * 2;

  //   // Objobject.children[0].material.map = texture;
  //   // Objobject.children[0].material.map = texture;
  //   // Objobject.children[1].material.map = textureTest;

  //   // Objobject.children[4].material.map = textureTest;
  //   // // Objobject.children[4].material.map = texture;
  //   // Objobject.children[5].material.map = textureTest;
  //   // // Objobject.children[5].material.map = texture;

  //   // Objobject.children[6].material.map = texture;
  //   // Objobject.children[6].material.map.minFilter = LinearFilter;
  //   // texture.wrapS = RepeatWrapping
  //   // texture.wrapT = RepeatWrapping
  //   // texture.wrapS = MirroredRepeatWrapping
  //   // texture.wrapT = MirroredRepeatWrapping
  //   // Objobject.material = texture;

  //   // Objobject.children[7].material.map = texture;
  //   // const cube = new BoxGeometry(1,1,1);
  //   // const mesh = new Mesh(cube,new MeshBasicMaterial({map:texture}));
  //   // scene.add(mesh);

  //   // console.log(Objobject.children);

  //   // Objobject.rotation.y= 0 ;
  //   // Objobject.rotation.y= - (Math.PI * 4 ) ;
  //   // Objobject.rotation.z = -  Math.PI * 0.5;

  //   Objobject.position.x = 0;
  //   // Objobject.position.y =  - 0.45 ;
  //   Objobject.position.z = 0;

  //   Objobject.castShadow = true;

  //   epse += 0.6;
  //   //  const material = new MeshBasicMaterial({color:'#2100a1'});
  //   //
  //   // // console.log(Objobject.position);
  //   Objobject.traverse(function (child) {
  //     if (child instanceof Mesh) {
  //       child.material.map = texture;
  //     }
  //   });
  //   // console.log(Objobject.scale.x );
  //   objects.push(Objobject);
  //   // objects.push(Objobject);

  //   scene.add(Objobject);

  //   animate();
  // });
  // renderer.domElement.addEventListener( 'mousedown', onMouseDown );
  // renderer.domElement.addEventListener("click", onClick, true);
  // raycaster = new Raycaster();
  // renderer.domElement.addEventListener( 'click', raycast, false );
  let btn2D = document.getElementById("2d");
  // btn2D.addEventListener("click", () => {
  //   // console.log("2d   683");

  //   to2D(false, true);
  // });

  canvas.addEventListener("mousedown", onDocumentMouseDown, false);
  animate();

  // } );
  // dragControls = new DragControls([...objects], camera, renderer.domElement);
  //   dragControls.transformGroup = true;
  //   dragControls.addEventListener("drag", render);

  //   dragControls.addEventListener("dragstart", function () {
  //     controls.enabled = false;
  //   });
  //   dragControls.addEventListener("dragend", function () {
  //     controls.enabled = true;
  //   });
}

// function onPointerMove(event) {
//   console.log('event.clientX  ' , event.clientX , '  event.clientY  ' , event.clientY);
//   // pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
//   // pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
//   // render();
// }

async function walls(type = null, drawLights = false) {
  (planeBack = undefined),
    (planeFront = undefined),
    (planeLeft = undefined),
    (planeRight = undefined),
    (planeGeo = undefined),
    (planeGeoBack = undefined),
    (planeGeoLR = undefined);
  dragLeftWall = undefined;
  dragRightWall = undefined;
  dragBackWall = undefined;
  dragFrontWall = undefined;

  for (let index = 0; index < scene.children.length; index++) {
    if (
      scene.children[index].name == "planeFront" ||
      scene.children[index].name == "planeBack" ||
      scene.children[index].name == "planeLeft" ||
      scene.children[index].name == "planeTop" ||
      scene.children[index].name == "planeRight"
    ) {
      // console.log("Deleted ok");
      // scene.children[index].name="Deleted";
      scene.children[index].layers.set(1);
      scene.remove(scene.children[index]);
      index--;
      // scene.children[index].visible=false;

      // index--;
    }
  }
  // console.log('scene length AA' , scene.children.length);
  // console.log('scene length AA' , scene.children);

  // console.log("scene ", scene);
  // Front and Back
  planeGeoBack = new BoxGeometry(
    measuresXG.max - measuresXG.min + 0.2,
    measures.height + 0.2,
    0.2
  );

  // Left and Right
  planeGeoLR = new BoxGeometry(
    measuresZG.max - measuresZG.min + 0.2,
    measures.height + 0.2,
    0.2
  );

  // Ground
  planeGeo = new BoxGeometry(
    measuresXG.max - measuresXG.min + 0.2,
    measuresZG.max - measuresZG.min + 0.2,
    0.2
  );

  console.log("planeTop   ", planeTop);
  // if(!planeTop || planeTop.visible == true ){
  planeTop = new Mesh(
    planeGeo,
    new MeshPhysicalMaterial({ map: textureCeiling })
  );
  planeTop.position.y = measures.height;
  planeTop.rotateX(Math.PI / 2);
  planeTop.name = "planeTop";
  planeTop.castShadow = true;
  planeTop.receiveShadow = true;
  if (planeBottom) {
    planeTop.position.x = planeBottom.position.x;
    planeTop.position.z = planeBottom.position.z;
  }
  if (is2D) planeTop.visible = false;
  // planeTop.material.map.repeat.set(
  //   (measuresXG.max * 2) / 0.6,
  //   (measuresXG.max * 2) / 0.6
  // );
  scene.add(planeTop);

  if (type == null) {
    // }
    textureFloor.mapping = EquirectangularRefractionMapping;
    textureFloor.envMap = textureFloor.envMap = textureFloor;
    textureFloor.needsUpdate = true;
    // textureFloor.reflectivity = 1;
    planeBottom = new Mesh(
      planeGeo,
      new MeshPhysicalMaterial({ map: textureFloor })
    );

    // planeBottom.position.x = 2;
    // planeBottom.material.map.repeat.set(
    //   (measuresXG.max * 2) / 0.6,
    //   (measuresXG.max * 2) / 0.6
    // );
    // console.log("planeBottom   ", planeBottom);
    planeBottom.position.x = (measuresXG.max + measuresXG.min) / 2;
    planeBottom.position.z = (measuresZG.max + measuresZG.min) / 2;
    planeBottom.rotateX(-Math.PI / 2);
    planeBottom.castShadow = true;
    planeBottom.receiveShadow = true;
    planeBottom.name = "planeBottom";

    // let groundMirror = new Reflector( planeBottom.geometry, {
    //   clipBias: 0.003,
    //   textureWidth: window.innerWidth * window.devicePixelRatio,
    //   textureHeight: window.innerHeight * window.devicePixelRatio,
    //   color: 0x777777
    // } );
    // groundMirror.position.y = planeBottom.position.y;
    // groundMirror.rotateX( - Math.PI / 2 );
    // groundMirror.scale.z = 0.1;
    // scene.add( groundMirror );
    scene.add(planeBottom);

    planeBottom.material = new MeshReflectorMaterial(
      renderer,
      camera,
      scene,
      planeBottom,
      {
        resolution: 1024,
        blur: [1024, 1024],
        mixBlur: 1.0,
        mixContrast: 1.0,
        mirror: 0,
      }
    );

    planeBottom.material.setValues({
      // roughnessMap: new TextureLoader().load("/images/roughness.jpg"),
      roughnessMap: textureFloor,
      map: textureFloor,
      // normalMap: textureFloor,
      // normalScale: new Vector2(0.3, 0.3),
      // normalMap: new TextureLoader().load("/normal.png"),
      // normalScale: new Vector2(0.3, 0.3)
    });
    planeBottom.castShadow = true;

    planeBottom.receiveShadow = true;
  }
  // planeBottom.scale.y = 1;
  // scene.add(planeBottom);

  // if (type != "wallFront") {

  textureWalls.wrapS = textureWalls.wrapT = RepeatWrapping;
  // textureWalls.offset.set(0.02, 0.02);
  // textureWalls.repeat.set(0.02, 0.02);
  textureWalls.anisotropy = 4;

  planeFront = new Mesh(
    planeGeoBack,
    new MeshPhysicalMaterial({ map: textureWalls })
  );
  planeFront.position.z = measuresZG.max;
  planeFront.position.x = (measuresXG.max + measuresXG.min) / 2;
  planeFront.position.y = 0;
  planeFront.scale.y = 0;
  planeFront.visible = false;

  planeFront.castShadow = true;

  planeFront.receiveShadow = true;
  planeFront.name = "planeFront";
  // const smileyEye2Path = new Path()
  // .moveTo( 65, 20 )
  // .absarc( 55, 20, 10, 0, Math.PI * 2, true );
  // planeFront.holes.push( smileyEye1Path );

  // console.log("planeFront.position.x  ", planeFront.position.x);
  // console.log("planeFront.position.z  ", planeFront.position.z);

  scene.add(planeFront);
  // }
  // if (type != "wallBack") {
  planeBack = new Mesh(
    planeGeoBack,
    new MeshPhongMaterial({ map: textureWalls })
  );
  planeBack.position.z = measuresZG.min;
  planeBack.position.x = (measuresXG.max + measuresXG.min) / 2;
  planeBack.castShadow = true;

  planeBack.receiveShadow = true;
  planeBack.position.y = measures.height / 2;
  // planeBack.castShadow = true;

  // console.log('backOpenings  length',backOpenings.length);

  if (backOpenings.length > 0) {
    // console.log("BBB");

    let meshB = new Mesh(
      new BoxGeometry(
        backOpenings[0].userData.W - 0.05,
        backOpenings[0].userData.H - 0.1,
        0.2
      ),
      new MeshPhysicalMaterial({ color: new Color("#FF5512") })
    );
    meshB.position.add(
      new Vector3(
        backOpenings[0].position.x - backOpenings[0].userData.W / 2,
        backOpenings[0].position.y + backOpenings[0].userData.H / 2,
        planeBack.position.z
      )
    );

    planeBack.updateMatrix();
    meshB.updateMatrix();

    let bspA = CSG.default.fromMesh(planeBack);
    let bspB = CSG.default.fromMesh(meshB);

    let bspResult = bspA.subtract(bspB);

    for (let b = 1; b < backOpenings.length; b++) {
      let meshB = new Mesh(
        new BoxGeometry(
          backOpenings[b].userData.W - 0.05,
          backOpenings[b].userData.H - 0.1,
          0.2
        ),
        new MeshStandardMaterial({ color: new Color("#FF5512") })
      );
      meshB.position.add(
        new Vector3(
          backOpenings[b].position.x - backOpenings[0].userData.W / 2,
          backOpenings[b].position.y + backOpenings[0].userData.H / 2,
          planeBack.position.z
        )
      );
      meshB.updateMatrix();
      let bspB = CSG.default.fromMesh(meshB);
      bspResult = bspResult.subtract(bspB);
    }
    planeBack = CSG.default.toMesh(
      bspResult,
      planeBack.matrix,
      planeBack.material
    );
  }
  // console.log("BBB");
  planeBack.castShadow = true;
  planeBack.receiveShadow = true;
  planeBack.name = "planeBack";
  // planeBack.material.map = textureWalls;

  // console.log("LLLL  ",planeBack.userData.llll);
  scene.add(planeBack);

  // console.log('planeBack  ' , planeBack);

  // const clipPlanes = [
  //   plane
  // ];
  // planeBack.material.clippingPlanes = clipPlanes;
  // planeBack.material.clipIntersection = true;
  // planeBack.material.needsUpdate = true
  // planeBack.receiveShadow = true;
  // planeBack.name = "planeBack";
  // scene.add(planeBack);
  // }
  // if (type != "wallRight") {
  planeRight = new Mesh(
    planeGeoLR,
    new MeshPhysicalMaterial({ map: textureWalls })
  );
  planeRight.position.x = measuresXG.max;
  planeRight.position.z = (measuresZG.max + measuresZG.min) / 2;
  planeRight.castShadow = true;

  planeRight.receiveShadow = true;
  planeRight.position.y = measures.height / 2;
  planeRight.rotateY(-Math.PI / 2);

  if (rightOpenings.length > 0) {
    let meshB = new Mesh(
      new BoxGeometry(
        0.4,
        rightOpenings[0].userData.H - 0.1,
        rightOpenings[0].userData.W - 0.05
      ),
      new MeshStandardMaterial({ color: new Color("#FF5512") })
    );
    meshB.position.add(
      new Vector3(
        planeRight.position.x,
        rightOpenings[0].position.y + rightOpenings[0].userData.H / 2,
        rightOpenings[0].position.z - rightOpenings[0].userData.W / 2
      )
    );

    planeRight.updateMatrix();
    meshB.updateMatrix();

    let bspA = CSG.default.fromMesh(planeRight);
    let bspB = CSG.default.fromMesh(meshB);

    let bspResult = bspA.subtract(bspB);

    for (let b = 1; b < rightOpenings.length; b++) {
      let meshB = new Mesh(
        new BoxGeometry(
          0.4,
          rightOpenings[b].userData.H - 0.1,
          rightOpenings[b].userData.W - 0.05
        ),
        new MeshStandardMaterial({ color: new Color("#FF5512") })
      );
      meshB.position.add(
        new Vector3(
          planeRight.position.x,
          rightOpenings[b].position.y + rightOpenings[b].userData.H / 2,
          rightOpenings[b].position.z - rightOpenings[b].userData.W / 2
        )
      );
      meshB.updateMatrix();
      let bspB = CSG.default.fromMesh(meshB);
      bspResult = bspResult.subtract(bspB);
    }
    planeRight = CSG.default.toMesh(
      bspResult,
      planeRight.matrix,
      planeRight.material
    );
  }

  planeRight.castShadow = true;
  planeRight.receiveShadow = true;
  planeRight.name = "planeRight";
  // planeRight.material.map = textureWalls;
  scene.add(planeRight);
  // }
  // if (type != "wallLeft") {
  planeLeft = new Mesh(
    planeGeoLR,
    new MeshPhysicalMaterial({ map: textureWalls })
  );
  planeLeft.position.x = measuresXG.min;
  planeLeft.position.z = (measuresZG.max + measuresZG.min) / 2;
  planeLeft.castShadow = true;

  planeLeft.receiveShadow = true;
  planeLeft.position.y = measures.height / 2;
  planeLeft.rotateY(Math.PI / 2);

  if (leftOpenings.length > 0) {
    let meshB = new Mesh(
      new BoxGeometry(
        0.4,
        leftOpenings[0].userData.H - 0.1,
        leftOpenings[0].userData.W - 0.05
      ),
      new MeshStandardMaterial({ color: new Color("#005512") })
    );

    meshB.position.add(
      new Vector3(
        leftOpenings[0].position.x,
        leftOpenings[0].position.y + leftOpenings[0].userData.H / 2,
        leftOpenings[0].position.z + leftOpenings[0].userData.W / 2
      )
    );
    // console.log("planeLeft  before 1", planeLeft);

    planeLeft.updateMatrix();
    // scene.add(   meshB);
    meshB.updateMatrix();
    // console.log("planeLeft  before ", planeLeft);
    let bspA = CSG.default.fromMesh(planeLeft);
    let bspB = CSG.default.fromMesh(meshB);

    let bspResult = bspA.subtract(bspB);
    // console.log("bspResult  ", bspResult);

    for (let b = 1; b < leftOpenings.length; b++) {
      let meshB = new Mesh(
        new BoxGeometry(
          0.4,
          leftOpenings[b].userData.H - 0.1,
          leftOpenings[b].userData.W - 0.05
        ),
        new MeshStandardMaterial({ color: new Color("#005512") })
      );
      meshB.position.add(
        new Vector3(
          leftOpenings[b].position.x,
          leftOpenings[b].position.y + leftOpenings[b].userData.H / 2,
          leftOpenings[b].position.z + leftOpenings[b].userData.W / 2
        )
      );
      meshB.updateMatrix();

      let bspB = CSG.default.fromMesh(meshB);
      bspResult = bspResult.subtract(bspB);
    }
    // console.log("planeLeft  ", planeLeft);
    planeLeft = CSG.default.toMesh(
      bspResult,
      planeLeft.matrix,
      planeLeft.material
    );
    // console.log("planeLeft.matrix after  ", planeLeft.matrix);
    // console.log("bspResult after  ", planeLeft);
  }

  planeLeft.castShadow = true;
  planeLeft.receiveShadow = true;
  planeLeft.name = "planeLeft";
  // planeLeft.material.map.repeat.set(
  //   (measuresXG.max * 2) / 0.9,
  //   (measuresXG.max * 2) / 0.9
  // );
  planeLeft.material.cleacoatRoughness = 0.1;
  planeLeft.material.cleacoat = 1.0;
  // planeLeft.material.map = textureWalls;

  scene.add(planeLeft);

  // console.log('Scene Here   ',scene);

  // }
  if (is2D) {
    // if (type != "wallLeft") {
    planeLeftCoordinates.scale = planeLeft.scale.y;
    planeLeft.scale.y = 0.000001;
    planeLeftCoordinates.position = planeLeft.position.y;
    planeLeft.position.y = 0.1;
    // scene.add(planeLeft);
    // }
    planeTop.visible = false;

    // if (type != "wallRight") {
    planeRightCoordinates.scale = planeRight.scale.y;
    planeRight.scale.y = 0.000001;
    planeRightCoordinates.position = planeRight.position.y;
    planeRight.position.y = 0.1;
    // scene.add(planeRight);
    // }
    // if (type != "wallBack") {
    planeBackCoordinates.scale = planeBack.scale.y;
    planeBack.scale.y = 0.000001;
    planeBackCoordinates.position = planeBack.position.y;
    planeBack.position.y = 0.1;
    // }
    // scene.add(planeRight);

    // scene.add(planeTop);
    // if (type != "wallFront") {
    // planeFront.visible = true;
    planeFront.scale.y = 0.000001;
    planeFront.position.y = 0.1;
    // scene.add(planeFront);
    // }
    // planeBack.layers.set( 1 );
    // planeFront.layers.set( 1 );
    // planeLeft.layers.set( 1 );
    // planeRight.layers.set( 1 );
  }

  // let ambientLight = new AmbientLight(new Color('hsl(0, 0%, 100%)'), 0.75);
  //   scene.add(ambientLight);

  // let directionalLightBack = new DirectionalLight(new Color('hsl(0, 0%, 100%)'), 0.25);
  // directionalLightBack.position.set(30, 100, 100);
  // directionalLightBack.shadow.mapSize.width = 1024
  // directionalLightBack.shadow.mapSize.height = 1024
  // scene.add(directionalLightBack);

  // let directionalLightFront = new DirectionalLight(new Color('hsl(0, 0%, 100%)'), 0.25);
  // directionalLightFront.position.set(-30, 100, -100);
  // directionalLightFront.shadow.mapSize.width = 1024
  // directionalLightFront.shadow.mapSize.height = 1024
  // scene.add(directionalLightFront);
  ///
  // mainLight = new PointLight(0xcccfff, 0.8, 12);
  // mainLight.position.y = measures.height - 0.5;

  // scene.add(mainLight);

  // var hemiLight = new HemisphereLight( 0xffffff, 0x444444 );
  // hemiLight.position.set( 0, 300, 0 );
  // hemiLight.castShadow = true;
  // hemiLight.receiveShadow = true;
  // scene.add( hemiLight );
  //// Lights
  if (drawLights) {
    // const directionalLightRight = new DirectionalLight("#ffffff", 0.05);
    // directionalLightRight.position.set(
    //   +measuresXG.max - 0.3,
    //   measures.height + 3,
    //   0
    // );
    // directionalLightRight.castShadow = true;
    // directionalLightRight.receiveShadow = true;
    // // directionalLightRight.shadow.normalBias = 0.09;
    // // directionalLightRight.shadow.bias = -0.0001;
    // directionalLightRight.shadow.mapSize.width = 1024;
    // directionalLightRight.shadow.mapSize.height = 1024;
    // console.log("directionalLightRight added");
    // scene.add(directionalLightRight);

    // const spotLight = new SpotLight( 0xecff00 ,0.2);
    // spotLight.position.set( measuresXG.min+wallWidth, measures.height, measuresZG.min+(wallWidth *5) );
    // spotLight.map = textureWalls;

    // spotLight.castShadow = true;
    // spotLight.receiveShadow = true;

    // spotLight.shadow.mapSize.width = 1024;
    // spotLight.shadow.mapSize.height = 1024;

    // spotLight.shadow.camera.near = 500;
    // spotLight.shadow.camera.far = 4000;
    // spotLight.shadow.camera.fov = 30;

    // scene.add( spotLight );

    var hemiLight = new HemisphereLight(0xaaaaaa, 0xaaaaaa, 1);

    // const hemiLight = new HemisphereLight(  0xaaaaaa, 0x444444 );
    // hemiLight.position.set( 0, 400, 0 );
    //  hemiLight.position.set( 50, 300, 0 );
    // hemiLight.castShadow = true;
    // hemiLight.receiveShadow = true;
    scene.add(hemiLight);

    const spotLightRight = new SpotLight(0xecff00, 0.2);
    spotLightRight.position.set(
      measuresXG.max - wallWidth,
      measures.height,
      measuresZG.min + wallWidth * 5
    );
    spotLightRight.map = textureWalls;

    spotLightRight.castShadow = true;
    spotLightRight.receiveShadow = true;

    spotLightRight.shadow.mapSize.width = 1024;
    spotLightRight.shadow.mapSize.height = 1024;

    spotLightRight.shadow.camera.near = 500;
    spotLightRight.shadow.camera.far = 4000;
    spotLightRight.shadow.camera.fov = 30;

    scene.add(spotLightRight);

    const spotLightLeft = new SpotLight(0xecff00, 0.3);
    spotLightLeft.position.set(
      measuresXG.min + wallWidth,
      measures.height / 2 - 1,
      measuresZG.min + wallWidth
    );
    spotLightLeft.map = textureWalls;

    spotLightLeft.castShadow = true;
    // spotLightTest.receiveShadow = true;

    spotLightLeft.shadow.mapSize.width = 1024;
    spotLightLeft.shadow.mapSize.height = 1024;

    spotLightLeft.shadow.camera.near = 500;
    spotLightLeft.shadow.camera.far = 4000;
    spotLightLeft.shadow.camera.fov = 30;

    scene.add(spotLightLeft);
    // const spotLight3 = new SpotLight( 0xecff00 ,0.2);
    // spotLight3.position.set( measuresXG.max-wallWidth, measures.height, measuresZG.max-(wallWidth *5) );
    // spotLight3.map = textureWalls;

    // spotLight3.castShadow = true;
    // spotLight3.receiveShadow = true;

    // spotLight3.shadow.mapSize.width = 1024;
    // spotLight3.shadow.mapSize.height = 1024;

    // spotLight3.shadow.camera.near = 500;
    // spotLight3.shadow.camera.far = 4000;
    // spotLight3.shadow.camera.fov = 30;

    // // scene.add( spotLight3 );

    // const spotLight4 = new SpotLight( 0xecff00 ,0.2);
    // spotLight4.position.set( measuresXG.min+wallWidth, measures.height, measuresZG.max-(wallWidth *5) );
    // spotLight4.map = textureWalls;

    // spotLight4.castShadow = true;
    // spotLight4.receiveShadow = true;

    // spotLight4.shadow.mapSize.width = 1024;
    // spotLight4.shadow.mapSize.height = 1024;

    // spotLight4.shadow.camera.near = 500;
    // spotLight4.shadow.camera.far = 4000;
    // spotLight4.shadow.camera.fov = 30;

    // scene.add( spotLight4 );

    // const spotLightTest = new SpotLight( 0xecff00 ,0.5);
    // spotLightTest.position.set( 0, measures.height+2, 0 );
    // spotLightTest.map = textureWalls;

    // spotLightTest.castShadow = true;
    // // spotLightTest.receiveShadow = true;

    // spotLightTest.shadow.mapSize.width = 1024;
    // spotLightTest.shadow.mapSize.height = 1024;

    // spotLightTest.shadow.camera.near = 500;
    // spotLightTest.shadow.camera.far = 4000;
    // spotLightTest.shadow.camera.fov = 30;

    // scene.add( spotLightTest );
  }

  // var dirLight = new AmbientLight( 0xffffff );
  // dirLight.intensity = 0.9;
  // dirLight.position.set( 75, 100, -75 );
  // scene.add( dirLight );
  // var dirLight = new DirectionalLight( 0xffffff );
  // dirLight.position.set( 75, 300, -75 );
  // scene.add( dirLight );

  /////////////////////////////////////////////////
  // backLight = new PointLight(0xcccfff, 0.8, 12);
  // backLight.position.y = measures.height - 0.5;
  // // backLight.castShadow = true;
  // // backLight.receiveShadow = true;
  // // backLight.shadow.mapSize.width = 1024
  // // backLight.shadow.mapSize.height = 1024
  // scene.add(backLight);

  // let newLight = new PointLight(0xcccfff, 0.8, 12);
  // newLight.position.y = 0.7;
  // newLight.position.z = 0;
  // newLight.position.x = +measures.width/2 ;
  // // backLight.castShadow = true;
  // // backLight.receiveShadow = true;
  // // backLight.shadow.mapSize.width = 1024
  // // backLight.shadow.mapSize.height = 1024
  // scene.add(newLight);

  // redLight = new PointLight(0xffffff, 0.4, 12);
  // // redLight.castShadow = true;
  // // redLight.receiveShadow = true;
  // // redLight.shadow.mapSize.width = 1024
  // // redLight.shadow.mapSize.height = 1024
  // redLight.position.set(-measuresXG.max + 0.2, measures.height - 0.3, 0);

  // scene.add(redLight);

  // const spotLight1 = new SpotLight("#ffffff", 0.2);
  // spotLight1.position.set(
  //   +measuresXG.max - 0.6,
  //   measures.height,
  //   -measures.length / 2 + 0.6
  // );

  // spotLight1.castShadow = true;
  // spotLight1.receiveShadow = true;
  // // directionalLightRight.shadow.normalBias = 0.05;
  // spotLight1.shadow.bias = -0.0001;
  // spotLight1.shadow.mapSize.width = 1024
  // spotLight1.shadow.mapSize.height = 1024
  // spotLight1.shadow.camera.top = 3
  // spotLight1.shadow.camera.right = 6
  // spotLight1.shadow.camera.left = - 6
  // spotLight1.shadow.camera.bottom = - 3
  // spotLight1.shadow.camera.far = 10
  // console.log("directionalLightRight added");
  // scene.add(spotLight1);

  // const spotLight2 = new SpotLight("#ffffff", 0.2);
  // spotLight2.position.set(
  //   -measuresXG.max + 0.6,
  //   measures.height,
  //   +measures.length / 2 - 0.6
  // );
  // spotLight2.castShadow = true;
  // spotLight2.receiveShadow = true;
  // // directionalLightRight.shadow.normalBias = 0.05;
  // spotLight2.shadow.bias = -0.0001;
  // spotLight2.shadow.mapSize.width = 1024
  // spotLight2.shadow.mapSize.height = 1024
  // console.log("directionalLightRight added");
  // scene.add(spotLight2);

  ////////////////////////////////////////

  // greenLight = new PointLight(0xffffff, 0.4, 12);
  // greenLight.position.set(measuresXG.max - 0.2, measures.height - 0.3, 0);
  // scene.add(greenLight);
  // // // //
  // const directionalLightLeft = new DirectionalLight('#ffffff', 0.5)
  // directionalLightLeft.position.set(-measures.width/2 - 1.5, measures.height - 2.9, -measures.length/2);
  // directionalLightLeft.castShadow = true;
  // directionalLightLeft.receiveShadow = true;
  // scene.add(directionalLightLeft)
  ////
  // frontLight = new PointLight(0xcccfff, 0.4, 12);
  // frontLight.position.set(0, 1, measures.width);
  // scene.add(frontLight);
}

async function updateChangeDimensions(
  updateDialog = true,
  plane = null,
  wall = null
) {
  // if (is2D) {
  //   to2D();
  //   to2D();
  // }

  // await setChanges(plane);
  await walls(wall);
  // if (updateDialog) {
  //   // lengthGui.updateDisplay();
  //   // widthGui.updateDisplay();

  // }
}
/**
 * Events
 */
function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  // renderer.outputEncoding = sRGBEncoding;
  renderer.domElement.addEventListener(
    "webglcontextrestored",
    function (event) {
      const updateMaterial = function (material) {
        material.needsUpdate = true;
        for (var key in material)
          if (material[key] && material[key].isTexture) {
            material[key].needsUpdate = true;
          }
      };
      scene.traverse(function (object) {
        if (object.geometry) {
          for (var key in object.geometry.attributes) {
            object.geometry.attributes[key].needsUpdate = true;
          }
          if (object.geometry.index) {
            object.geometry.index.needsUpdate = true;
          }
        }
        if (object.material) {
          if (object.material.length) {
            object.material.forEach(updateMaterial);
          } else {
            updateMaterial(object.material);
          }
        }
      });
      try {
        scene.backgound.needsUpdate = true;
      } catch (e) {}
    }
  );
}

function animate() {

  requestAnimationFrame(animate);

  const time = clock.getElapsedTime();
  let deltaSeconds = 2;
  if (mixer != null) mixer.update(deltaSeconds);
  if (mixer2 != null) mixer2.update(deltaSeconds);
  if (mixer3 != null) mixer3.update(deltaSeconds);
  if (mixer4 != null) mixer4.update(deltaSeconds);

  // refractor.material.uniforms.time.value = time;
  // refractor.visible = false;

  renderer.shadowMap.enabled = true;
  // renderer.outputEncoding = sRGBEncoding;
  // renderer.toneMapping = ReinhardToneMapping;
  // renderer.toneMapping = ACESFilmicToneMapping;
  // renderer.toneMappingExposure = 1.25;
  renderer.render(scene, camera);
}

function onKeyDown(event) {
  enableSelection = false;
}

function onKeyUp() {}
var mouse_vector = new Vector3();
var mouse = { x: 0, y: 0, z: 1 };

function render() {
  renderer.shadowMap.enabled = true;
  // renderer.outputEncoding = sRGBEncoding;
  //  renderer.toneMapping = ACESFilmicToneMapping;
  // renderer.toneMappingExposure = 1.25;
  renderer.render(scene, camera);
  window.scene = scene;
}

// tick()
window.addObjects = async (
  objName,
  measure,
  Type,
  isElement,
  ElType = null,
  heightable = null,
  directional = null
) => {
  console.log("ADD Object");

  const dimentions = measure.split("-");
  const loaderr = new GLTFLoader();
  const loader2 = new GLTFLoader();
  let objectsAdd = [];
  let allObjects = [];
  let positionX = 0;
  let positionZ = 0;
  let positionY = 0;
  // const loader2 = new GLTFLoader();
  // loader2.load("/obj/newObjects/" + objName + ".glb", function ( gltf ) {

  //   console.log('gltf ' , gltf);
  //   gltf.scene.traverse( function ( child ) {

  //     if ( child.isMesh ) {
  //       child.castShadow = true;
  //       child.receiveShadow = true;
  //       // textureFloor.encoding = sRGBEncoding;
  //       // textureFloor.minFilter = NearestFilter;
  //       // textureFloor.magFilter = NearestFilter;
  //       // textureFloor.encoding = sRGBEncoding;
  //       // textureFloor.flipY = false;
  //       child.material.metalness = 0;
  //       child.material.map = textureFloor;
  //       // child.material.map.encoding=sRGBEncoding
  //       // child.material.needsUpdate = true;

  // renderer.outputEncoding = sRGBEncoding;
  //       // child.material.side = DoubleSide;
  //       // child.material.map = textureWalls;

  //     }
  let objectName;
  // if(isElement)
  objectName = isElement ? objName : objName + " L";
  let objectType = isElement ? 'accessories' : 'objects';

  await loaderr.load(
    // "http://cors-anywhere.herokuapp.com/https://storage.googleapis.com/kitchendata/objects/"+ objectName +".glb",
    // flagTest ? ("https://storage.googleapis.com/kitchendata/objects/"+ objectName +".glb"):("https://alashrafykitchens.s3.me-central-1.amazonaws.com/"+ objectName +".glb"),
    "https://storage.googleapis.com/kitchendata/"+objectType+"/" + objectName + ".glb",
    // "https://alashrafykitchens.s3.me-central-1.amazonaws.com/"+ objectName +".glb",
    // await loaderr.load(
    // "/obj/newObjects/" + objectName + ".glb",
    async function (gltf) {
      console.log("Gltf object ", gltf);
      // RectAreaLightUniformsLib.init();
      // document.getElementById('flagTest').innerHTML = flagTest? 'Google':'AWS';
      flagTest = !flagTest;
      // const geoFloor = new BoxGeometry( 2000, 0.1, 2000 );
      // const matStdFloor = new MeshStandardMaterial( { color: 0x808080, roughness: 0.1, metalness: 0 } );
      // const mshStdFloor = new Mesh( geoFloor, matStdFloor );
      // scene.add( mshStdFloor );
      // Objobject.scale.x = 0.00125;
      // Objobject.scale.y = 0.00125;
      // Objobject.scale.z = 0.00125;
      let Objobject = gltf.scene;
      // console.log("gltf ", gltf);
      // gltf.scene.traverse( function ( child ) {

      //   if ( child.isMesh ) {
      //     child.castShadow = true;
      //     child.receiveShadow = true;
      //     child.material.metalness = 0;
      //     child.material.map = textureFloor;

      //   }

      // } );
      let objectSaved = gltf;
      // scene.add(gltf.scene)

      // Objobject.userData.H = parseFloat(dimentions[0]) / 1000;
      // Objobject.userData.W = parseFloat(dimentions[2]) / 1000;
      // Objobject.userData.L = parseFloat(dimentions[1]) / 1000;

      // Initialization the object with default values
      Objobject.userData.objectImg = "../static/Preview/Base/BU 1-6.png";
      Objobject.userData.structure_id = objName;
      Objobject.userData.door = "OP1";
      Objobject.userData.drawer = "DPH";
      Objobject.userData.decoStripColor = "Not found";
      Objobject.userData.decoStripLight = false;
      Objobject.userData.corniceColor = "Not found";
      Objobject.userData.corniceLight = false;
      Objobject.userData.wallPanelColor = "Not found";
      Objobject.userData.wallPanelHeight = 0;
      Objobject.userData.ovenWidth = 0;
      Objobject.userData.sinkWidth = 0;
      Objobject.userData.hasLightSkirting = false;
      Objobject.userData.visibleBackCover = false;
      Objobject.userData.visibleLeftCover = false;
      Objobject.userData.visibleRightCover = false;
      Objobject.userData.H = isElement
        ? parseFloat(dimentions[0]) / 100
        : parseFloat(dimentions[0]) / 1000;
      Objobject.userData.W = isElement
        ? parseFloat(dimentions[2]) / 100
        : parseFloat(dimentions[2]) / 1000;
      Objobject.userData.L = isElement
        ? parseFloat(dimentions[1]) / 100
        : parseFloat(dimentions[1]) / 1000;

      // if (Type == "T") {
      //   const objectName = objName.split("-");
      //   if (objectName[1] > 11 && objectName[1] < 18) {
      //     Objobject.userData.H = parseFloat(dimentions[1]) / 1000;
      //     Objobject.userData.L = parseFloat(dimentions[0]) / 1000;
      //   }
      // }

      Objobject.userData.directional = directional;
      if (isElement) {
        Objobject.userData.ElType = ElType;

        Objobject.scale.set(
          Objobject.userData.W,
          Objobject.userData.H,
          Objobject.userData.L
        );
      }

      Objobject.rotation.x = Math.PI * 2;

      Objobject.name = Type;
      // initial name of object (timescale)
      Objobject.userData.name = objName;
      Objobject.userData.Beside = null;
      // initial variable of animation (timescale)
      Objobject.userData.timescale = 0.039;

      // Determine the right position of the new object.
      if (objects.length == 0) {
        Objobject.position.x =
          measuresXG.min + Objobject.userData.W + wallWidth;
        Objobject.position.z = measuresZG.min + wallWidth;
      } else {
        const width =
          objects[objects.length - 1].position.x + Objobject.userData.W;
        if (width > measuresXG.max - wallWidth) {
          if (
            objects[objects.length - 1].rotation.y != degrees_to_radians(-90)
          ) {
            Objobject.position.z =
              objects[objects.length - 1].position.z +
              objects[objects.length - 1].userData.L +
              Objobject.userData.W;
          } else {
            Objobject.position.z =
              objects[objects.length - 1].position.z + Objobject.userData.W;
          }

          Objobject.rotation.y = degrees_to_radians(-90);
          Objobject.position.x = measuresXG.max - wallWidth;

          if (Objobject.position.z > measuresZG.max - wallWidth) {
            if (
              objects[objects.length - 1].rotation.y != degrees_to_radians(180)
            ) {
              Objobject.position.x =
                objects[objects.length - 1].position.x -
                objects[objects.length - 1].userData.L -
                Objobject.userData.W;
            } else {
              Objobject.position.x =
                objects[objects.length - 1].position.x - Objobject.userData.W;
            }

            Objobject.position.z = measuresZG.max - wallWidth;
            Objobject.rotation.y = degrees_to_radians(180);

            if (Objobject.position.x < measuresXG.min + wallWidth) {
              if (
                objects[objects.length - 1].rotation.y != degrees_to_radians(90)
              ) {
                Objobject.position.z =
                  objects[objects.length - 1].position.z -
                  objects[objects.length - 1].userData.L -
                  Objobject.userData.W;
              } else {
                Objobject.position.z =
                  objects[objects.length - 1].position.z - Objobject.userData.W;
              }

              Objobject.position.x = -measures.wallWidth / 2 + wallWidth;
              Objobject.rotation.y = degrees_to_radians(90);
            }
          }
        } else {
          Objobject.position.x =
            objects[objects.length - 1].position.x + Objobject.userData.W;

          Objobject.position.z = measuresZG.min + wallWidth;
        }
      }

      if (Type == "W" || Type == "WC" || Type == "Win") {
        if (is2D) Objobject.position.y = wallWidth * 2;
        else Objobject.position.y = measures.height / 2;
      } else {
        Objobject.position.y = wallWidth;
      }
      Objobject.userData.oldPositionY = Objobject.position.y;
      uuidSelected = [];
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].name === "SelectedObject") {
          scene.remove(scene.children[index]);
          index -= 1;
        }
      }

      // set the most repeated color in the scene
      let corpusRepeated = Array.from({ length: 22 }).fill(1),
        maxIndexCorpus = 1;

      let frontRepeated = Array.from({ length: 22 }).fill(1),
        maxIndexFront = 1;
      let toekickRepeated = Array.from({ length: 22 }).fill(1),
        maxIndexToekick = 1;
      let worktopsRepeated = Array.from({ length: 22 }).fill(1),
        maxIndexWorktops = 1;
      for (let i = 0; i < objects.length; i++) {
        if (objects[i].name != "Win" && objects[i].name != "Do") {
          let corpus = objects[i].userData.carcass_out;
          let corpusNo = corpus.substring(2);
          corpusRepeated[corpusNo] += 1;
          if (corpusRepeated[corpusNo] > corpusRepeated[maxIndexCorpus])
            maxIndexCorpus = corpusNo;

          let front = objects[i].userData.shutter_out;
          let frontNo = front.substring(2);
          frontRepeated[frontNo] += 1;
          if (frontRepeated[frontNo] > frontRepeated[maxIndexFront])
            maxIndexFront = frontNo;

          let toekick = objects[i].userData.toekick;
          let toekickNo = toekick.substring(2);
          toekickRepeated[toekickNo] += 1;
          if (toekickRepeated[toekickNo] > toekickRepeated[maxIndexToekick])
            maxIndexToekick = toekickNo;

          let worktops = objects[i].userData.worktops;
          let worktopsNo = worktops.substring(2);
          worktopsRepeated[worktopsNo] += 1;
          if (worktopsRepeated[worktopsNo] > worktopsRepeated[maxIndexWorktops])
            maxIndexWorktops = worktopsNo;
        }
      }

      let scaleShutter;

      // scene.add( new RectAreaLightHelper( rectLight3 ) );
      for (let index = 0; index < Objobject.children.length; index++) {
        // for (let indexj = 0; indexj < Objobject.children[index].children.length; indexj++) {
        // Objobject.children[index].children[indexj] = JSON.stringify(Objobject.children[index].children[indexj]);

        Objobject.children[index].userData.uuid = Objobject.uuid;
        // Objobject.children[index].material.metalness = 0;
        // if(index > 4 && index < 9)
        // {
        if (isElement) {
          Objobject.traverse(function (child) {
            if (child instanceof Mesh) {
              child.material.metalness = 0;
              child.material.color.setHex(0xfefae0);
              // child.material.map = textureWalls;
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
        } else if (
          Objobject.children[index].type == "Mesh" ||
          Objobject.children[index].type == "Group"
        ) {
          textureCorpus.flipY = false;
          textureCorpus.encoding = CubeUVReflectionMapping;
          // textureCorpus.metalness = 0;
          // Objobject.children[index].material.metalness = -1;

          // for (let c = 0; c < Objobject.children[index].children.length; c++) {
          //   console.log("Objobject.children[index].children.length  " , Objobject.children[index].children.length);
          // Objobject.children[index].children[c].material.metalness = -2;

          // }
          // Objobject.children[index].material.metalness = -1;
          if (Objobject.children[index].type == "Mesh") {
            Objobject.children[index].material.metalness = -1;
            if (Objobject.children[index].material.map != null)
              Objobject.children[index].material.map.anisotropy = 16;

            Objobject.children[index].userData.oldMaterial =
              Objobject.children[index].material;
            Objobject.children[index].material.map =
              textureLoader.load("./colors/MC2.png");
          }
          for (let c = 0; c < Objobject.children[index].children.length; c++) {
            Objobject.children[index].children[c].userData.uuid =
              Objobject.uuid;
            Objobject.children[index].children[c].receiveShadow = true;
            Objobject.children[index].children[c].castShadow = true;
            Objobject.children[index].children[c].material.metalness = 0;
            if (Objobject.children[index].children[c].material.map != null)
              Objobject.children[index].children[
                c
              ].material.map.anisotropy = 16;
            Objobject.children[index].children[c].userData.oldMaterial =
              Objobject.children[index].children[c].material;
            Objobject.children[index].children[c].material.map =
              textureLoader.load("./colors/MC2.png");
          }

          // Objobject.children[index].material.roughness = 4;
          // Objobject.children[index].material.clone();
          // Objobject.children[index].material.color.setHex( 0xff00dd );
          // Objobject.children[index].material.map.anisotropy = 16;
          // if (
          //   Objobject.children[index].name.match(/counter_top.*/) ||
          //   Objobject.children[index].name.match(/Shelf.*/)
          // ) {
          //   // Objobject.children[index].visible = false;
          // }
          // if (Objobject.children[index].name.match(/shutter.*/)) {
          //   scaleShutter = Objobject.children[index].scale.x;
          //   // Objobject.children[index].visible = false;
          // }
          if (Objobject.children[index].name.match(/counter_top.*/)) {
            // Objobject.children[index]
            if (Objobject.name == "B")
              Objobject.children[index].visible = false;
          }
          // Objobject.children[index].material.metalness = 1;
          Objobject.children[index].castShadow = true;
          Objobject.children[index].receiveShadow = true;

          if (Objobject.children[index].name.match(/Handle.*/)) {
            Objobject.children[index].visible = false;
          }
        }
      }
      // console.log("textureCorpus   ", textureCorpus);
      Objobject.userData.carcass_out = "MC2";
      Objobject.userData.carcass_in = "MC2";
      Objobject.userData.carcass_edges = "MC2";
      Objobject.userData.shutter_out = "MC2";
      Objobject.userData.shutter_in = "MC2";
      Objobject.userData.shelf = "MC2";
      Objobject.userData.shelf_edges = "MC2";
      Objobject.userData.toekick = "MC2";
      Objobject.userData.worktops = "MC2";

      Objobject.userData.handle = "HP1";

      // Objobject.userData.heightable = ((Objobject.name =! 'B' || heightable == true )? true:false);
      // console.log('heightable ' , heightable);

      if (heightable == true) {
        Objobject.userData.heightable = true;
      } else {
        // console.log("Here");
        if (Objobject.name != "B" && Objobject.name != "T") {
          if (heightable == null) {
            Objobject.userData.heightable = true;
          } else {
            Objobject.userData.heightable = false;
          }
        } else {
          Objobject.userData.heightable = false;
        }
      }
      // Objobject.userData.heightable = ((heightable == true)? true:((Objobject.name == 'B' || heightable == false)?false:true));
      // console.log("Objobject.userData.heightable     ", Objobject.userData.heightable);
      //   Objobject.traverse( function( object ) {

      //     object.frustumCulled = false;

      // } );
      // Objobject.frustumCulled = false;

      // Objobject.userData.door = "OP1";
      // Objobject.userData.drawer = "DPH";
      // Objobject.userData.handle = "HP1";

      //  const material = new MeshBasicMaterial({color:'#2100a1'});
      //
      // // console.log(Objobject.position);
      // Objobject.traverse(function (child) {
      //   if (child instanceof Mesh) {
      //     child.material.map = texture;
      //   }
      // });
      // for (const child of Objobject.children) {
      //   if (child.isMesh) child.material = child.material.clone();
      // }
      // Objobject.children[2].material.map = textureCeiling ;
      // Objobject.children[0].material.map = textureWalls ;
      // Objobject.children[1].material.map = textureFloor ;
      // Objobject.children[3].material.map = textureCorpus ;

      // Objobject.children[4].material.map = textureCorpus ;
      // Objobject.children[4].visible = false ;
      // Objobject.children[5].material.map = textureFloor ;
      // Objobject.children[5].material.map = textureWalls ;
      // Objobject.children[6].material.map = textureCorpus ;
      // Objobject.children[4].visible = false ;
      // Objobject.children[5].visible = false ;
      // Objobject.children[6].visible = false ;
      // Objobject.children[7].visible = false ;
      // Objobject.children[8].visible = false ;
      // Objobject.children[9].visible = false ;

      if (is2D) Objobject.scale.y = 0.1;
      if (!isElement) {
        // Left Cover
        //        loader2.load("/obj/newObjects/cover.glb", function (gltf) {
        loader2.load(
          "https://storage.googleapis.com/kitchendata/accessories/cover.glb",
          function (gltf) {
            let object = gltf.scene;
            Objobject.userData.hasLeftCover = true;
            Objobject.userData.visibleLeftCover = true;

            Objobject.userData.uuidLeftCover = object.uuid;
            let positionX, positionZ;
            positionX = Objobject.position.x;
            positionZ = Objobject.position.z;
            if (Objobject.rotation.y == degrees_to_radians(0)) {
              positionX = Objobject.position.x + 0.018;
            } else if (Objobject.rotation.y == degrees_to_radians(90)) {
              positionZ = Objobject.position.z - 0.018;
            } else if (Objobject.rotation.y == degrees_to_radians(180)) {
              positionX = Objobject.position.x - 0.018;
            } else if (Objobject.rotation.y == degrees_to_radians(-90)) {
              positionZ = Objobject.position.z + 0.018;
            }

            object.position.x = positionX;
            object.position.z = positionZ;
            object.rotation.y = Objobject.rotation.y;
            object.scale.y = Objobject.userData.H;
            if (is2D) object.scale.y = 0.1;

            object.position.y = Objobject.position.y + 0.1;
            console.log(Type);
            if (Type == "W") {
              object.position.y = Objobject.position.y;

              object.scale.z = 0.61;
            }

            heightObj -= 0.189;

            for (let t = 0; t < object.children.length; t++) {
              if (object.children[t].type == "Mesh") {
                object.children[t].userData.uuid = object.uuid;
                object.children[t].material.metalness = 0;
                object.children[t].material.map = textureWalls;

                object.children[t].castShadow = true;
                object.children[t].receiveShadow = true;
              }
            }
            object.name = "Left cover";
            scene.add(object);

            leftCovers.push(object);
            // console.log("leftCovers ", leftCovers);
          }
        );
        // Right Cover
        //        loader2.load("/obj/newObjects/cover.glb", function (gltf) {
        loader2.load(
          "https://storage.googleapis.com/kitchendata/accessories/cover.glb",
          function (gltf) {
            let object = gltf.scene;
            Objobject.userData.hasRightCover = true;
            Objobject.userData.visibleRightCover = true;

            Objobject.userData.uuidRightCover = object.uuid;
            let positionX, positionZ;
            positionX = Objobject.position.x;
            positionZ = Objobject.position.z;
            if (Objobject.rotation.y == degrees_to_radians(0)) {
              positionX = Objobject.position.x - Objobject.userData.W;
            } else if (Objobject.rotation.y == degrees_to_radians(90)) {
              positionZ = Objobject.position.z + Objobject.userData.W;
            } else if (Objobject.rotation.y == degrees_to_radians(180)) {
              positionX = Objobject.position.x + Objobject.userData.W;
            } else if (Objobject.rotation.y == degrees_to_radians(-90)) {
              positionZ = Objobject.position.z - Objobject.userData.W;
            }

            object.position.x = positionX;
            object.position.z = positionZ;
            object.scale.y = Objobject.userData.H;
            object.rotation.y = Objobject.rotation.y;

            if (is2D) object.scale.y = 0.1;

            object.position.y = Objobject.position.y + 0.1;

            if (Type == "W") {
              object.position.y = Objobject.position.y;
            }
            heightObj -= 0.189;

            for (let t = 0; t < object.children.length; t++) {
              if (object.children[t].type == "Mesh") {
                object.children[t].userData.uuid = object.uuid;
                object.children[t].material.metalness = 0;
                object.children[t].material.map = textureWalls;

                object.children[t].castShadow = true;
                object.children[t].receiveShadow = true;
              }
              // Objobject.children.push(object.children[index]);
            }
            object.name = "Right cover";

            scene.add(object);
            // Objobject.children.push(object.children);
            // Objobject.children[6].children[0] = object;
            rightCovers.push(object);
            // console.log("rightCovers ", rightCovers);
          }
        );
        // Back Cover
        //        loader2.load("/obj/newObjects/back.glb", function (gltf) {
        loader2.load(
          "https://storage.googleapis.com/kitchendata/accessories/back.glb",
          function (gltf) {
            let object = gltf.scene;
            Objobject.userData.hasBackCover = true;
            Objobject.userData.visibleBackCover = true;

            Objobject.userData.uuidBackCover = object.uuid;
            // console.log('positionX  ' ,positionX);

            // console.log('positionZ  ' ,positionZ);
            // console.log('positionY  ' ,positionY);
            // Objobject.children[index].position.z = Objobject.position.z + Objobject.userData.L - 0.018;
            // console.log('Objobject.children[j].position.y   ' ,Objobject.children[j].scale.y);
            // console.log('Objobject.position.y   ' ,Objobject.scale.y);
            // console.log('Objobject.children.name   ' ,Objobject.children[j].name);

            // positionY = -10000000000 * Objobject.children[j].scale.y ;
            // console.log('positionY  ' ,positionY);
            object.scale.x = Objobject.userData.W;
            object.scale.y = Objobject.userData.H;

            if (is2D) object.scale.y = 0.1;

            object.position.x = Objobject.position.x;
            object.position.z = Objobject.position.z;
            if (Objobject.rotation.y == degrees_to_radians(0)) {
              object.position.z = Objobject.position.z - 0.001;
            } else if (Objobject.rotation.y == degrees_to_radians(90)) {
              object.position.x = Objobject.position.x - 0.001;
            } else if (Objobject.rotation.y == degrees_to_radians(180)) {
              object.position.z = Objobject.position.z + 0.001;
            } else if (Objobject.rotation.y == degrees_to_radians(-90)) {
              object.position.x = Objobject.position.x + 0.001;
            }
            object.position.y = Objobject.position.y + 0.1;
            if (Type == "W") {
              object.position.y = Objobject.position.y;
            }
            object.rotation.y = Objobject.rotation.y;
            heightObj -= 0.189;
            // console.log(Objobject.scale);
            // console.log(Objobject.position.y);
            // object.rotation.x = Math.PI * 2;

            // console.log("Handle   ", Type);
            // object.name = Objobject.children[j].name+objName + j;
            // object.userData.name = objName;

            // objectsAdd.push(Objobject);

            // var newMesh = new Mesh( object.children[0].geometry, cylBleu );

            // newMesh.add(object);

            // scene.add(Objobject);

            for (let t = 0; t < object.children.length; t++) {
              if (object.children[t].type == "Mesh") {
                object.children[t].userData.uuid = object.uuid;
                object.children[t].material.metalness = 0;
                object.children[t].material.map = textureWalls;

                object.children[t].castShadow = true;
                object.children[t].receiveShadow = true;
              }
              // Objobject.children.push(object.children[index]);
            }
            object.name = "Back cover";

            scene.add(object);
            // Objobject.children.push(object.children);
            // Objobject.children[6].children[0] = object;
            backCovers.push(object);
            // console.log("backCovers ", backCovers);
          }
        );

        Objobject.userData.Direction = "L";
        Objobject.userData.Type = "object";
      }

      positionX = Objobject.position.x - Objobject.userData.W / 2;
      positionY = Objobject.userData.H + 0.118;
      positionZ = Objobject.position.z + Objobject.userData.L - 0.018;
      let heightObj = Objobject.userData.H + 0.1;

      Objobject.userData.wallOffset = 0;
      Objobject.userData.Type = "element";

      /// Add Directional Handle
      if (
        !(isElement && Objobject.userData.ElType != "opening") &&
        Objobject.userData.directional != "none"
      ) {
        const loaderr = new GLTFLoader();
        let name =
          "handle_direction_" +
          (Objobject.userData.ElType != "opening"
            ? "L"
            : Objobject.userData.directional == "double"
            ? "double"
            : "L");
        //        loaderr.load("/obj/newObjects/" + name + ".glb", function (gltf) {
        loaderr.load(
          "https://storage.googleapis.com/kitchendata/accessories/" +
            name +
            ".glb",
          function (gltf) {
            let object = gltf.scene;
            Objobject.userData.hasHandleDirection = true;
            Objobject.userData.uuidDirection = object.uuid;
            Objobject.userData.openingDir = "in";
            object.scale.x = Objobject.userData.W;
            object.scale.y = 0.1;
            object.scale.z = 0.8;
            object.name = "Handle Direction";
            object.position.x = Objobject.position.x;
            object.position.z =
              Objobject.position.z +
              (Objobject.userData.ElType == "opening"
                ? 0.1
                : Objobject.userData.L);
            object.position.y = 0.3;
            // object.rotation.x = degrees_to_radians(-180);
            object.visible = false;
            directions.push(object);
            // object.rotation.x = 180;
            scene.add(object);
          }
        );
      }

      Objobject.userData.finish_uuids = new Array();
      Objobject.userData.objectSaved = objectSaved;
      objects.push(Objobject);
      console.log(Objobject.userData.name);
      scene.add(Objobject);
      /// intersect test
      let i = objects.length - 1;

      objectsAltered = [];

      for (let j = 0; j < objects.length; j++) {
        if (i != j && objects[i].position.y === objects[j].position.y) {
          /// Z
          // 90 degree
          if (objects[j].rotation.y == degrees_to_radians(90)) {
            if (
              Math.abs(objects[i].position.x - objects[j].position.x) <
                Math.max(objects[i].userData.L, objects[j].userData.L) &&
              objects[i].rotation.y == degrees_to_radians(90)
            ) {
              if (
                objects[i].position.z <
                  objects[j].position.z + objects[j].userData.W &&
                objects[i].position.z >= objects[j].position.z
              ) {
                if (
                  objects[j].position.z +
                    objects[j].userData.W +
                    objects[i].userData.W >
                  measuresZG.max - wallWidth
                )
                  if (
                    objects[j].position.z - objects[i].userData.W <
                    measuresZG.min + wallWidth
                  )
                    objects[i].position.x =
                      objects[j].position.x + objects[j].userData.L;
                  else
                    objects[i].position.z =
                      objects[j].position.z - objects[i].userData.W;
                else
                  objects[i].position.z =
                    objects[j].position.z + objects[j].userData.W;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);

                // if (is2D) {
                //   to2D();
                //   to2D();
                // }
                if (objects[i].userData.hasLeftCover) {
                  // console.log("objects[i].userData.hasLeftCover ");
                  for (let index = 0; index < leftCovers.length; index++) {
                    if (
                      leftCovers[index].uuid ==
                      objects[i].userData.uuidLeftCover
                    ) {
                      leftCovers[index].visible = false;
                      // objects[i].userData.visibleLeftCover = false;
                      scene.add(leftCovers[index]);
                      // objects[i].userData.hasLeftCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                if (objects[j].userData.hasRightCover) {
                  // console.log("objects[i].userData.hasRightCover ");

                  for (let index = 0; index < rightCovers.length; index++) {
                    if (
                      rightCovers[index].uuid ==
                      objects[j].userData.uuidRightCover
                    ) {
                      rightCovers[index].visible = false;
                      // objects[j].userData.visibleRightCover = false;

                      scene.add(rightCovers[index]);
                      // objects[i].userData.hasRightCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                objects[j].userData.Beside = objects[i];
                objects[i].userData.Beside = objects[j];
                objects[i].userData.typeBeside = "right";
              } else if (
                objects[i].position.z + objects[i].userData.W >
                  objects[j].position.z &&
                objects[i].position.z <= objects[j].position.z
              ) {
                if (
                  objects[j].position.z - objects[i].userData.W <
                  measuresZG.min + wallWidth
                )
                  if (
                    objects[j].position.z + objects[j].userData.W >
                    measuresZG.max - wallWidth
                  )
                    objects[i].position.x =
                      objects[j].position.x + objects[j].userData.L;
                  else
                    objects[i].position.z =
                      objects[j].position.z + objects[j].userData.W;
                else
                  objects[i].position.z =
                    objects[j].position.z - objects[i].userData.W;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);
                // if (is2D) {
                //   to2D();
                //   to2D();
                // }

                if (objects[j].userData.hasLeftCover) {
                  // console.log("objects[i].userData.hasLeftCover ");
                  for (let index = 0; index < leftCovers.length; index++) {
                    if (
                      leftCovers[index].uuid ==
                      objects[j].userData.uuidLeftCover
                    ) {
                      leftCovers[index].visible = false;
                      // objects[j].userData.visibleLeftCover = false;
                      scene.add(leftCovers[index]);
                      // objects[i].userData.hasLeftCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                if (objects[i].userData.hasRightCover) {
                  // console.log("objects[i].userData.hasRightCover ");

                  for (let index = 0; index < rightCovers.length; index++) {
                    if (
                      rightCovers[index].uuid ==
                      objects[i].userData.uuidRightCover
                    ) {
                      rightCovers[index].visible = false;
                      // objects[i].userData.visibleRightCover = false;
                      scene.add(rightCovers[index]);
                      // objects[i].userData.hasRightCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                objects[i].userData.Beside = objects[j];
                objects[j].userData.Beside = objects[i];
                objects[i].userData.typeBeside = "left";
              }
            }
            if (
              objects[i].position.x - objects[j].position.x <
                objects[i].userData.L + objects[j].userData.L &&
              objects[i].rotation.y == degrees_to_radians(-90) &&
              objects[i].position.x > objects[j].position.x
            ) {
              if (
                objects[i].position.z <
                  objects[j].position.z + objects[j].userData.W &&
                objects[i].position.z >= objects[j].position.z
              ) {
                if (
                  objects[j].position.z - objects[i].userData.W <
                  measuresZG.min + wallWidth
                )
                  if (
                    objects[j].position.z +
                      objects[i].userData.W +
                      objects[j].userData.W >
                    measuresZG.max - wallWidth
                  )
                    objects[i].position.x = objects[j].position.x;
                  else
                    objects[i].position.z =
                      objects[j].position.z +
                      objects[i].userData.W +
                      objects[j].userData.W;
                else objects[i].position.z = objects[j].position.z;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);

                // if (is2D) {
                //   to2D();
                //   to2D();
                // }
                if (objects[i].userData.hasLeftCover) {
                  // console.log("objects[i].userData.hasLeftCover ");
                  for (let index = 0; index < leftCovers.length; index++) {
                    if (
                      leftCovers[index].uuid ==
                      objects[i].userData.uuidLeftCover
                    ) {
                      leftCovers[index].visible = false;
                      // objects[i].userData.visibleLeftCover = false;
                      scene.add(leftCovers[index]);
                      // objects[i].userData.hasLeftCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                if (objects[j].userData.hasRightCover) {
                  // console.log("objects[i].userData.hasRightCover ");

                  for (let index = 0; index < rightCovers.length; index++) {
                    if (
                      rightCovers[index].uuid ==
                      objects[j].userData.uuidRightCover
                    ) {
                      rightCovers[index].visible = false;
                      // objects[j].userData.visibleRightCover = false;

                      scene.add(rightCovers[index]);
                      // objects[i].userData.hasRightCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                objects[j].userData.Beside = objects[i];
                objects[i].userData.Beside = objects[j];
                objects[i].userData.typeBeside = "right";
              } else if (
                objects[i].position.z - objects[i].userData.W <
                  objects[j].position.z + objects[j].userData.W &&
                objects[i].position.z >=
                  objects[j].position.z + objects[j].userData.W
              ) {
                if (
                  objects[j].position.z +
                    objects[i].userData.W +
                    objects[j].userData.W >
                  measuresZG.max - wallWidth
                )
                  if (
                    objects[j].position.z - objects[i].userData.W <
                    measuresZG.min + wallWidth
                  )
                    objects[i].position.x = objects[j].position.x;
                  // objects[j].position.x + objects[j].userData.L + objects[i].userData.L;
                  else objects[i].position.z = objects[j].position.z;
                else
                  objects[i].position.z =
                    objects[j].position.z +
                    objects[i].userData.W +
                    objects[j].userData.W;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);
                // if (is2D) {
                //   to2D();
                //   to2D();
                // }

                if (objects[j].userData.hasLeftCover) {
                  // console.log("objects[i].userData.hasLeftCover ");
                  for (let index = 0; index < leftCovers.length; index++) {
                    if (
                      leftCovers[index].uuid ==
                      objects[j].userData.uuidLeftCover
                    ) {
                      leftCovers[index].visible = false;
                      // objects[j].userData.visibleLeftCover = false;
                      scene.add(leftCovers[index]);
                      // objects[i].userData.hasLeftCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                if (objects[i].userData.hasRightCover) {
                  // console.log("objects[i].userData.hasRightCover ");

                  for (let index = 0; index < rightCovers.length; index++) {
                    if (
                      rightCovers[index].uuid ==
                      objects[i].userData.uuidRightCover
                    ) {
                      rightCovers[index].visible = false;
                      // objects[i].userData.visibleRightCover = false;
                      scene.add(rightCovers[index]);
                      // objects[i].userData.hasRightCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                objects[i].userData.Beside = objects[j];
                objects[j].userData.Beside = objects[i];
                objects[i].userData.typeBeside = "left";
              }
            }

            if (
              objects[i].position.z <
                objects[j].userData.W + objects[j].position.z &&
              objects[i].position.z + objects[i].userData.L >
                objects[j].position.z &&
              objects[i].rotation.y == degrees_to_radians(0) &&
              objects[i].position.x > objects[j].position.x
            ) {
              if (
                objects[i].position.x <
                  objects[j].position.x + objects[j].userData.L &&
                objects[i].position.x >= objects[j].position.x
              ) {
                if (
                  objects[j].position.x - objects[j].userData.W <
                  measuresXG.min + wallWidth
                )
                  objects[i].position.x =
                    objects[j].position.x +
                    objects[i].userData.L +
                    objects[i].userData.W;
                else objects[i].position.x = objects[j].position.x;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);

                // if (is2D) {
                //   to2D();
                //   to2D();
                // }
                // if (objects[i].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[i].userData.visibleLeftCover = false;
                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[j].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[j].userData.visibleRightCover = false;

                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.Beside = objects[j];
                // objects[i].userData.typeBeside = "right";
              } else if (
                objects[i].position.x - objects[i].userData.W <
                  objects[j].position.x + objects[j].userData.L &&
                objects[i].position.x >=
                  objects[j].position.x + objects[j].userData.L
              ) {
                if (
                  objects[j].position.x +
                    objects[j].userData.L +
                    objects[i].userData.W >
                  measuresXG.max - wallWidth
                )
                  objects[i].position.x = objects[j].position.x;
                else
                  objects[i].position.x =
                    objects[j].position.x +
                    objects[j].userData.L +
                    objects[i].userData.W;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);
                // if (is2D) {
                //   to2D();
                //   to2D();
                // }

                // if (objects[j].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[j].userData.visibleLeftCover = false;
                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[i].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[i].userData.visibleRightCover = false;
                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // objects[i].userData.Beside = objects[j];
                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.typeBeside = "left";
              }
            }

            if (
              objects[i].position.z > objects[j].position.z &&
              objects[i].position.z - objects[i].userData.L <
                objects[j].position.z + objects[j].userData.W &&
              objects[i].rotation.y == degrees_to_radians(180)
            ) {
              if (
                objects[i].position.x + objects[i].userData.W <
                  objects[j].position.x + objects[j].userData.L &&
                objects[i].position.z >= objects[j].position.z &&
                objects[i].position.x + objects[i].userData.W >
                  objects[j].position.x
              ) {
                if (
                  objects[j].position.x - objects[i].userData.W <
                  measuresXG.min + wallWidth
                )
                  objects[i].position.x =
                    objects[j].position.x + objects[j].userData.L;
                else
                  objects[i].position.x =
                    objects[j].position.x - objects[i].userData.W;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);

                // if (is2D) {
                //   to2D();
                //   to2D();
                // }
                // if (objects[i].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[i].userData.visibleLeftCover = false;
                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[j].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[j].userData.visibleRightCover = false;

                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.Beside = objects[j];
                // objects[i].userData.typeBeside = "right";
              } else if (
                objects[i].position.x + objects[i].userData.W >
                  objects[j].position.x + objects[j].userData.L &&
                objects[i].position.x <=
                  objects[j].position.x + objects[j].userData.L
              ) {
                if (
                  objects[j].position.x +
                    objects[j].userData.L +
                    objects[i].userData.W >
                  measuresXG.max - wallWidth
                )
                  objects[i].position.x =
                    objects[j].position.x - objects[i].userData.W;
                else
                  objects[i].position.x =
                    objects[j].position.x + objects[j].userData.L;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);
                // if (is2D) {
                //   to2D();
                //   to2D();
                // }

                // if (objects[j].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[j].userData.visibleLeftCover = false;
                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[i].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[i].userData.visibleRightCover = false;
                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // objects[i].userData.Beside = objects[j];
                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.typeBeside = "left";
              }
            }
          }

          // -90 degree
          if (objects[j].rotation.y == degrees_to_radians(-90)) {
            if (
              Math.abs(objects[i].position.x - objects[j].position.x) <
                Math.max(objects[i].userData.L, objects[j].userData.L) &&
              objects[i].rotation.y == degrees_to_radians(-90)
            ) {
              if (
                objects[i].position.z <
                  objects[j].position.z + objects[i].userData.W &&
                objects[i].position.z >= objects[j].position.z
              ) {
                if (
                  objects[j].position.z + objects[i].userData.W >
                  measuresZG.max - wallWidth
                )
                  if (
                    objects[j].position.z -
                      objects[j].userData.W -
                      objects[i].userData.W <
                    measuresZG.min + wallWidth
                  )
                    objects[i].position.x =
                      objects[j].position.x - objects[j].userData.L;
                  else
                    objects[i].position.z =
                      objects[j].position.z - objects[j].userData.W;
                else
                  objects[i].position.z =
                    objects[j].position.z + objects[i].userData.W;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);
                // if (is2D) {
                //   to2D();
                //   to2D();
                // }

                if (objects[j].userData.hasLeftCover) {
                  // console.log("objects[i].userData.hasLeftCover ");
                  for (let index = 0; index < leftCovers.length; index++) {
                    if (
                      leftCovers[index].uuid ==
                      objects[j].userData.uuidLeftCover
                    ) {
                      leftCovers[index].visible = false;
                      // objects[j].userData.visibleLeftCover = false;

                      scene.add(leftCovers[index]);
                      // objects[i].userData.hasLeftCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                if (objects[i].userData.hasRightCover) {
                  // console.log("objects[i].userData.hasRightCover ");

                  for (let index = 0; index < rightCovers.length; index++) {
                    if (
                      rightCovers[index].uuid ==
                      objects[i].userData.uuidRightCover
                    ) {
                      rightCovers[index].visible = false;
                      // objects[i].userData.visibleRightCover = false;

                      scene.add(rightCovers[index]);
                      // objects[i].userData.hasRightCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                objects[i].userData.Beside = objects[j];
                objects[j].userData.Beside = objects[i];
                objects[i].userData.typeBeside = "left";
              } else if (
                objects[i].position.z + objects[j].userData.W >
                  objects[j].position.z &&
                objects[i].position.z <= objects[j].position.z
              ) {
                if (
                  objects[j].position.z -
                    objects[j].userData.W -
                    objects[i].userData.W <
                  measuresZG.min + wallWidth
                )
                  if (
                    objects[j].position.z + objects[i].userData.W >
                    measuresZG.max - wallWidth
                  )
                    objects[i].position.x =
                      objects[j].position.x - objects[j].userData.L;
                  else
                    objects[i].position.z =
                      objects[j].position.z + objects[i].userData.W;
                else
                  objects[i].position.z =
                    objects[j].position.z - objects[j].userData.W;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);
                // if (is2D) {
                //   to2D();
                //   to2D();
                // }
                if (objects[i].userData.hasLeftCover) {
                  // console.log("objects[i].userData.hasLeftCover ");
                  for (let index = 0; index < leftCovers.length; index++) {
                    if (
                      leftCovers[index].uuid ==
                      objects[i].userData.uuidLeftCover
                    ) {
                      leftCovers[index].visible = false;
                      // objects[i].userData.visibleLeftCover = false;

                      scene.add(leftCovers[index]);
                      // objects[i].userData.hasLeftCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                if (objects[j].userData.hasRightCover) {
                  // console.log("objects[i].userData.hasRightCover ");

                  for (let index = 0; index < rightCovers.length; index++) {
                    if (
                      rightCovers[index].uuid ==
                      objects[j].userData.uuidRightCover
                    ) {
                      rightCovers[index].visible = false;
                      // objects[j].userData.visibleRightCover = false;

                      scene.add(rightCovers[index]);
                      // objects[i].userData.hasRightCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                objects[j].userData.Beside = objects[i];
                objects[i].userData.Beside = objects[j];
                objects[i].userData.typeBeside = "right";
              }
            } else if (
              objects[j].position.x - objects[i].position.x <
                objects[i].userData.L + objects[j].userData.L &&
              objects[i].rotation.y == degrees_to_radians(90) &&
              objects[j].position.x >= objects[i].position.x
            ) {
              if (
                objects[i].position.z >
                  objects[j].position.z - objects[j].userData.W &&
                objects[i].position.z <= objects[j].position.z
              ) {
                if (
                  objects[j].position.z + objects[j].userData.W >
                  measuresZG.max - wallWidth
                )
                  if (
                    objects[j].position.z -
                      objects[j].userData.W -
                      objects[i].userData.W <
                    measuresZG.min + wallWidth
                  )
                    objects[i].position.x = objects[j].position.x;
                  else
                    objects[i].position.z =
                      objects[j].position.z -
                      objects[j].userData.W -
                      objects[i].userData.W;
                else objects[i].position.z = objects[j].position.z;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);
                // if (is2D) {
                //   to2D();
                //   to2D();
                // }

                // if (objects[j].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[j].userData.visibleLeftCover = false;

                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[i].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[i].userData.visibleRightCover = false;

                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // objects[i].userData.Beside = objects[j];
                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.typeBeside = "left";
              } else if (
                objects[i].position.z + objects[i].userData.W >
                  objects[j].position.z - objects[j].userData.W &&
                objects[i].position.z <= objects[j].position.z
              ) {
                if (
                  objects[j].position.z -
                    objects[j].userData.W -
                    objects[i].userData.W <
                  measuresZG.min + wallWidth
                )
                  if (
                    objects[j].position.z + objects[i].userData.W >
                    measuresZG.max - wallWidth
                  )
                    objects[i].position.x =
                      objects[j].position.x - objects[j].userData.L;
                  else
                    objects[i].position.z =
                      objects[j].position.z + objects[i].userData.W;
                else
                  objects[i].position.z =
                    objects[j].position.z -
                    objects[j].userData.W -
                    objects[i].userData.W;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);
                // if (is2D) {
                //   to2D();
                //   to2D();
                // }
                // if (objects[i].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[i].userData.visibleLeftCover = false;

                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[j].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[j].userData.visibleRightCover = false;

                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.Beside = objects[j];
                // objects[i].userData.typeBeside = "right";
              }
            } else if (
              objects[i].position.z + objects[i].userData.L >=
                objects[j].position.z - objects[j].userData.W &&
              objects[i].rotation.y == degrees_to_radians(0) &&
              objects[j].position.z >= objects[i].position.z
            ) {
              if (
                objects[i].position.x <= objects[j].position.x &&
                objects[i].position.x >=
                  objects[j].position.x - objects[j].userData.L
              ) {
                if (
                  objects[j].position.x - objects[j].userData.L <
                  measuresXG.min + wallWidth
                )
                  objects[i].position.x =
                    objects[j].position.x + objects[i].userData.W;
                else
                  objects[i].position.x =
                    objects[j].position.x - objects[j].userData.L;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);
                // if (is2D) {
                //   to2D();
                //   to2D();
                // }

                // if (objects[j].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[j].userData.visibleLeftCover = false;

                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[i].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[i].userData.visibleRightCover = false;

                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // objects[i].userData.Beside = objects[j];
                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.typeBeside = "left";
              } else if (
                objects[i].position.x - objects[i].userData.W <
                  objects[j].position.x &&
                objects[i].position.x >= objects[j].position.x
              ) {
                if (
                  objects[j].position.x + objects[i].userData.W >
                  measuresXG.max - wallWidth
                )
                  objects[i].position.x =
                    objects[j].position.x - objects[j].userData.L;
                else
                  objects[i].position.x =
                    objects[j].position.x + objects[i].userData.W;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);
                // if (is2D) {
                //   to2D();
                //   to2D();
                // }
                // if (objects[i].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[i].userData.visibleLeftCover = false;

                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[j].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[j].userData.visibleRightCover = false;

                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.Beside = objects[j];
                // objects[i].userData.typeBeside = "right";
              }
            } else if (
              objects[i].position.z - objects[i].userData.L <=
                objects[j].position.z &&
              objects[i].position.z >
                objects[j].position.z - objects[j].userData.W &&
              objects[i].rotation.y == degrees_to_radians(180)
              // && objects[j].position.z  <= objects[i].position.z
            ) {
              if (
                objects[i].position.x <= objects[j].position.x &&
                objects[i].position.x >=
                  objects[j].position.x - objects[j].userData.L
              ) {
                if (
                  objects[j].position.x + objects[i].userData.W <
                  measuresXG.min + wallWidth
                )
                  objects[i].position.x =
                    objects[j].position.x -
                    objects[j].userData.L -
                    objects[i].userData.W;
                else objects[i].position.x = objects[j].position.x;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);
                // if (is2D) {
                //   to2D();
                //   to2D();
                // }

                // if (objects[j].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[j].userData.visibleLeftCover = false;

                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[i].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[i].userData.visibleRightCover = false;

                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // objects[i].userData.Beside = objects[j];
                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.typeBeside = "left";
              } else if (
                objects[i].position.x + objects[i].userData.W >
                  objects[j].position.x - objects[j].userData.L &&
                objects[i].position.x <= objects[j].position.x
              ) {
                if (
                  objects[j].position.x -
                    objects[j].userData.L -
                    objects[i].userData.W <
                  measuresXG.min + wallWidth
                )
                  objects[i].position.x = objects[j].position.x;
                else
                  objects[i].position.x =
                    objects[j].position.x -
                    objects[j].userData.L -
                    objects[i].userData.W;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);
                // if (is2D) {
                //   to2D();
                //   to2D();
                // }
                // if (objects[i].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[i].userData.visibleLeftCover = false;

                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[j].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[j].userData.visibleRightCover = false;

                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.Beside = objects[j];
                // objects[i].userData.typeBeside = "right";
              }
            }
          }

          ///  X
          // 180 degree
          if (objects[j].rotation.y == degrees_to_radians(180)) {
            if (
              Math.abs(objects[i].position.z - objects[j].position.z) <
                Math.max(objects[i].userData.L, objects[j].userData.L) &&
              objects[i].rotation.y == degrees_to_radians(180)
            ) {
              if (
                objects[i].position.x <
                  objects[j].position.x + objects[j].userData.W &&
                objects[i].position.x >= objects[j].position.x
              ) {
                if (
                  objects[j].position.x +
                    objects[j].userData.W +
                    objects[i].userData.W >
                  measuresXG.max - wallWidth
                )
                  if (
                    objects[j].position.x - objects[i].userData.W <
                    measuresXG.min + wallWidth
                  ) {
                    objects[i].position.z =
                      objects[j].position.z - objects[j].userData.L;
                    // objects[i].position.x = objects[j].position.x ;
                  } else
                    objects[i].position.x =
                      objects[j].position.x - objects[i].userData.W;
                else
                  objects[i].position.x =
                    objects[j].position.x + objects[j].userData.W;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);
                // if (is2D) {
                //   to2D();
                //   to2D();
                // }
                if (objects[i].userData.hasLeftCover) {
                  // console.log("objects[i].userData.hasLeftCover ");
                  for (let index = 0; index < leftCovers.length; index++) {
                    if (
                      leftCovers[index].uuid ==
                      objects[i].userData.uuidLeftCover
                    ) {
                      leftCovers[index].visible = false;
                      // objects[i].userData.visibleLeftCover = false;

                      scene.add(leftCovers[index]);
                      // objects[i].userData.hasLeftCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                if (objects[j].userData.hasRightCover) {
                  // console.log("objects[i].userData.hasRightCover ");

                  for (let index = 0; index < rightCovers.length; index++) {
                    if (
                      rightCovers[index].uuid ==
                      objects[j].userData.uuidRightCover
                    ) {
                      rightCovers[index].visible = false;
                      // objects[j].userData.visibleRightCover = false;

                      scene.add(rightCovers[index]);
                      // objects[i].userData.hasRightCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                objects[j].userData.Beside = objects[i];
                objects[i].userData.Beside = objects[j];
                objects[i].userData.typeBeside = "right";
              } else if (
                objects[i].position.x + objects[i].userData.W >
                  objects[j].position.x &&
                objects[i].position.x <= objects[j].position.x
              ) {
                if (
                  objects[j].position.x - objects[i].userData.W <
                  measuresXG.min + wallWidth
                )
                  if (
                    objects[j].position.x +
                      objects[j].userData.W +
                      objects[i].userData.W >
                    measuresXG.max - wallWidth
                  ) {
                    objects[i].position.z =
                      objects[j].position.z - objects[j].userData.L;
                  } else
                    objects[i].position.x =
                      objects[j].position.x + objects[j].userData.W;
                else
                  objects[i].position.x =
                    objects[j].position.x - objects[i].userData.W;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);

                if (objects[j].userData.hasLeftCover) {
                  // console.log("objects[i].userData.hasLeftCover ");
                  for (let index = 0; index < leftCovers.length; index++) {
                    if (
                      leftCovers[index].uuid ==
                      objects[j].userData.uuidLeftCover
                    ) {
                      leftCovers[index].visible = false;
                      // objects[j].userData.visibleLeftCover = false;

                      scene.add(leftCovers[index]);
                      // objects[i].userData.hasLeftCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                if (objects[i].userData.hasRightCover) {
                  // console.log("objects[i].userData.hasRightCover ");

                  for (let index = 0; index < rightCovers.length; index++) {
                    if (
                      rightCovers[index].uuid ==
                      objects[i].userData.uuidRightCover
                    ) {
                      rightCovers[index].visible = false;
                      // objects[i].userData.visibleRightCover = false;

                      scene.add(rightCovers[index]);
                      // objects[i].userData.hasRightCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                objects[j].userData.Beside = objects[i];
                objects[i].userData.Beside = objects[j];
                objects[i].userData.typeBeside = "left";
              }
            } else if (
              Math.abs(objects[i].position.z - objects[j].position.z) <
                objects[i].userData.L + objects[j].userData.L &&
              objects[i].position.z < objects[j].position.z &&
              objects[i].rotation.y == degrees_to_radians(0)
            ) {
              if (
                objects[i].position.x <
                  objects[j].position.x +
                    objects[i].userData.W +
                    objects[j].userData.W &&
                objects[i].position.x >=
                  objects[j].position.x + objects[j].userData.W
              ) {
                if (
                  objects[j].position.x +
                    objects[i].userData.W +
                    objects[j].userData.W >
                  measuresXG.max - wallWidth
                )
                  if (
                    objects[j].position.x - objects[i].userData.W <
                    measuresXG.min + wallWidth
                  ) {
                    objects[i].position.z =
                      objects[j].position.z -
                      objects[j].userData.L -
                      objects[i].userData.L;
                    // objects[i].position.x = objects[j].position.x ;
                  } else objects[i].position.x = objects[j].position.x;
                else
                  objects[i].position.x =
                    objects[j].position.x +
                    objects[i].userData.W +
                    objects[j].userData.W;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);
                // if (is2D) {
                //   to2D();
                //   to2D();
                // }
                if (objects[i].userData.hasLeftCover) {
                  // console.log("objects[i].userData.hasLeftCover ");
                  for (let index = 0; index < leftCovers.length; index++) {
                    if (
                      leftCovers[index].uuid ==
                      objects[i].userData.uuidLeftCover
                    ) {
                      leftCovers[index].visible = false;
                      // objects[i].userData.visibleLeftCover = false;

                      scene.add(leftCovers[index]);
                      // objects[i].userData.hasLeftCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                if (objects[j].userData.hasRightCover) {
                  // console.log("objects[i].userData.hasRightCover ");

                  for (let index = 0; index < rightCovers.length; index++) {
                    if (
                      rightCovers[index].uuid ==
                      objects[j].userData.uuidRightCover
                    ) {
                      rightCovers[index].visible = false;
                      // objects[j].userData.visibleRightCover = false;

                      scene.add(rightCovers[index]);
                      // objects[i].userData.hasRightCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                objects[j].userData.Beside = objects[i];
                objects[i].userData.Beside = objects[j];
                objects[i].userData.typeBeside = "right";
              } else if (
                objects[i].position.x - objects[i].userData.W <
                  objects[j].position.x &&
                objects[j].position.x <= objects[i].position.x
              ) {
                if (
                  objects[j].position.x - objects[i].userData.W <
                  measuresXG.min + wallWidth
                )
                  if (
                    objects[j].position.x +
                      objects[j].userData.W +
                      objects[i].userData.W >
                    measuresXG.max - wallWidth
                  ) {
                    objects[i].position.z =
                      objects[j].position.z -
                      objects[j].userData.L -
                      objects[i].userData.L;
                  } else
                    objects[i].position.x =
                      objects[j].position.x +
                      objects[j].userData.W +
                      objects[i].userData.W;
                else objects[i].position.x = objects[j].position.x;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);

                if (objects[j].userData.hasLeftCover) {
                  // console.log("objects[i].userData.hasLeftCover ");
                  for (let index = 0; index < leftCovers.length; index++) {
                    if (
                      leftCovers[index].uuid ==
                      objects[j].userData.uuidLeftCover
                    ) {
                      leftCovers[index].visible = false;
                      // objects[j].userData.visibleLeftCover = false;

                      scene.add(leftCovers[index]);
                      // objects[i].userData.hasLeftCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                if (objects[i].userData.hasRightCover) {
                  // console.log("objects[i].userData.hasRightCover ");

                  for (let index = 0; index < rightCovers.length; index++) {
                    if (
                      rightCovers[index].uuid ==
                      objects[i].userData.uuidRightCover
                    ) {
                      rightCovers[index].visible = false;
                      // objects[i].userData.visibleRightCover = false;

                      scene.add(rightCovers[index]);
                      // objects[i].userData.hasRightCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                objects[j].userData.Beside = objects[i];
                objects[i].userData.Beside = objects[j];
                objects[i].userData.typeBeside = "left";
              }
            } else if (
              objects[i].position.x <
                objects[j].position.x + objects[j].userData.W &&
              objects[i].rotation.y == degrees_to_radians(90) &&
              objects[i].position.x + objects[i].userData.L >
                objects[j].position.x
            ) {
              if (
                objects[j].position.z <
                  objects[i].position.z + objects[j].userData.L &&
                objects[i].position.z <= objects[j].position.z
              ) {
                if (
                  objects[j].position.z - objects[i].userData.W >
                  measuresZG.max - wallWidth
                )
                  objects[i].position.z =
                    objects[j].position.z -
                    objects[j].userData.L -
                    objects[i].userData.W;
                else objects[i].position.z = objects[j].position.z;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);

                // if (objects[i].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[i].userData.visibleLeftCover = false;

                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[j].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[j].userData.visibleRightCover = false;

                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.Beside = objects[j];
                // objects[i].userData.typeBeside = "right";
              } else if (
                objects[i].position.z + objects[i].userData.W >
                  objects[j].position.z - objects[j].userData.L &&
                objects[j].position.z - objects[j].userData.L >
                  objects[i].position.z
              ) {
                if (
                  objects[j].position.z -
                    objects[j].userData.L -
                    objects[i].userData.W <
                  measuresZG.min + wallWidth
                )
                  objects[i].position.z = objects[j].position.z;
                else
                  objects[i].position.z =
                    objects[j].position.z -
                    objects[j].userData.L -
                    objects[i].userData.W;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);

                // if (objects[j].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[j].userData.visibleLeftCover = false;

                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[i].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[i].userData.visibleRightCover = false;

                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.Beside = objects[j];
                // objects[i].userData.typeBeside = "left";
              }
            } else if (
              objects[i].position.x <
                objects[j].position.x +
                  objects[j].userData.W +
                  objects[i].userData.L &&
              objects[i].rotation.y == degrees_to_radians(-90) &&
              objects[i].position.x > objects[j].position.x
            ) {
              if (
                objects[j].position.z <
                  objects[i].position.z + objects[j].userData.L &&
                objects[i].position.z <= objects[j].position.z
              ) {
                if (
                  objects[j].position.z - objects[j].userData.L <
                  measuresZG.min + wallWidth
                )
                  objects[i].position.z =
                    objects[j].position.z + objects[i].userData.W;
                else
                  objects[i].position.z =
                    objects[j].position.z - objects[j].userData.L;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);

                // if (objects[i].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[i].userData.visibleLeftCover = false;

                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[j].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[j].userData.visibleRightCover = false;

                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.Beside = objects[j];
                // objects[i].userData.typeBeside = "right";
              } else if (
                objects[i].position.z - objects[i].userData.W <
                  objects[j].position.z &&
                objects[j].position.z < objects[i].position.z
              ) {
                if (
                  objects[j].position.z + objects[i].userData.W >
                  measuresZG.max - wallWidth
                )
                  objects[i].position.z =
                    objects[j].position.z + objects[j].userData.L;
                else
                  objects[i].position.z =
                    objects[j].position.z + objects[i].userData.W;

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);

                // if (objects[j].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[j].userData.visibleLeftCover = false;

                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[i].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[i].userData.visibleRightCover = false;

                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.Beside = objects[j];
                // objects[i].userData.typeBeside = "left";
              }
            }
          }

          // 0 degree
          if (objects[j].rotation.y == degrees_to_radians(0)) {
            if (
              Math.abs(objects[i].position.z - objects[j].position.z) <
                Math.max(objects[i].userData.L, objects[j].userData.L) &&
              objects[i].rotation.y == degrees_to_radians(0)
            ) {
              if (
                objects[i].position.x <
                  objects[j].position.x + objects[i].userData.W &&
                objects[i].position.x >= objects[j].position.x
              ) {
                if (
                  objects[j].position.x + objects[i].userData.W >
                  measuresXG.max - wallWidth
                ) {
                  if (
                    objects[j].position.x - objects[j].userData.W <
                    measuresXG.min + wallWidth
                  )
                    objects[i].position.z =
                      objects[j].position.z + objects[j].userData.L;
                  else
                    objects[i].position.x =
                      objects[j].position.x - objects[j].userData.W;
                } else {
                  objects[i].position.x =
                    objects[j].position.x + objects[i].userData.W;
                }

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);

                if (objects[j].userData.hasLeftCover) {
                  // console.log("objects[i].userData.hasLeftCover ");
                  for (let index = 0; index < leftCovers.length; index++) {
                    if (
                      leftCovers[index].uuid ==
                      objects[j].userData.uuidLeftCover
                    ) {
                      leftCovers[index].visible = false;
                      // objects[j].userData.visibleLeftCover = false;

                      scene.add(leftCovers[index]);
                      // objects[i].userData.hasLeftCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                if (objects[i].userData.hasRightCover) {
                  // console.log("objects[i].userData.hasRightCover ");

                  for (let index = 0; index < rightCovers.length; index++) {
                    if (
                      rightCovers[index].uuid ==
                      objects[i].userData.uuidRightCover
                    ) {
                      rightCovers[index].visible = false;
                      // objects[i].userData.visibleRightCover = false;

                      scene.add(rightCovers[index]);
                      // objects[i].userData.hasRightCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }

                objects[j].userData.Beside = objects[i];
                objects[i].userData.Beside = objects[j];
                objects[i].userData.typeBeside = "left";
              } else if (
                objects[i].position.x + objects[j].userData.W >
                  objects[j].position.x &&
                objects[i].position.x <= objects[j].position.x
              ) {
                if (
                  objects[j].position.x -
                    objects[j].userData.W -
                    objects[i].userData.W <
                  measuresXG.min + wallWidth
                ) {
                  if (
                    objects[j].position.x + objects[i].userData.W >
                    measuresXG.max - wallWidth
                  )
                    objects[i].position.z =
                      objects[j].position.z + objects[j].userData.L;
                  else
                    objects[i].position.x =
                      objects[j].position.x + objects[i].userData.W;
                } else {
                  objects[i].position.x =
                    objects[j].position.x - objects[j].userData.W;
                }

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);

                if (objects[i].userData.hasLeftCover) {
                  // console.log("objects[i].userData.hasLeftCover ");
                  for (let index = 0; index < leftCovers.length; index++) {
                    if (
                      leftCovers[index].uuid ==
                      objects[i].userData.uuidLeftCover
                    ) {
                      leftCovers[index].visible = false;
                      // objects[i].userData.visibleLeftCover = false;

                      scene.add(leftCovers[index]);
                      // objects[i].userData.hasLeftCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                if (objects[j].userData.hasRightCover) {
                  // console.log("objects[i].userData.hasRightCover ");

                  for (let index = 0; index < rightCovers.length; index++) {
                    if (
                      rightCovers[index].uuid ==
                      objects[j].userData.uuidRightCover
                    ) {
                      rightCovers[index].visible = false;
                      // objects[j].userData.visibleRightCover = false;

                      scene.add(rightCovers[index]);
                      // objects[i].userData.hasRightCover = false
                      // scene.add(objects[i]);
                    }
                  }
                }
                // console.log("OKKKAAAYY  ");
                objects[j].userData.Beside = objects[i];
                objects[i].userData.Beside = objects[j];
                objects[i].userData.typeBeside = "right";
              }
            } else if (
              objects[i].rotation.y == degrees_to_radians(180) &&
              Math.abs(objects[i].position.z - objects[j].position.z) <
                objects[j].userData.L + objects[i].userData.L &&
              objects[i].position.z > objects[j].position.z
            ) {
              if (
                objects[j].position.x <
                  objects[i].position.x + objects[i].userData.W &&
                objects[j].position.x >= objects[i].position.x
              ) {
                if (
                  objects[j].position.x + objects[i].userData.W >
                  measuresXG.max - wallWidth
                ) {
                  if (
                    objects[j].position.x -
                      objects[j].userData.W -
                      objects[i].userData.W <
                    measuresXG.min + wallWidth
                  ) {
                    objects[i].position.z = objects[j].position.z;
                    objects[i].position.x -= objects[i].userData.W;
                  } else
                    objects[i].position.x =
                      objects[j].position.x -
                      objects[j].userData.W -
                      objects[i].userData.W;
                } else {
                  objects[i].position.x = objects[j].position.x;
                }

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);

                // if (objects[j].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[j].userData.visibleLeftCover = false;

                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[i].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[i].userData.visibleRightCover = false;

                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }

                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.Beside = objects[j];
                // objects[i].userData.typeBeside = "left";
              } else if (
                objects[i].position.x + objects[i].userData.W >
                  objects[j].position.x - objects[j].userData.W &&
                objects[i].position.x <= objects[j].position.x
              ) {
                if (
                  objects[j].position.x -
                    objects[j].userData.W -
                    objects[i].userData.W <
                  measuresXG.min + wallWidth
                ) {
                  if (objects[j].position.x >= measuresXG.max - wallWidth) {
                    objects[i].position.z = objects[j].position.z;
                    objects[i].position.x -= objects[i].userData.W;
                  } else objects[i].position.x = objects[j].position.x;
                } else {
                  objects[i].position.x =
                    objects[j].position.x -
                    objects[j].userData.W -
                    objects[i].userData.W;
                }

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);

                // if (objects[i].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[i].userData.visibleLeftCover = false;

                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[j].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[j].userData.visibleRightCover = false;

                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // // console.log("OKKKAAAYY  ");
                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.Beside = objects[j];
                // objects[i].userData.typeBeside = "right";
              }
            } else if (
              objects[i].rotation.y == degrees_to_radians(90) &&
              objects[i].position.x + objects[i].userData.L >
                objects[j].position.x - objects[j].userData.W &&
              objects[i].position.x < objects[j].position.x
            ) {
              if (
                objects[i].position.z <
                  objects[j].position.z + objects[j].userData.L &&
                objects[j].position.z <= objects[i].position.z
              ) {
                if (
                  objects[j].position.z +
                    objects[j].userData.L +
                    objects[i].userData.W >
                  measuresZG.max - wallWidth
                ) {
                  objects[i].position.z =
                    objects[j].position.z - objects[i].userData.W;
                } else {
                  objects[i].position.z =
                    objects[j].position.z + objects[j].userData.L;
                }

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);

                // if (objects[j].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[j].userData.visibleLeftCover = false;

                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[i].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[i].userData.visibleRightCover = false;

                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }

                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.Beside = objects[j];
                // objects[i].userData.typeBeside = "left";
              } else if (
                objects[i].position.z + objects[i].userData.W >
                  objects[j].position.z &&
                objects[i].position.z <= objects[j].position.z
              ) {
                if (
                  objects[j].position.z - objects[i].userData.W <
                  measuresZG.min + wallWidth
                ) {
                  objects[i].position.z =
                    objects[j].position.z + objects[j].userData.L;
                } else {
                  objects[i].position.z =
                    objects[j].position.z - objects[i].userData.W;
                }

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);

                // if (objects[i].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[i].userData.visibleLeftCover = false;

                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[j].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[j].userData.visibleRightCover = false;

                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // // console.log("OKKKAAAYY  ");
                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.Beside = objects[j];
                // objects[i].userData.typeBeside = "right";
              }
            } else if (
              objects[i].rotation.y == degrees_to_radians(-90) &&
              objects[i].position.x - objects[i].userData.L <
                objects[j].position.x &&
              objects[i].position.x >
                objects[j].position.x - objects[j].userData.W
            ) {
              if (
                objects[i].position.z - objects[i].userData.W <
                  objects[j].position.z + objects[j].userData.L &&
                objects[j].position.z <=
                  objects[i].position.z - objects[i].userData.W
              ) {
                if (
                  objects[j].position.z +
                    objects[j].userData.L +
                    objects[i].userData.W >
                  measuresZG.max - wallWidth
                ) {
                  objects[i].position.z = objects[j].position.z;
                } else {
                  objects[i].position.z =
                    objects[j].position.z +
                    objects[j].userData.L +
                    objects[i].userData.W;
                }

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);

                // if (objects[j].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[j].userData.visibleLeftCover = false;

                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[i].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[i].userData.visibleRightCover = false;

                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }

                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.Beside = objects[j];
                // objects[i].userData.typeBeside = "left";
              } else if (
                objects[j].position.z + objects[j].userData.L >
                  objects[i].position.z &&
                objects[i].position.z >= objects[j].position.z
              ) {
                if (
                  objects[j].position.z - objects[i].userData.W <
                  measuresZG.min + wallWidth
                ) {
                  objects[i].position.z =
                    objects[j].position.z + objects[j].userData.L;
                } else {
                  objects[i].position.z = objects[j].position.z;
                }

                if (objects[i].name == "B") objectsAltered.push(objects[i]);

                // if (objects[j].name == "B") objectsAltered.push(objects[j]);

                // if (objects[i].userData.hasLeftCover) {
                //   // console.log("objects[i].userData.hasLeftCover ");
                //   for (let index = 0; index < leftCovers.length; index++) {
                //     if (
                //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
                //     ) {
                //       leftCovers[index].visible = false;
                //       // objects[i].userData.visibleLeftCover = false;

                //       scene.add(leftCovers[index]);
                //       // objects[i].userData.hasLeftCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // if (objects[j].userData.hasRightCover) {
                //   // console.log("objects[i].userData.hasRightCover ");

                //   for (let index = 0; index < rightCovers.length; index++) {
                //     if (
                //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
                //     ) {
                //       rightCovers[index].visible = false;
                //       // objects[j].userData.visibleRightCover = false;

                //       scene.add(rightCovers[index]);
                //       // objects[i].userData.hasRightCover = false
                //       // scene.add(objects[i]);
                //     }
                //   }
                // }
                // // console.log("OKKKAAAYY  ");
                // objects[j].userData.Beside = objects[i];
                // objects[i].userData.Beside = objects[j];
                // objects[i].userData.typeBeside = "right";
              }
            }
          }

          scene.add(objects[i]);
        }
      }

      dragControls = new DragControls([Objobject], camera, renderer.domElement);
      dragControls.transformGroup = true;

      if (
        Objobject.rotation.y == degrees_to_radians(0) &&
        Objobject.position.z == measuresZG.min + 0.1
      ) {
        BC = BC + 1;
      } else if (
        Objobject.rotation.y == degrees_to_radians(180) &&
        Objobject.position.z == measuresZG.max - 0.1
      ) {
        FC = FC + 1;
      } else if (
        Objobject.rotation.y == degrees_to_radians(-90) &&
        Objobject.position.x == measuresXG.max - 0.1
      ) {
        RC = RC + 1;
      } else if (
        Objobject.rotation.y == degrees_to_radians(90) &&
        Objobject.position.x == measuresXG.min + 0.1
      ) {
        LC = LC + 1;
      }
      // Drag Object
      dragControls.addEventListener("drag", (event) => {
        // console.log("dragControls   " , dragControls);
        let Objobject = event.object;

        drag(Objobject);
      });
      dragControls.rotateSpeed = 2.5;
      // Drag Start
      dragControls.addEventListener("dragstart", async function (event) {
        // console.log("finishTops  ", finishTops);
        // console.log(
        //   "event.object.userData.finish_uuids  ",
        //   event.object.userData.finish_uuids
        // );
        let Objobject = event.object;
        if (
          Objobject.rotation.y == degrees_to_radians(0) &&
          BC > 0 &&
          Objobject.position.z == measuresZG.min + 0.1
        ) {
          BC = BC - 1;
        } else if (
          Objobject.rotation.y == degrees_to_radians(180) &&
          FC > 0 &&
          Objobject.position.z == measuresZG.max - 0.1
        ) {
          FC = FC - 1;
        } else if (
          Objobject.rotation.y == degrees_to_radians(-90) &&
          RC > 0 &&
          Objobject.position.x == measuresXG.max - 0.1
        ) {
          RC = RC - 1;
        } else if (
          Objobject.rotation.y == degrees_to_radians(90) &&
          LC > 0 &&
          Objobject.position.x == measuresXG.min + 0.1
        ) {
          LC = LC - 1;
        }
        await dragstart(event);
        // isUpdatedBeside = false;
        // document.getElementById("update_dimensions").style.display = "none";

        // /**
        //  * Delete the finish top of the determined object.
        //  */

        // for (let index = 0; index < finishTops.length; index++) {
        //   for (let m = 0; m < event.object.userData.finish_uuids.length; m++) {
        //     if (
        //       finishTops[index].uuid == event.object.userData.finish_uuids[m]
        //     ) {
        //       finishTops.splice(index, 1);
        //       index--;
        //       break;
        //     }
        //   }
        // }

        // for await (let obj of scene.children) {
        //   for (let m = 0; m < event.object.userData.finish_uuids.length; m++) {
        //     if (obj.uuid == event.object.userData.finish_uuids[m]) {
        //       event.object.userData.finish_uuids.splice(m--, 1);
        //       scene.remove(obj);
        //       break;
        //     }
        //   }
        // }

        // event.object.userData.finish_uuids = [];

        // uuids = [];

        // // stop camera
        // controls.enabled = false;

        // let objDraggable = event.object;

        // // Remove filler of the draggable object.
        // for (let index = 0; index < scene.children.length; index++) {
        //   if (
        //     scene.children[index].uuid == objDraggable.userData.rightFillerId ||
        //     scene.children[index].uuid == objDraggable.userData.leftFillerId
        //   ) {
        //     scene.remove(scene.children[index]);
        //     index--;
        //   }
        // }

        // if (objDraggable.userData.objBesideLeft != null) {
        //   for await (let obj of scene.children) {
        //     if (
        //       obj.uuid ===
        //       objDraggable.userData.objBesideLeft.userData.rightFillerId
        //     ) {
        //       for await (let objInner of scene.children) {
        //         if (objDraggable.userData.objBesideLeft.uuid == objInner.uuid) {
        //           objInner.userData.rightFillerId = null;

        //           break;
        //         }
        //       }
        //       scene.remove(obj);
        //     }
        //   }
        // }
        // if (objDraggable.userData.objBesideRight != null) {
        //   for await (let obj of scene.children) {
        //     if (
        //       obj.uuid ===
        //       objDraggable.userData.objBesideRight.userData.leftFillerId
        //     ) {
        //       for await (let objInner of scene.children) {
        //         if (
        //           objDraggable.userData.objBesideRight.uuid == objInner.uuid
        //         ) {
        //           objInner.userData.leftFillerId = null;

        //           break;
        //         }
        //       }
        //       scene.remove(obj);
        //     }
        //   }
        // }

        // objDraggable.userData.rightFillerId = null;
        // objDraggable.userData.leftFillerId = null;
        // scene.add(objDraggable);
      });

      // Drag End
      dragControls.addEventListener("dragend", async function (event) {
        let Objobject = event.object;
        await dragend(event);
        if (
          Objobject.rotation.y == degrees_to_radians(0) &&
          Objobject.position.z == measuresZG.min + 0.1
        ) {
          BC = BC + 1;
        } else if (
          Objobject.rotation.y == degrees_to_radians(180) &&
          Objobject.position.z == measuresZG.max - 0.1
        ) {
          FC = FC + 1;
        } else if (
          Objobject.rotation.y == degrees_to_radians(-90) &&
          Objobject.position.x == measuresXG.max - 0.1
        ) {
          RC = RC + 1;
        } else if (
          Objobject.rotation.y == degrees_to_radians(90) &&
          Objobject.position.x == measuresXG.min + 0.1
        ) {
          LC = LC + 1;
        }
        // let objDraggable = event.object;
        // if (!is2D) {
        //   controls.enabled = true;
        // }

        // // var changed = false;
        // // var counter = 0;
        // // console.log("Drag End ");
        // // do {
        // //   changed = false;
        // //   counter = counter + 1;
        // //   if (counter > 10) break;

        // // Intersect check
        // for (var i = 0; i < objects.length; i++) {
        //   for (let j = 0; j < objects.length; j++) {
        //     if (i != j && objects[i].position.y === objects[j].position.y) {
        //       /// Z
        //       // 90 degree
        //       if (
        //         Math.abs(objects[i].position.x - objects[j].position.x) <
        //           Math.max(objects[i].userData.L, objects[j].userData.L) &&
        //         objects[i].rotation.y == degrees_to_radians(90) &&
        //         objects[j].rotation.y == degrees_to_radians(90)
        //       ) {
        //         if (
        //           objects[i].position.z <
        //             objects[j].position.z + objects[j].userData.W &&
        //           objects[i].position.z >= objects[j].position.z
        //         ) {
        //           objects[i].position.z =
        //             objects[j].position.z + objects[j].userData.W;
        //           // if (is2D) {
        //           //   to2D();
        //           //   to2D();
        //           // }
        //           if (objects[i].userData.hasLeftCover) {
        //             // console.log("objects[i].userData.hasLeftCover ");
        //             for (let index = 0; index < leftCovers.length; index++) {
        //               if (
        //                 leftCovers[index].uuid ==
        //                 objects[i].userData.uuidLeftCover
        //               ) {
        //                 leftCovers[index].visible = false;
        //                 scene.add(leftCovers[index]);
        //                 // objects[i].userData.hasLeftCover = false
        //                 // scene.add(objects[i]);
        //               }
        //             }
        //           }
        //           if (objects[j].userData.hasRightCover) {
        //             // console.log("objects[i].userData.hasRightCover ");

        //             for (let index = 0; index < rightCovers.length; index++) {
        //               if (
        //                 rightCovers[index].uuid ==
        //                 objects[j].userData.uuidRightCover
        //               ) {
        //                 rightCovers[index].visible = false;
        //                 scene.add(rightCovers[index]);
        //                 // objects[i].userData.hasRightCover = false
        //                 // scene.add(objects[i]);
        //               }
        //             }
        //           }
        //           objects[j].userData.Beside = objects[i];
        //           objects[i].userData.Beside = objects[j];
        //           objects[i].userData.typeBeside = "right";
        //         } else if (
        //           objects[i].position.z + objects[i].userData.W >
        //             objects[j].position.z &&
        //           objects[i].position.z <= objects[j].position.z
        //         ) {
        //           objects[i].position.z =
        //             objects[j].position.z - objects[i].userData.W;
        //           // if (is2D) {
        //           //   to2D();
        //           //   to2D();
        //           // }

        //           if (objects[j].userData.hasLeftCover) {
        //             // console.log("objects[i].userData.hasLeftCover ");
        //             for (let index = 0; index < leftCovers.length; index++) {
        //               if (
        //                 leftCovers[index].uuid ==
        //                 objects[j].userData.uuidLeftCover
        //               ) {
        //                 leftCovers[index].visible = false;
        //                 scene.add(leftCovers[index]);
        //                 // objects[i].userData.hasLeftCover = false
        //                 // scene.add(objects[i]);
        //               }
        //             }
        //           }
        //           if (objects[i].userData.hasRightCover) {
        //             // console.log("objects[i].userData.hasRightCover ");

        //             for (let index = 0; index < rightCovers.length; index++) {
        //               if (
        //                 rightCovers[index].uuid ==
        //                 objects[i].userData.uuidRightCover
        //               ) {
        //                 rightCovers[index].visible = false;
        //                 scene.add(rightCovers[index]);
        //                 // objects[i].userData.hasRightCover = false
        //                 // scene.add(objects[i]);
        //               }
        //             }
        //           }
        //           objects[i].userData.Beside = objects[j];
        //           objects[j].userData.Beside = objects[i];
        //           objects[i].userData.typeBeside = "left";
        //         }
        //       }

        //       // -90 degree
        //       if (
        //         Math.abs(objects[i].position.x - objects[j].position.x) <
        //           Math.max(objects[i].userData.L, objects[j].userData.L) &&
        //         objects[i].rotation.y == degrees_to_radians(-90) &&
        //         objects[j].rotation.y == degrees_to_radians(-90)
        //       ) {
        //         if (
        //           objects[i].position.z <
        //             objects[j].position.z + objects[i].userData.W &&
        //           objects[i].position.z >= objects[j].position.z
        //         ) {
        //           objects[i].position.z =
        //             objects[j].position.z + objects[i].userData.W;
        //           // if (is2D) {
        //           //   to2D();
        //           //   to2D();
        //           // }

        //           if (objects[j].userData.hasLeftCover) {
        //             // console.log("objects[i].userData.hasLeftCover ");
        //             for (let index = 0; index < leftCovers.length; index++) {
        //               if (
        //                 leftCovers[index].uuid ==
        //                 objects[j].userData.uuidLeftCover
        //               ) {
        //                 leftCovers[index].visible = false;
        //                 scene.add(leftCovers[index]);
        //                 // objects[i].userData.hasLeftCover = false
        //                 // scene.add(objects[i]);
        //               }
        //             }
        //           }
        //           if (objects[i].userData.hasRightCover) {
        //             // console.log("objects[i].userData.hasRightCover ");

        //             for (let index = 0; index < rightCovers.length; index++) {
        //               if (
        //                 rightCovers[index].uuid ==
        //                 objects[i].userData.uuidRightCover
        //               ) {
        //                 rightCovers[index].visible = false;
        //                 scene.add(rightCovers[index]);
        //                 // objects[i].userData.hasRightCover = false
        //                 // scene.add(objects[i]);
        //               }
        //             }
        //           }
        //           objects[i].userData.Beside = objects[j];
        //           objects[j].userData.Beside = objects[i];
        //           objects[i].userData.typeBeside = "left";
        //         } else if (
        //           objects[i].position.z + objects[j].userData.W >
        //             objects[j].position.z &&
        //           objects[i].position.z <= objects[j].position.z
        //         ) {
        //           objects[i].position.z =
        //             objects[j].position.z - objects[j].userData.W;
        //           // if (is2D) {
        //           //   to2D();
        //           //   to2D();
        //           // }
        //           if (objects[i].userData.hasLeftCover) {
        //             // console.log("objects[i].userData.hasLeftCover ");
        //             for (let index = 0; index < leftCovers.length; index++) {
        //               if (
        //                 leftCovers[index].uuid ==
        //                 objects[i].userData.uuidLeftCover
        //               ) {
        //                 leftCovers[index].visible = false;
        //                 scene.add(leftCovers[index]);
        //                 // objects[i].userData.hasLeftCover = false
        //                 // scene.add(objects[i]);
        //               }
        //             }
        //           }
        //           if (objects[j].userData.hasRightCover) {
        //             // console.log("objects[i].userData.hasRightCover ");

        //             for (let index = 0; index < rightCovers.length; index++) {
        //               if (
        //                 rightCovers[index].uuid ==
        //                 objects[j].userData.uuidRightCover
        //               ) {
        //                 rightCovers[index].visible = false;
        //                 scene.add(rightCovers[index]);
        //                 // objects[i].userData.hasRightCover = false
        //                 // scene.add(objects[i]);
        //               }
        //             }
        //           }
        //           objects[j].userData.Beside = objects[i];
        //           objects[i].userData.Beside = objects[j];
        //           objects[i].userData.typeBeside = "right";
        //         }
        //       }

        //       ///  X
        //       // 180 degree
        //       if (
        //         Math.abs(objects[i].position.z - objects[j].position.z) <
        //           Math.max(objects[i].userData.L, objects[j].userData.L) &&
        //         objects[i].rotation.y == degrees_to_radians(180) &&
        //         objects[j].rotation.y == degrees_to_radians(180)
        //       ) {
        //         if (
        //           objects[i].position.x <
        //             objects[j].position.x + objects[j].userData.W &&
        //           objects[i].position.x >= objects[j].position.x
        //         ) {
        //           objects[i].position.x =
        //             objects[j].position.x + objects[j].userData.W;
        //           // if (is2D) {
        //           //   to2D();
        //           //   to2D();
        //           // }
        //           if (objects[i].userData.hasLeftCover) {
        //             // console.log("objects[i].userData.hasLeftCover ");
        //             for (let index = 0; index < leftCovers.length; index++) {
        //               if (
        //                 leftCovers[index].uuid ==
        //                 objects[i].userData.uuidLeftCover
        //               ) {
        //                 leftCovers[index].visible = false;
        //                 scene.add(leftCovers[index]);
        //                 // objects[i].userData.hasLeftCover = false
        //                 // scene.add(objects[i]);
        //               }
        //             }
        //           }
        //           if (objects[j].userData.hasRightCover) {
        //             // console.log("objects[i].userData.hasRightCover ");

        //             for (let index = 0; index < rightCovers.length; index++) {
        //               if (
        //                 rightCovers[index].uuid ==
        //                 objects[j].userData.uuidRightCover
        //               ) {
        //                 rightCovers[index].visible = false;
        //                 scene.add(rightCovers[index]);
        //                 // objects[i].userData.hasRightCover = false
        //                 // scene.add(objects[i]);
        //               }
        //             }
        //           }
        //           objects[j].userData.Beside = objects[i];
        //           objects[i].userData.Beside = objects[j];
        //           objects[i].userData.typeBeside = "right";
        //         } else if (
        //           objects[i].position.x + objects[i].userData.W >
        //             objects[j].position.x &&
        //           objects[i].position.x <= objects[j].position.x
        //         ) {
        //           objects[i].position.x =
        //             objects[j].position.x - objects[i].userData.W;
        //           // if (is2D) {
        //           //   to2D();
        //           //   to2D();
        //           // }

        //           if (objects[j].userData.hasLeftCover) {
        //             // console.log("objects[i].userData.hasLeftCover ");
        //             for (let index = 0; index < leftCovers.length; index++) {
        //               if (
        //                 leftCovers[index].uuid ==
        //                 objects[j].userData.uuidLeftCover
        //               ) {
        //                 leftCovers[index].visible = false;
        //                 scene.add(leftCovers[index]);
        //                 // objects[i].userData.hasLeftCover = false
        //                 // scene.add(objects[i]);
        //               }
        //             }
        //           }
        //           if (objects[i].userData.hasRightCover) {
        //             // console.log("objects[i].userData.hasRightCover ");

        //             for (let index = 0; index < rightCovers.length; index++) {
        //               if (
        //                 rightCovers[index].uuid ==
        //                 objects[i].userData.uuidRightCover
        //               ) {
        //                 rightCovers[index].visible = false;
        //                 scene.add(rightCovers[index]);
        //                 // objects[i].userData.hasRightCover = false
        //                 // scene.add(objects[i]);
        //               }
        //             }
        //           }
        //           objects[j].userData.Beside = objects[i];
        //           objects[i].userData.Beside = objects[j];
        //           objects[i].userData.typeBeside = "left";
        //         }
        //       }

        //       // 0 degree
        //       if (
        //         Math.abs(objects[i].position.z - objects[j].position.z) <
        //           Math.max(objects[i].userData.L, objects[j].userData.L) &&
        //         objects[i].rotation.y == degrees_to_radians(0) &&
        //         objects[j].rotation.y == degrees_to_radians(0)
        //       ) {
        //         if (
        //           objects[i].position.x <
        //             objects[j].position.x + objects[i].userData.W &&
        //           objects[i].position.x >= objects[j].position.x
        //         ) {
        //           objects[i].position.x =
        //             objects[j].position.x + objects[i].userData.W;

        //           if (objects[j].userData.hasLeftCover) {
        //             // console.log("objects[i].userData.hasLeftCover ");
        //             for (let index = 0; index < leftCovers.length; index++) {
        //               if (
        //                 leftCovers[index].uuid ==
        //                 objects[j].userData.uuidLeftCover
        //               ) {
        //                 leftCovers[index].visible = false;
        //                 scene.add(leftCovers[index]);
        //                 // objects[i].userData.hasLeftCover = false
        //                 // scene.add(objects[i]);
        //               }
        //             }
        //           }
        //           if (objects[i].userData.hasRightCover) {
        //             // console.log("objects[i].userData.hasRightCover ");

        //             for (let index = 0; index < rightCovers.length; index++) {
        //               if (
        //                 rightCovers[index].uuid ==
        //                 objects[i].userData.uuidRightCover
        //               ) {
        //                 rightCovers[index].visible = false;
        //                 scene.add(rightCovers[index]);
        //                 // objects[i].userData.hasRightCover = false
        //                 // scene.add(objects[i]);
        //               }
        //             }
        //           }

        //           objects[j].userData.Beside = objects[i];
        //           objects[i].userData.Beside = objects[j];
        //           objects[i].userData.typeBeside = "left";
        //         } else if (
        //           objects[i].position.x + objects[j].userData.W >
        //             objects[j].position.x &&
        //           objects[i].position.x <= objects[j].position.x
        //         ) {
        //           objects[i].position.x =
        //             objects[j].position.x - objects[j].userData.W;

        //           if (objects[i].userData.hasLeftCover) {
        //             // console.log("objects[i].userData.hasLeftCover ");
        //             for (let index = 0; index < leftCovers.length; index++) {
        //               if (
        //                 leftCovers[index].uuid ==
        //                 objects[i].userData.uuidLeftCover
        //               ) {
        //                 leftCovers[index].visible = false;
        //                 scene.add(leftCovers[index]);
        //                 // objects[i].userData.hasLeftCover = false
        //                 // scene.add(objects[i]);
        //               }
        //             }
        //           }
        //           if (objects[j].userData.hasRightCover) {
        //             // console.log("objects[i].userData.hasRightCover ");

        //             for (let index = 0; index < rightCovers.length; index++) {
        //               if (
        //                 rightCovers[index].uuid ==
        //                 objects[j].userData.uuidRightCover
        //               ) {
        //                 rightCovers[index].visible = false;
        //                 scene.add(rightCovers[index]);
        //                 // objects[i].userData.hasRightCover = false
        //                 // scene.add(objects[i]);
        //               }
        //             }
        //           }
        //           // console.log("OKKKAAAYY  ");
        //           objects[j].userData.Beside = objects[i];
        //           objects[i].userData.Beside = objects[j];
        //           objects[i].userData.typeBeside = "right";
        //         }
        //       }

        //       scene.add(objects[i]);
        //     }
        //   }
        //   if(!(objects[i].name == "Element" && objects[i].userData.ElType != 'opening')){
        //      // Change coordinates of the Handle Direction

        //      if (objects[i].userData.hasHandleDirection == true) {
        //       let positionX, positionZ;

        //       for (let index = 0; index < directions.length; index++) {
        //         if (
        //           directions[index].uuid == objects[i].userData.uuidDirection
        //         ) {

        //           if(objects[i].userData.ElType != 'opening'){

        //             if (objects[i].rotation.y == degrees_to_radians(0)) {
        //               if(objects[i].userData.Direction == "L"){
        //                 positionX = objects[i].position.x;
        //               }else{
        //                 positionX = objects[i].position.x -  objects[i].userData.W;
        //                 directions[index].rotation.z = degrees_to_radians(-180);
        //               }
        //               positionZ = objects[i].position.z + ((objects[i].userData.ElType == 'opening')? 0.1:objects[i].userData.L);

        //             } else if (objects[i].rotation.y == degrees_to_radians(90)) {
        //               if(objects[i].userData.Direction == "L"){
        //                 positionZ = objects[i].position.z;

        //               }else{
        //                 positionZ = objects[i].position.z +  objects[i].userData.W;
        //                 directions[index].rotation.x = degrees_to_radians(0);
        //               }
        //               positionX = objects[i].position.x + ((objects[i].userData.ElType == 'opening')? 0.1:objects[i].userData.L);
        //             } else if (objects[i].rotation.y == degrees_to_radians(180)) {
        //               if(objects[i].userData.Direction == "L"){
        //                 positionX = objects[i].position.x;
        //               }else{
        //                 positionX = objects[i].position.x  + objects[i].userData.W;
        //                 directions[index].rotation.z = degrees_to_radians(-180);
        //               }

        //               positionZ = objects[i].position.z -  ((objects[i].userData.ElType == 'opening')? 0.1:objects[i].userData.L);
        //             } else if (objects[i].rotation.y == degrees_to_radians(-90)) {

        //               if(objects[i].userData.Direction == "L"){
        //                 positionZ = objects[i].position.z;
        //               }else{
        //                 positionZ = objects[i].position.z - objects[i].userData.W;
        //                 directions[index].rotation.x = degrees_to_radians(0);
        //               }
        //               positionX = objects[i].position.x -  ((objects[i].userData.ElType == 'opening')? 0.1:objects[i].userData.L);

        //             }

        //             // directions[index].position.x = positionX;
        //             // directions[index].position.z = positionZ;
        //             directions[index].rotation.y = objects[i].rotation.y;

        //             }else{
        //             if (objects[i].rotation.y == degrees_to_radians(0)) {
        //               positionX = objects[i].position.x;
        //               positionZ = objects[i].position.z +  ((objects[i].userData.ElType == 'opening')? 0.1:objects[i].userData.L);
        //               directions[index].rotation.x = degrees_to_radians(-180);
        //               directions[index].rotation.z = degrees_to_radians(0);
        //               directions[index].rotation.y = objects[i].rotation.y;

        //             } else if (objects[i].rotation.y == degrees_to_radians(90)) {
        //               positionX = objects[i].position.x +  ((objects[i].userData.ElType == 'opening')? 0.1:objects[i].userData.L);
        //               positionZ = objects[i].position.z;
        //               directions[index].rotation.z = degrees_to_radians(90);
        //               directions[index].rotation.x = degrees_to_radians(-90);
        //               directions[index].rotation.y = degrees_to_radians(-90);

        //             } else if (objects[i].rotation.y == degrees_to_radians(180)) {
        //               positionX = objects[i].position.x;
        //               positionZ = objects[i].position.z -  ((objects[i].userData.ElType == 'opening')? 0.1:objects[i].userData.L);

        //               directions[index].rotation.x = degrees_to_radians(-180);
        //               directions[index].rotation.z = degrees_to_radians(0);
        //               directions[index].rotation.y = objects[i].rotation.y;

        //             } else if (objects[i].rotation.y == degrees_to_radians(-90)) {
        //               positionX = objects[i].position.x -  ((objects[i].userData.ElType == 'opening')? 0.1:objects[i].userData.L);
        //               positionZ = objects[i].position.z;

        //               directions[index].rotation.z = degrees_to_radians(-90);
        //               directions[index].rotation.x = degrees_to_radians(-90);
        //               directions[index].rotation.y = degrees_to_radians(90);

        //             }

        //             // directions[index].position.x = positionX;
        //             // directions[index].position.z = positionZ;
        //           }
        //           // if (objects[i].rotation.y == degrees_to_radians(0)) {
        //           //   positionX = objects[i].position.x;
        //           //   directions[index].rotation.x = degrees_to_radians(-180);
        //           //   directions[index].rotation.z = degrees_to_radians(0);

        //           //   positionZ = objects[i].position.z +  ((objects[i].userData.ElType == 'opening')? 0.1:objects[i].userData.L);
        //           // } else if (objects[i].rotation.y == degrees_to_radians(90)) {
        //           //   positionX = objects[i].position.x +  ((objects[i].userData.ElType == 'opening')? 0.1:objects[i].userData.L);
        //           //   directions[index].rotation.z = degrees_to_radians(90);
        //           //   directions[index].rotation.x = degrees_to_radians(-90);
        //           //   directions[index].rotation.y = degrees_to_radians(-90);

        //           //   positionZ = objects[i].position.z;
        //           // } else if (objects[i].rotation.y == degrees_to_radians(180)) {
        //           //   positionX = objects[i].position.x;
        //           //   directions[index].rotation.x = degrees_to_radians(-180);
        //           //   directions[index].rotation.z = degrees_to_radians(0);

        //           //   positionZ = objects[i].position.z -  ((objects[i].userData.ElType == 'opening')? 0.1:objects[i].userData.L);
        //           // } else if (objects[i].rotation.y == degrees_to_radians(-90)) {
        //           //   positionX = objects[i].position.x -  ((objects[i].userData.ElType == 'opening')? 0.1:objects[i].userData.L);
        //           //   directions[index].rotation.z = degrees_to_radians(-90);
        //           //   directions[index].rotation.x = degrees_to_radians(-90);
        //           //   directions[index].rotation.y = degrees_to_radians(90);

        //           //   positionZ = objects[i].position.z;
        //           // }

        //           directions[index].position.x = positionX;
        //           directions[index].position.z = positionZ;
        //           // directions[index].rotation.y = objects[i].rotation.y;

        //           scene.add(directions[index]);
        //         }
        //       }
        //     }
        //   }
        //   if (objects[i].name != "Element") {
        //     // Change coordinates of the left Cover
        //     if (objects[i].userData.hasLeftCover == true) {
        //       let positionX, positionY, positionZ;
        //       if (objects[i].rotation.y == degrees_to_radians(0)) {
        //         positionX = objects[i].position.x + 0.018;
        //         positionZ = objects[i].position.z;
        //         positionY = objects[i].position.y + 0.1;
        //       } else if (objects[i].rotation.y == degrees_to_radians(90)) {
        //         positionX = objects[i].position.x;
        //         positionZ = objects[i].position.z - 0.018;
        //         positionY = objects[i].position.y + 0.1;
        //       } else if (objects[i].rotation.y == degrees_to_radians(180)) {
        //         positionX = objects[i].position.x - 0.018;
        //         positionZ = objects[i].position.z;
        //         positionY = objects[i].position.y + 0.1;
        //       } else if (objects[i].rotation.y == degrees_to_radians(-90)) {
        //         positionX = objects[i].position.x;
        //         positionZ = objects[i].position.z + 0.018;
        //         positionY = objects[i].position.y + 0.1;
        //       }

        //       for (let index = 0; index < leftCovers.length; index++) {
        //         if (
        //           leftCovers[index].uuid == objects[i].userData.uuidLeftCover
        //         ) {
        //           leftCovers[index].position.x = positionX;
        //           leftCovers[index].position.z = positionZ;
        //           leftCovers[index].rotation.y = objects[i].rotation.y;
        //           scene.add(leftCovers[index]);
        //         }
        //       }
        //     }

        //     //  Change coordinates of the right Cover
        //     if (objects[i].userData.hasRightCover == true) {
        //       let positionX, positionY, positionZ;
        //       if (objects[i].rotation.y == degrees_to_radians(0)) {
        //         positionX = objects[i].position.x - objects[i].userData.W;
        //         positionZ = objects[i].position.z;
        //         positionY = objects[i].position.y + 0.1;
        //       } else if (objects[i].rotation.y == degrees_to_radians(90)) {
        //         positionX = objects[i].position.x;
        //         positionZ = objects[i].position.z + objects[i].userData.W;
        //         positionY = objects[i].position.y + 0.1;
        //       } else if (objects[i].rotation.y == degrees_to_radians(180)) {
        //         positionX = objects[i].position.x + objects[i].userData.W;
        //         positionZ = objects[i].position.z;

        //         positionY = objects[i].position.y + 0.1;
        //       } else if (objects[i].rotation.y == degrees_to_radians(-90)) {
        //         positionX = objects[i].position.x;
        //         positionZ = objects[i].position.z - objects[i].userData.W;
        //         positionY = objects[i].position.y + 0.1;
        //       }

        //       for (let index = 0; index < rightCovers.length; index++) {
        //         if (
        //           rightCovers[index].uuid == objects[i].userData.uuidRightCover
        //         ) {
        //           rightCovers[index].position.x = positionX;
        //           rightCovers[index].position.z = positionZ;
        //           rightCovers[index].rotation.y = objects[i].rotation.y;
        //           scene.add(rightCovers[index]);
        //         }
        //       }
        //     }
        //     //  Change coordinates of the Cornice
        //     if (objects[i].userData.hasCornice == true) {
        //       let positionX, positionY, positionZ;
        //       positionX = objects[i].position.x;
        //       positionZ = objects[i].position.z;

        //       var lightPosX;
        //       var lightPosZ;
        //       if (objects[i].rotation.y == degrees_to_radians(0)) {
        //         positionZ =
        //           objects[i].position.z + objects[i].userData.L - 0.05;
        //         lightPosX = objects[i].position.x - objects[i].userData.W / 2;
        //         lightPosZ =
        //           objects[i].position.z + objects[i].userData.L - 0.05;
        //         positionX += 0.018;
        //       } else if (objects[i].rotation.y == degrees_to_radians(180)) {
        //         positionZ =
        //           objects[i].position.z - objects[i].userData.L + 0.05;
        //         lightPosX = objects[i].position.x + objects[i].userData.W / 2;
        //         lightPosZ =
        //           objects[i].position.z - objects[i].userData.L + 0.05;
        //         positionX -= 0.018;
        //       } else if (objects[i].rotation.y == degrees_to_radians(90)) {
        //         positionX =
        //           objects[i].position.x + objects[i].userData.L - 0.05;
        //         lightPosZ = objects[i].position.z + objects[i].userData.W / 2;
        //         lightPosX =
        //           objects[i].position.x + objects[i].userData.L - 0.05;
        //         positionZ -= 0.018;
        //       } else {
        //         positionX =
        //           objects[i].position.x - objects[i].userData.L + 0.05;
        //         lightPosZ = objects[i].position.z - objects[i].userData.W / 2;
        //         lightPosX =
        //           objects[i].position.x - objects[i].userData.L + 0.05;
        //         positionZ += 0.018;
        //       }

        //       for (let index = 0; index < Cornices.length; index++) {
        //         if (Cornices[index].uuid == objects[i].userData.uuidCornice) {
        //           Cornices[index].position.x = positionX;
        //           Cornices[index].position.z = positionZ;
        //           // Cornices[index].position.y = positionY;
        //           Cornices[index].rotation.y = objects[i].rotation.y;
        //           // wallPanels[index].scale.x = objects[i].userData.W;

        //           // wallPanels[index].scale.x = objects[i].userData.W;

        //           scene.add(Cornices[index]);
        //         }
        //       }
        //       for (let index = 0; index < lightObjects.length; index++) {
        //         if (
        //           lightObjects[index].uuid ==
        //           objects[i].userData.uuidLightCornice
        //         ) {
        //           lightObjects[index].position.x = lightPosX;
        //           lightObjects[index].position.z = lightPosZ;
        //           lightObjects[index].rotation.y = objects[i].rotation.y;
        //           scene.add(lightObjects[index]);
        //         }
        //       }
        //     }
        //     //  Change coordinates of the Deco strip
        //     if (objects[i].userData.hasDecoStrip == true) {
        //       let positionX, positionY, positionZ;
        //       positionX = objects[i].position.x;
        //       positionZ = objects[i].position.z;

        //       var lightPosX;
        //       var lightPosZ;
        //       var lightRotX = 0;
        //       var lightRotZ = 0;
        //       var lightRotY = 0;

        //       if (objects[i].rotation.y == degrees_to_radians(0)) {
        //         positionZ =
        //           objects[i].position.z + objects[i].userData.L - 0.018;
        //         lightPosX = objects[i].position.x - objects[i].userData.W / 2;
        //         lightPosZ =
        //           objects[i].position.z + objects[i].userData.L - 0.118;
        //         lightRotX = degrees_to_radians(-90);
        //         lightRotZ = degrees_to_radians(0);
        //         lightRotY = objects[i].rotation.y;
        //       } else if (objects[i].rotation.y == degrees_to_radians(180)) {
        //         positionZ =
        //           objects[i].position.z - objects[i].userData.L + 0.018;
        //         lightPosX = objects[i].position.x + objects[i].userData.W / 2;
        //         lightPosZ =
        //           objects[i].position.z - objects[i].userData.L + 0.118;
        //         lightRotX = degrees_to_radians(90);
        //         lightRotZ = degrees_to_radians(180);
        //         lightRotY = objects[i].rotation.y;
        //       } else if (objects[i].rotation.y == degrees_to_radians(90)) {
        //         positionX =
        //           objects[i].position.x + objects[i].userData.L - 0.018;
        //         lightPosZ = objects[i].position.z + objects[i].userData.W / 2;
        //         lightPosX =
        //           objects[i].position.x + objects[i].userData.L - 0.118;
        //         lightRotZ = degrees_to_radians(180);
        //         lightRotY = objects[i].rotation.y;
        //       } else {
        //         positionX =
        //           objects[i].position.x - objects[i].userData.L + 0.018;
        //         lightPosZ = objects[i].position.z - objects[i].userData.W / 2;
        //         lightPosX =
        //           objects[i].position.x - objects[i].userData.L + 0.118;
        //         lightRotZ = degrees_to_radians(180);
        //         lightRotY = objects[i].rotation.y;
        //       }
        //       // if(objects[i].rotation.y == degrees_to_radians(0))
        //       // positionZ = objects[i].position.z + objects[i].userData.L - 0.018;
        //       // else if(objects[i].rotation.y == degrees_to_radians(180))
        //       // positionZ = objects[i].position.z - objects[i].userData.L + 0.018;
        //       // else if(objects[i].rotation.y == degrees_to_radians(90))
        //       // positionX = objects[i].position.x + objects[i].userData.L - 0.018;
        //       // else
        //       // positionX = objects[i].position.x - objects[i].userData.L + 0.018;
        //       positionY = objects[i].position.y - 0.1;

        //       for (let index = 0; index < decoStrips.length; index++) {
        //         if (
        //           decoStrips[index].uuid == objects[i].userData.uuidDecoStrip
        //         ) {
        //           decoStrips[index].position.x = positionX;
        //           decoStrips[index].position.z = positionZ;
        //           decoStrips[index].position.y = positionY;
        //           decoStrips[index].rotation.y = objects[i].rotation.y;
        //           // wallPanels[index].scale.x = objects[i].userData.W;

        //           // wallPanels[index].scale.x = objects[i].userData.W;

        //           scene.add(decoStrips[index]);
        //         }
        //       }
        //       for (let index = 0; index < lightObjects.length; index++) {
        //         if (lightObjects[index].uuid == objects[i].userData.uuidLight) {
        //           lightObjects[index].position.x = lightPosX;
        //           lightObjects[index].position.z = lightPosZ;
        //           lightObjects[index].position.y = positionY + 0.1;
        //           if (lightRotX == 0) {
        //             lightObjects[index].rotation.y = lightRotZ;
        //             lightObjects[index].rotation.z = degrees_to_radians(-90);
        //             lightObjects[index].rotation.x = degrees_to_radians(90);
        //             // console.log("Here1 lights");
        //           } else {
        //             lightObjects[index].rotation.x = lightRotX;
        //             lightObjects[index].rotation.z = lightRotZ;
        //             lightObjects[index].rotation.y = lightRotY;
        //             // console.log("Here2 lights");
        //           }

        //           // lightObjects[index].rotation.y = objects[i].rotation.y;
        //           scene.add(lightObjects[index]);
        //           // console.log("lightObjects[index]  ", lightObjects[index]);
        //           break;
        //         }
        //       }
        //     }
        //     //  Change coordinates of the wall panel
        //     if (objects[i].userData.hasWallPanel == true) {
        //       let positionX, positionY, positionZ;
        //       positionX = objects[i].position.x;
        //       positionZ = objects[i].position.z;
        //       positionY = objects[i].userData.H + 0.2;

        //       for (let index = 0; index < wallPanels.length; index++) {
        //         if (
        //           wallPanels[index].uuid == objects[i].userData.uuidWallPanel
        //         ) {
        //           wallPanels[index].position.x = positionX;
        //           wallPanels[index].position.z = positionZ;
        //           wallPanels[index].position.y = positionY;
        //           wallPanels[index].rotation.y = objects[i].rotation.y;
        //           // wallPanels[index].scale.x = objects[i].userData.W;
        //           wallPanels[index].scale.x = objects[i].userData.W;

        //           if (
        //             positionX == measuresXG.max - wallWidth ||
        //             positionX == measuresXG.min + wallWidth ||
        //             positionZ == measuresZG.max - wallWidth ||
        //             positionZ == measuresZG.min + wallWidth
        //           )
        //             wallPanels[index].visible = true;
        //           else wallPanels[index].visible = false;
        //           scene.add(wallPanels[index]);
        //         }
        //       }
        //     }

        //     //  Change coordinates of the back Cover
        //     if (objects[i].userData.hasBackCover == true) {
        //       let positionX, positionY, positionZ;
        //       positionX = objects[i].position.x;
        //       positionZ = objects[i].position.z;
        //       if (objects[i].rotation.y == degrees_to_radians(0)) {
        //         positionZ = objects[i].position.z - 0.001;
        //       } else if (objects[i].rotation.y == degrees_to_radians(90)) {
        //         positionX = objects[i].position.x - 0.001;
        //       } else if (objects[i].rotation.y == degrees_to_radians(180)) {
        //         positionZ = objects[i].position.z + 0.001;
        //       } else if (objects[i].rotation.y == degrees_to_radians(-90)) {
        //         positionX = objects[i].position.x + 0.001;
        //       }
        //       positionY = objects[i].position.y + 0.1;

        //       for (let index = 0; index < backCovers.length; index++) {
        //         if (
        //           backCovers[index].uuid == objects[i].userData.uuidBackCover
        //         ) {
        //           backCovers[index].position.x = positionX;
        //           backCovers[index].position.z = positionZ;
        //           backCovers[index].rotation.y = objects[i].rotation.y;

        //           if (
        //             positionX == measuresXG.max - wallWidth + 0.001 ||
        //             positionX == measuresXG.min + wallWidth - 0.001 ||
        //             positionZ == measuresZG.max - wallWidth + 0.001 ||
        //             positionZ == measuresZG.min + wallWidth - 0.001
        //           )
        //             backCovers[index].visible = false;
        //           else backCovers[index].visible = true;

        //           // console.log("backCovers  ", backCovers);

        //           scene.add(backCovers[index]);
        //         }
        //       }
        //     }

        //     //  Change coordinates of the light of skirting
        //     if (objects[i].userData.hasLightSkirting == true) {
        //       var lightPosX;
        //       var lightPosZ;
        //       if (objects[i].rotation.y == degrees_to_radians(0)) {
        //         lightPosX = objects[i].position.x - objects[i].userData.W / 2;
        //         lightPosZ =
        //           objects[i].position.z + objects[i].userData.L - 0.014;
        //       } else if (objects[i].rotation.y == degrees_to_radians(180)) {
        //         lightPosX = objects[i].position.x + objects[i].userData.W / 2;
        //         lightPosZ =
        //           objects[i].position.z - objects[i].userData.L + 0.014;
        //       } else if (objects[i].rotation.y == degrees_to_radians(90)) {
        //         lightPosZ = objects[i].position.z + objects[i].userData.W / 2;
        //         lightPosX =
        //           objects[i].position.x + objects[i].userData.L - 0.014;
        //       } else {
        //         lightPosZ = objects[i].position.z - objects[i].userData.W / 2;
        //         lightPosX =
        //           objects[i].position.x - objects[i].userData.L + 0.014;
        //       }

        //       for (let index = 0; index < lightObjects.length; index++) {
        //         if (
        //           lightObjects[index].uuid ==
        //           objects[i].userData.uuidLightSkirting
        //         ) {
        //           lightObjects[index].position.x = lightPosX;
        //           lightObjects[index].position.z = lightPosZ;
        //           lightObjects[index].rotation.y = objects[i].rotation.y;
        //           scene.add(lightObjects[index]);
        //         }
        //       }
        //     }

        //   }
        // }

        // let RightLine = new Measures();
        // let LeftLine = new Measures();

        // const loaderr = new GLTFLoader();
        // let j;
        // (drawR = false),
        //   (drawL = false),
        //   (drawF = false),
        //   (drawB = false),
        //   (drawT = false),
        //   (drawBO = false);
        // obj = objDraggable;

        // let maxRight = 0;
        // let maxLeft = 0;

        // let objBeside = null;
        // let objBesideLeft = null;
        // let objBesideRight = null;

        // if (objDraggable.rotation.y == degrees_to_radians(0)) {
        //   // Right Line
        //   if (
        //     objDraggable.position.x - objDraggable.userData.W >
        //     measuresXG.min + wallWidth
        //   ) {
        //     maxRight = measuresXG.min;
        //     RightLine.line1X = maxRight;
        //     RightLine.line2X =
        //       objDraggable.position.x - objDraggable.userData.W;
        //     RightLine.line1Z =
        //       objDraggable.position.z + objDraggable.userData.L / 2;
        //     RightLine.line2Z =
        //       objDraggable.position.z + objDraggable.userData.L / 2;
        //     // drawR = true;
        //   }
        //   // Left Line
        //   if (objDraggable.position.x < +measuresXG.max - wallWidth) {
        //     maxLeft = +measuresXG.max;
        //     LeftLine.line1X = maxLeft;
        //     LeftLine.line2X = objDraggable.position.x;
        //     LeftLine.line1Z =
        //       objDraggable.position.z + objDraggable.userData.L / 2;
        //     LeftLine.line2Z =
        //       objDraggable.position.z + objDraggable.userData.L / 2;
        //     // drawL = true;
        //   }
        // } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
        //   // Right Line
        //   if (
        //     objDraggable.position.x + objDraggable.userData.W <
        //     measuresXG.max - wallWidth
        //   ) {
        //     maxRight = measuresXG.max;
        //     RightLine.line1X = maxRight;
        //     RightLine.line2X =
        //       objDraggable.position.x + objDraggable.userData.W;
        //     RightLine.line1Z =
        //       objDraggable.position.z - objDraggable.userData.L / 2;
        //     RightLine.line2Z =
        //       objDraggable.position.z - objDraggable.userData.L / 2;
        //     // drawR = true;
        //   }
        //   // Left Line
        //   if (objDraggable.position.x > measuresXG.min + wallWidth) {
        //     maxLeft = measuresXG.min;
        //     LeftLine.line1X = maxLeft;
        //     LeftLine.line2X = objDraggable.position.x;
        //     LeftLine.line1Z =
        //       objDraggable.position.z - objDraggable.userData.L / 2;
        //     LeftLine.line2Z =
        //       objDraggable.position.z - objDraggable.userData.L / 2;
        //     // drawL = true;
        //   }
        // } else if (objDraggable.rotation.y == degrees_to_radians(-90)) {
        //   // Right Line
        //   if (
        //     objDraggable.position.z - objDraggable.userData.W >
        //     measuresZG.min + wallWidth
        //   ) {
        //     maxRight = measuresZG.min;
        //     RightLine.line1X =
        //       +objDraggable.position.x - objDraggable.userData.L / 2;
        //     RightLine.line2X =
        //       +objDraggable.position.x - objDraggable.userData.L / 2;
        //     RightLine.line1Z = maxRight;
        //     RightLine.line2Z =
        //       objDraggable.position.z - objDraggable.userData.W;
        //     // drawR = true;
        //   }
        //   // Left Line
        //   if (objDraggable.position.z < measuresZG.max - wallWidth) {
        //     maxLeft = measuresZG.max;
        //     LeftLine.line1X =
        //       +objDraggable.position.x - objDraggable.userData.L / 2;
        //     LeftLine.line2X =
        //       +objDraggable.position.x - objDraggable.userData.L / 2;
        //     LeftLine.line1Z = maxLeft;
        //     LeftLine.line2Z = objDraggable.position.z;
        //     // drawL = true;
        //   }
        // } else {
        //   // Right Line
        //   if (
        //     objDraggable.position.z + objDraggable.userData.W <
        //     measuresZG.max - wallWidth
        //   ) {
        //     maxRight = measuresZG.max;
        //     RightLine.line1X =
        //       +objDraggable.position.x + objDraggable.userData.L / 2;
        //     RightLine.line2X =
        //       +objDraggable.position.x + objDraggable.userData.L / 2;
        //     RightLine.line1Z = maxRight;
        //     RightLine.line2Z =
        //       objDraggable.position.z + objDraggable.userData.W;
        //     // drawR = true;
        //   }
        //   // Left Line
        //   if (objDraggable.position.z > measuresZG.min + wallWidth) {
        //     maxLeft = measuresZG.min;
        //     LeftLine.line1X =
        //       +objDraggable.position.x + objDraggable.userData.L / 2;
        //     LeftLine.line2X =
        //       +objDraggable.position.x + objDraggable.userData.L / 2;
        //     LeftLine.line1Z = maxLeft;
        //     LeftLine.line2Z = objDraggable.position.z;
        //     // drawL = true;
        //   }
        // }

        // let rightCoordinates = {
        //   x: 0,
        //   z: 0,
        // };

        // let leftCoordinates = {
        //   x: 0,
        //   z: 0,
        // };

        // for await (const object of objects) {
        //   if (
        //     objects.length > 1 &&
        //     object.name == objDraggable.name &&
        //     object.uuid != objDraggable.uuid
        //   ) {
        //     if (
        //       object.rotation.y == degrees_to_radians(0) &&
        //       objDraggable.rotation.y == degrees_to_radians(0)
        //     ) {
        //       if (
        //         maxRight < object.position.x &&
        //         ((object.position.z >= objDraggable.position.z &&
        //           object.position.z <=
        //             objDraggable.position.z + objDraggable.userData.L) ||
        //           (object.position.z + objDraggable.userData.L >=
        //             objDraggable.position.z &&
        //             object.position.z + objDraggable.userData.L <=
        //               objDraggable.position.z + objDraggable.userData.L)) &&
        //         object.position.x <=
        //           objDraggable.position.x - objDraggable.userData.W
        //       ) {
        //         maxRight = object.position.x;
        //         RightLine.line1X = object.position.x;
        //         drawR = true;
        //         objBeside = object;
        //         objBesideRight = object;
        //         // console.log("objBesideRight setted ", objBesideRight);
        //       }
        //       if (
        //         maxLeft > object.position.x &&
        //         ((object.position.z >= objDraggable.position.z &&
        //           object.position.z <=
        //             objDraggable.position.z + objDraggable.userData.L) ||
        //           (object.position.z + objDraggable.userData.L >=
        //             objDraggable.position.z &&
        //             object.position.z + objDraggable.userData.L <=
        //               objDraggable.position.z + objDraggable.userData.L)) &&
        //         object.position.x > objDraggable.position.x
        //       ) {
        //         maxLeft = object.position.x - object.userData.W;
        //         LeftLine.line1X = object.position.x - object.userData.W;
        //         drawL = true;
        //         objBeside = object;
        //         objBesideLeft = object;
        //       }
        //     } else if (
        //       object.rotation.y == degrees_to_radians(90) &&
        //       objDraggable.rotation.y == degrees_to_radians(90)
        //     ) {
        //       if (
        //         maxRight > object.position.z &&
        //         ((object.position.x >= objDraggable.position.x &&
        //           object.position.x <=
        //             objDraggable.position.x + objDraggable.userData.L) ||
        //           (object.position.x + objDraggable.userData.L >=
        //             objDraggable.position.x &&
        //             object.position.x + objDraggable.userData.L <=
        //               objDraggable.position.x + objDraggable.userData.L)) &&
        //         object.position.z >=
        //           objDraggable.position.z + objDraggable.userData.W
        //       ) {
        //         maxRight = object.position.z;
        //         RightLine.line1Z = object.position.z;
        //         drawR = true;
        //         objBeside = object;
        //         objBesideRight = object;
        //         // await drawLines(objDraggable.userData.L/2);
        //       }

        //       if (
        //         maxLeft < object.position.z &&
        //         ((object.position.x >= objDraggable.position.x &&
        //           object.position.x <=
        //             objDraggable.position.x + objDraggable.userData.L) ||
        //           (object.position.x + objDraggable.userData.L >=
        //             objDraggable.position.x &&
        //             object.position.x + objDraggable.userData.L <=
        //               objDraggable.position.x + objDraggable.userData.L)) &&
        //         object.position.z < objDraggable.position.z
        //       ) {
        //         maxLeft = object.position.z + object.userData.W;
        //         LeftLine.line1Z = object.position.z + object.userData.W;
        //         drawL = true;
        //         objBeside = object;
        //         objBesideLeft = object;
        //       }
        //     } else if (
        //       object.rotation.y == degrees_to_radians(180) &&
        //       objDraggable.rotation.y == degrees_to_radians(180)
        //     ) {
        //       if (
        //         maxRight > object.position.x &&
        //         ((object.position.z <= objDraggable.position.z &&
        //           object.position.z >=
        //             objDraggable.position.z - objDraggable.userData.L) ||
        //           (object.position.z - objDraggable.userData.L <
        //             objDraggable.position.z &&
        //             object.position.z - objDraggable.userData.L >
        //               objDraggable.position.z - objDraggable.userData.L)) &&
        //         object.position.x >=
        //           objDraggable.position.x + objDraggable.userData.W
        //       ) {
        //         maxRight = object.position.x;
        //         RightLine.line1X = object.position.x;

        //         drawR = true;
        //         objBeside = object;
        //         objBesideRight = object;
        //         // await drawLines(objDraggable.userData.L/2);
        //       }

        //       if (
        //         maxLeft < object.position.x &&
        //         ((object.position.z <= objDraggable.position.z &&
        //           object.position.z >=
        //             objDraggable.position.z - objDraggable.userData.L) ||
        //           (object.position.z - objDraggable.userData.L <
        //             objDraggable.position.z &&
        //             object.position.z - objDraggable.userData.L >
        //               objDraggable.position.z - objDraggable.userData.L)) &&
        //         object.position.x < objDraggable.position.x
        //       ) {
        //         maxLeft = object.position.x + object.userData.W;
        //         LeftLine.line1X = object.position.x + object.userData.W;
        //         drawL = true;
        //         objBeside = object;
        //         objBesideLeft = object;
        //       }
        //     } else if (
        //       object.rotation.y == degrees_to_radians(-90) &&
        //       objDraggable.rotation.y == degrees_to_radians(-90)
        //     ) {
        //       if (
        //         maxRight < object.position.z &&
        //         ((object.position.x <= objDraggable.position.x &&
        //           object.position.x >=
        //             objDraggable.position.x - objDraggable.userData.L) ||
        //           (object.position.x - objDraggable.userData.L <
        //             objDraggable.position.x &&
        //             object.position.x - objDraggable.userData.L >
        //               objDraggable.position.x - objDraggable.userData.L)) &&
        //         object.position.z <=
        //           objDraggable.position.z - objDraggable.userData.W
        //       ) {
        //         maxRight = object.position.z;
        //         RightLine.line1Z = object.position.z;
        //         drawR = true;
        //         objBeside = object;
        //         objBesideRight = object;
        //       }

        //       if (
        //         maxLeft > object.position.z &&
        //         ((object.position.x <= objDraggable.position.x &&
        //           object.position.x >=
        //             objDraggable.position.x - objDraggable.userData.L) ||
        //           (object.position.x - objDraggable.userData.L <
        //             objDraggable.position.x &&
        //             object.position.x - objDraggable.userData.L >
        //               objDraggable.position.x - objDraggable.userData.L)) &&
        //         object.position.z > objDraggable.position.z
        //       ) {
        //         maxLeft = object.position.z - object.userData.W;
        //         LeftLine.line1Z = object.position.z - object.userData.W;
        //         drawL = true;
        //         objBeside = object;
        //         objBesideLeft = object;
        //       }
        //     }
        //   }
        // }

        // // Set the right position of the filler.
        // if (objDraggable.rotation.y == degrees_to_radians(0)) {
        //   rightCoordinates.x =
        //     objDraggable.position.x - objDraggable.userData.W;
        //   rightCoordinates.z = objDraggable.position.z;
        //   leftCoordinates.x = maxLeft;
        //   leftCoordinates.z = objDraggable.position.z;
        // } else if (objDraggable.rotation.y == degrees_to_radians(90)) {
        //   rightCoordinates.x = objDraggable.position.x;
        //   rightCoordinates.z =
        //     objDraggable.position.z + objDraggable.userData.W;
        //   leftCoordinates.x = objDraggable.position.x;
        //   leftCoordinates.z = maxLeft;
        // } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
        //   rightCoordinates.x =
        //     objDraggable.position.x + objDraggable.userData.W;
        //   rightCoordinates.z = objDraggable.position.z;
        //   leftCoordinates.x = maxLeft;
        //   leftCoordinates.z = objDraggable.position.z;
        // } else {
        //   rightCoordinates.x = objDraggable.position.x;
        //   rightCoordinates.z =
        //     objDraggable.position.z - objDraggable.userData.W;
        //   leftCoordinates.x = objDraggable.position.x;
        //   leftCoordinates.z = maxLeft;
        // }

        // // console.log("maxRight ", RightLine.getValue() * 1000);
        // var shutterMaterial,
        //   skirtingMaterial,
        //   backMaterial,
        //   wallMaterial,
        //   wallScale,
        //   wallPosition;
        // for (let index = 0; index < objDraggable.children.length; index++) {
        //   if (objDraggable.children[index].name.match(/Shutter.*/)) {
        //     shutterMaterial = objDraggable.children[index].material.map;
        //   }
        //   if (objDraggable.children[index].name.match(/Skirting.*/)) {
        //     skirtingMaterial = objDraggable.children[index].material.map;
        //   }
        //   if (objDraggable.children[index].name.match(/carcass.*/)) {
        //     backMaterial = objDraggable.children[index].material.map;
        //   }
        // }

        // if (objDraggable.userData.hasWallPanel) {
        //   for (let index = 0; index < wallPanels.length; index++) {
        //     if (wallPanels[index].uuid == objDraggable.userData.uuidWallPanel) {
        //       wallMaterial = wallPanels[index].children[4].material.map;
        //       wallScale = wallPanels[index].scale.y;
        //       wallPosition = objDraggable.position.y + objDraggable.userData.H;
        //     }
        //   }
        // }

        // // if(objBesideLeft != null ){
        // //   // objDraggable.userData.objBesideLeft =  null;
        // //   // objDraggable.userData.objBesideLeft.userData.objBesideRight = null ;
        // //   objDraggable.userData.objBesideLeft =  objBesideLeft;
        // //   objDraggable.userData.objBesideLeft.userData.objBesideRight = objDraggable;
        // // }

        // // if(objBesideRight != null){
        // //   // objDraggable.userData.objBesideRight =  null;
        // //   // objDraggable.userData.objBesideRight.userData.objBesideLeft = null;
        // //   objDraggable.userData.objBesideRight =  objBesideRight;
        // //   objDraggable.userData.objBesideRight.userData.objBesideLeft = objDraggable;
        // //         }
        // // Right filler
        // if (
        //   RightLine.getValue() * 1000 <= 200 &&
        //   RightLine.getValue() * 1000 > 0 &&
        //   maxRight != 0 &&
        //   objDraggable.name != "Element"
        // ) {
        //   if (objBesideRight != null) {
        //     objDraggable.userData.objBesideRight = objBesideRight;
        //     objDraggable.userData.objBesideRight.userData.objBesideLeft =
        //       objDraggable;
        //   }
        //   loaderr.load("/obj/newObjects/filler.glb", function (gltf) {
        //     let object = gltf.scene;

        //     object.position.x = rightCoordinates.x;
        //     object.position.z = rightCoordinates.z;
        //     object.name = "filler";

        //     object.position.y = objDraggable.position.y;
        //     object.scale.x = RightLine.getValue();
        //     object.rotation.y = objDraggable.rotation.y;
        //     objDraggable.userData.rightFillerId = object.uuid;
        //     // console.log("Right filler ", object);
        //     for (let t = 0; t < object.children.length; t++) {
        //       if (object.children[t].type == "Mesh") {
        //         object.children[t].userData.uuid = object.uuid;
        //         object.children[t].material.metalness = 0;
        //         if (t == 2) object.children[t].material.map = shutterMaterial;
        //         else if (t == 4) object.children[t].material.map = backMaterial;
        //         else if (t == 3)
        //           object.children[t].material.map = skirtingMaterial;
        //         else if (t == 1) {
        //           if (wallMaterial) {
        //             object.children[t].clone();
        //             let color = "MC40";
        //             for (let k = 0; k < wallPanels.length; k++) {
        //               if (
        //                 wallPanels[k].uuid ==
        //                 objDraggable.userData.uuidWallPanel
        //               ) {
        //                 color = wallPanels[k].userData.color;
        //               }
        //               1;
        //             }

        //             let texture = textureLoader.load(
        //               "/colors/" + color + ".png"
        //             );
        //             // texture.offset.set(0.05, 0.002);
        //             // texture.repeat.set(0.02, 0.002);
        //             texture.magFilter = NearestFilter;
        //             texture.mapping = UVMapping;
        //             texture.wrapS = RepeatWrapping;
        //             texture.wrapT = RepeatWrapping;
        //             texture.side = DoubleSide;
        //             texture.flipY = true;
        //             object.children[t].material.map = texture;
        //             // object.children[t].material.map = wallMaterial;
        //             object.children[t].material.map.repeat.set(1, 15);
        //             // object.children[t].material.map.rotate.set(1.55);
        //             // object.children[t].material.map.rotate = 1.55;

        //             // object.children[t].position.y = 0.87;
        //           } else object.children[t].visible = false;
        //         }
        //         object.children[t].castShadow = true;
        //         object.children[t].receiveShadow = true;
        //       }
        //     }
        //     if (is2D) {
        //       object.scale.y = 0.1;
        //     }

        //     scene.add(object);
        //   });

        //   for (let i = 0; i < rightCovers.length; i++) {
        //     if (rightCovers[i].uuid == objDraggable.userData.uuidRightCover) {
        //       rightCovers[i].visible = false;
        //       scene.add(rightCovers[i]);
        //     }
        //   }

        //   if (
        //     objBesideRight != null &&
        //     objBesideRight.name != "Element" &&
        //     objBesideRight.name === objDraggable.name
        //   ) {
        //     for (let i = 0; i < leftCovers.length; i++) {
        //       if (leftCovers[i].uuid == objBesideRight.userData.uuidLeftCover) {
        //         leftCovers[i].visible = false;
        //         scene.add(leftCovers[i]);
        //       }
        //     }

        //     objBesideRight.userData.Beside = objDraggable;
        //     objDraggable.userData.objBesideRight = objBesideRight;
        //     objDraggable.userData.typeBeside = "right";

        //     scene.add(objDraggable);
        //     scene.add(objBesideRight);
        //   }
        // }

        // // Left filler
        // if (
        //   LeftLine.getValue() * 1000 <= 200 &&
        //   LeftLine.getValue() * 1000 > 0 &&
        //   maxLeft != 0 &&
        //   objDraggable.name != "Element"
        // ) {
        //   if (objBesideLeft != null) {
        //     objDraggable.userData.objBesideLeft = objBesideLeft;
        //     objDraggable.userData.objBesideLeft.userData.objBesideRight =
        //       objDraggable;
        //   }
        //   loaderr.load("/obj/newObjects/filler.glb", function (gltf) {
        //     let object = gltf.scene;

        //     object.position.x = leftCoordinates.x;
        //     object.position.z = leftCoordinates.z;
        //     object.name = "filler";
        //     object.position.y = objDraggable.position.y;
        //     object.scale.x = LeftLine.getValue();
        //     object.rotation.y = objDraggable.rotation.y;
        //     objDraggable.userData.leftFillerId = object.uuid;
        //     // console.log("Left filler    ", object);
        //     for (let t = 0; t < object.children.length; t++) {
        //       if (object.children[t].type == "Mesh") {
        //         object.children[t].userData.uuid = object.uuid;
        //         object.children[t].material.metalness = 0;

        //         if (t == 2) object.children[t].material.map = shutterMaterial;
        //         else if (t == 4) object.children[t].material.map = backMaterial;
        //         else if (t == 3)
        //           object.children[t].material.map = skirtingMaterial;
        //         else if (t == 1) {
        //           if (wallMaterial) {
        //             object.children[t].clone();
        //             let color = "MC40";
        //             for (let k = 0; k < wallPanels.length; k++) {
        //               if (
        //                 wallPanels[k].uuid ==
        //                 objDraggable.userData.uuidWallPanel
        //               ) {
        //                 color = wallPanels[k].userData.color;
        //               }
        //               1;
        //             }
        //             let texture = textureLoader.load(
        //               "/colors/" + color + ".png"
        //             );
        //             // texture.offset.set(0.05, 0.002);
        //             // texture.repeat.set(0.02, 0.002);
        //             texture.magFilter = NearestFilter;
        //             texture.mapping = UVMapping;
        //             texture.wrapS = RepeatWrapping;
        //             texture.wrapT = RepeatWrapping;
        //             texture.side = DoubleSide;
        //             texture.flipY = true;
        //             object.children[t].material.map = texture;
        //             object.children[t].material.map.repeat.set(1, 15);
        //             // object.children[t].material.map.rotate = 1.55;

        //             // object.children[t].position.y = 0.87;
        //           } else object.children[t].visible = false;
        //         }

        //         object.children[t].castShadow = true;
        //         object.children[t].receiveShadow = true;
        //       }
        //     }
        //     // console.log("filler  ", object);

        //     if (is2D) {
        //       object.scale.y = 0.1;
        //     }
        //     // object.uuid.type='filler';

        //     scene.add(object);
        //   });

        //   for (let i = 0; i < leftCovers.length; i++) {
        //     if (leftCovers[i].uuid == objDraggable.userData.uuidLeftCover) {
        //       leftCovers[i].visible = false;
        //       scene.add(leftCovers[i]);
        //     }
        //   }
        //   if (
        //     objBesideLeft != null &&
        //     objBesideLeft.name != "Element" &&
        //     objBesideLeft.name === objDraggable.name
        //   ) {
        //     for (let i = 0; i < rightCovers.length; i++) {
        //       if (
        //         rightCovers[i].uuid == objBesideLeft.userData.uuidRightCover
        //       ) {
        //         rightCovers[i].visible = false;
        //         scene.add(rightCovers[i]);
        //       }
        //     }

        //     objBesideLeft.userData.Beside = objDraggable;
        //     objDraggable.userData.Beside = objBesideLeft;
        //     objDraggable.userData.typeBeside = "left";

        //     scene.add(objDraggable);
        //     scene.add(objBesideLeft);
        //   }
        // }

        // // console.log("objBesideRight " , objBesideRight);

        // scene.add(objDraggable);
        // // scene.add(objBesideLeft);
        // // scene.add(objBesideRight);
        // if (is2D) {
        //   // console.log("Here 1");
        //   to2D(false, false);
        //   to2D(false, true);
        // }

        // //  for (let h = 0; h < scene.children.length; h++) {
        // //    if(scene.children[h].uuid == objDraggable.userData.Beside.uuid){
        // //     scene.children[h].Beside = null;
        // //     objDraggable.userData.Beside = null;
        // //     break;
        // //    }
        // // for await (const object of scene.children) {
        // //   finishTops.splice(index, 1);
        // //   for (let j = 0; j < scene.children.length; j++) {
        // //     if (
        // //       scene.children[j].uuid == finishTops.uuid
        // //     ) {
        // //       scene.remove(scene.children[j]);
        // //       --j;
        // //     }
        // //   }
        // // }

        // // for (let index = 0; index < finishTops.length; index++) {

        // // }
        // // let savedObj = objDraggable;
        // // objects.unshift(savedObj);
        // // let repeated = 0;
        // // for (let index = 0; index < objects.length; index++) {
        // // let objDraggable = objects[index];

        // // if (objDraggable.uuid == savedObj.uuid) {
        // //   if (repeated == 0) repeated = 1;
        // //   else continue;
        // // }
        // // console.log("repeated  ", repeated);
        // // console.log("objDraggable.uuid    ", objDraggable.uuid);
        // // console.log("uuids  ", uuids);
        // // if (!uuids.includes(objDraggable.uuid)) {

        // // Finish Tops
        // if (objDraggable.name == "B") {
        //   (uuidsLeft = []), (uuidsRight = []);
        //   let finishTopId = objDraggable.userData.finish_uuids;
        //   let Id = objDraggable.uuid;

        //   console.log("Scene   ", scene);
        //   // console.log('Id ' ,Id);
        //   // console.log("objects left ", uuidsLeft);
        //   // console.log("objects right ", uuidsRight);
        //   for await (let obj of scene.children) {
        //     for (
        //       let m = 0;
        //       m < event.object.userData.finish_uuids.length;
        //       m++
        //     ) {
        //       if (obj.uuid == event.object.userData.finish_uuids[m]) {
        //         event.object.userData.finish_uuids.splice(m--, 1);
        //         scene.remove(obj);
        //         break;
        //       }
        //     }
        //   }
        //   //   for (let j = 0; j < scene.children.length; j++) {
        //   //     for (let m = 0; m < event.object.userData.finish_uuids.length; m++) {
        //   //     if (scene.children[j].uuid == event.object.userData.finish_uuids[m]) {
        //   //       event.object.userData.finish_uuids.splice(m,1);
        //   //       m--;
        //   //       scene.remove(scene.children[j]);
        //   //       j--;
        //   //     }
        //   //     // }
        //   //   }
        //   // }
        //   let widthTop = 0;

        //   let remain = 0;
        //   await loaderr.load("/obj/newObjects/finish_top.glb", function (gltf) {
        //     let object = gltf.scene;
        //     widthTop = objDraggable.userData.W;
        //     objDraggable.userData.finish_uuids = [];
        //     objDraggable.userData.finish_uuids.push(object.uuid);
        //     if (uuidsLeft.length == 0) {
        //       object.position.x = objDraggable.position.x;
        //       object.position.z = objDraggable.position.z;
        //     } else {
        //       object.position.x = uuidsLeft[uuidsLeft.length - 1].position.x;
        //       object.position.z = uuidsLeft[uuidsLeft.length - 1].position.z;
        //     }

        //     if (objDraggable.rotation.y == degrees_to_radians(0)) {
        //       if (object.position.x + 0.2 > measuresXG.max) {
        //         // console.log("FFF");
        //         widthTop =
        //           measuresXG.max - object.position.x + objDraggable.userData.W;
        //         object.position.x = measuresXG.max;
        //       } else if (
        //         object.position.x - objDraggable.userData.W - 0.2 <
        //         measuresXG.min
        //       ) {
        //         // console.log("DDD");

        //         widthTop = measuresXG.max - wallWidth + object.position.x;

        //         // object.position.x = - measures.width/2;
        //       }

        //       if (uuidsLeft.length == 0) {
        //         if (uuidsRight.length == 0) {
        //           object.scale.x =
        //             object.position.x - (object.position.x - widthTop);
        //         } else {
        //           if (
        //             Math.abs(
        //               uuidsRight[uuidsRight.length - 1].position.x -
        //                 uuidsRight[uuidsRight.length - 1].userData.W -
        //                 measuresXG.min
        //             ) <= 0.2
        //           ) {
        //             remain =
        //               -measuresXG.min +
        //               (uuidsRight[uuidsRight.length - 1].position.x -
        //                 uuidsRight[uuidsRight.length - 1].userData.W);
        //           }
        //           // console.log("WidthTop  " , widthTop);
        //           // console.log(" object.position.x  ",  object.position.x);
        //           // console.log(" measuresXG.max   ",  uuidsRight[uuidsRight.length - 1].position.x);
        //           // console.log(" object.position.x   ",   uuidsRight[uuidsRight.length - 1].userData.W );
        //           object.scale.x =
        //             object.position.x -
        //             (uuidsRight[uuidsRight.length - 1].position.x -
        //               uuidsRight[uuidsRight.length - 1].userData.W) +
        //             remain;

        //           // object.scale.x = widthTop ;
        //         }
        //       } else {
        //         if (uuidsRight.length == 0) {
        //           object.scale.x =
        //             uuidsLeft[uuidsLeft.length - 1].position.x -
        //             objDraggable.position.x +
        //             widthTop;
        //           // console.log('uuidsLeft[uuidsLeft.length - 1].position.x  ' , uuidsLeft[uuidsLeft.length - 1].position.x );
        //           // console.log('object.position.x   ' , objDraggable.position.x  );
        //           // console.log('widthTop  ' , widthTop  );
        //         } else {
        //           object.scale.x =
        //             uuidsLeft[uuidsLeft.length - 1].position.x -
        //             (uuidsRight[uuidsRight.length - 1].position.x -
        //               uuidsRight[uuidsRight.length - 1].userData.W);
        //         }
        //       }
        //       object.scale.z = objDraggable.userData.L;
        //       object.rotation.y = objDraggable.rotation.y;
        //       // console.log("DDD   "  , object.scale.x);
        //     } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
        //       if (object.position.x - 0.2 < measuresXG.min) {
        //         widthTop =
        //           object.position.x + measuresXG.max + objDraggable.userData.W;
        //         object.position.x = measuresXG.min;
        //       } else if (
        //         object.position.x + objDraggable.userData.W + 0.2 >
        //         measuresXG.max
        //       ) {
        //         widthTop = measuresXG.max - object.position.x;
        //         // object.position.x = measures.width/2;
        //       }
        //       if (uuidsLeft.length == 0) {
        //         if (uuidsRight.length == 0) {
        //           object.scale.x =
        //             object.position.x - (object.position.x + widthTop);
        //         } else {
        //           if (
        //             measuresXG.max -
        //               (uuidsRight[uuidsRight.length - 1].position.x +
        //                 uuidsRight[uuidsRight.length - 1].userData.W) <=
        //             0.2
        //           ) {
        //             remain =
        //               measuresXG.max -
        //               (uuidsRight[uuidsRight.length - 1].position.x +
        //                 uuidsRight[uuidsRight.length - 1].userData.W);
        //           }
        //           object.scale.x =
        //             object.position.x -
        //             (uuidsRight[uuidsRight.length - 1].position.x +
        //               uuidsRight[uuidsRight.length - 1].userData.W) -
        //             remain;
        //         }
        //       } else {
        //         if (uuidsRight.length == 0) {
        //           object.scale.x =
        //             uuidsLeft[uuidsLeft.length - 1].position.x -
        //             (objDraggable.position.x + widthTop);
        //         } else {
        //           object.scale.x =
        //             uuidsLeft[uuidsLeft.length - 1].position.x -
        //             (uuidsRight[uuidsRight.length - 1].position.x +
        //               uuidsRight[uuidsRight.length - 1].userData.W);
        //         }
        //       }
        //       object.position.z = object.position.z - objDraggable.userData.L;
        //       object.scale.z = objDraggable.userData.L;
        //     } else if (objDraggable.rotation.y == degrees_to_radians(90)) {
        //       if (object.position.z - 0.2 < measuresZG.min) {
        //         widthTop =
        //           object.position.z + measuresZG.max + objDraggable.userData.W;
        //         object.position.z = measuresZG.min;
        //       } else if (
        //         object.position.z + objDraggable.userData.W + 0.2 >
        //         measuresZG.max
        //       ) {
        //         widthTop = measuresZG.max - object.position.z;
        //         // object.position.z = measures.length/2;
        //       }
        //       if (uuidsLeft.length == 0) {
        //         if (uuidsRight.length == 0) {
        //           object.scale.z =
        //             object.position.z - (object.position.z + widthTop);
        //         } else {
        //           if (
        //             measuresZG.max -
        //               (uuidsRight[uuidsRight.length - 1].position.z +
        //                 uuidsRight[uuidsRight.length - 1].userData.W) <=
        //             0.2
        //           ) {
        //             remain =
        //               measuresZG.max -
        //               (uuidsRight[uuidsRight.length - 1].position.z +
        //                 uuidsRight[uuidsRight.length - 1].userData.W);
        //             // console.log("Remain  ", remain);
        //           }
        //           object.scale.z =
        //             object.position.z -
        //             (uuidsRight[uuidsRight.length - 1].position.z +
        //               uuidsRight[uuidsRight.length - 1].userData.W) -
        //             remain;
        //         }
        //       } else {
        //         if (uuidsRight.length == 0) {
        //           object.scale.z =
        //             uuidsLeft[uuidsLeft.length - 1].position.z -
        //             (objDraggable.position.z + widthTop);
        //         } else {
        //           object.scale.z =
        //             uuidsLeft[uuidsLeft.length - 1].position.z -
        //             (uuidsRight[uuidsRight.length - 1].position.z +
        //               uuidsRight[uuidsRight.length - 1].userData.W);
        //         }
        //       }
        //       object.rotation.y =
        //         objDraggable.rotation.y + degrees_to_radians(90);
        //       object.position.x = object.position.x;
        //       object.scale.x = objDraggable.userData.L;
        //     } else {
        //       if (object.position.z + 0.2 > measuresZG.max) {
        //         widthTop =
        //           measuresZG.max - object.position.z + objDraggable.userData.W;
        //         object.position.z = measuresZG.max;
        //       } else if (
        //         object.position.z - objDraggable.userData.W - 0.2 <
        //         measuresZG.min
        //       ) {
        //         widthTop = object.position.z + measuresZG.max;
        //         // object.position.z = measures.length/2;
        //       }
        //       if (uuidsLeft.length == 0) {
        //         if (uuidsRight.length == 0) {
        //           object.scale.z =
        //             object.position.z - (object.position.z + widthTop);
        //           object.scale.x = objDraggable.userData.L;
        //           object.rotation.y =
        //             objDraggable.rotation.y + degrees_to_radians(90);
        //         } else {
        //           if (
        //             uuidsRight[uuidsRight.length - 1].position.z -
        //               uuidsRight[uuidsRight.length - 1].userData.W -
        //               measuresZG.min <=
        //             0.2
        //           ) {
        //             remain =
        //               uuidsRight[uuidsRight.length - 1].position.z -
        //               uuidsRight[uuidsRight.length - 1].userData.W -
        //               measuresZG.min;
        //           }
        //           object.scale.x =
        //             object.position.z -
        //             (uuidsRight[uuidsRight.length - 1].position.z -
        //               uuidsRight[uuidsRight.length - 1].userData.W) +
        //             remain;
        //           object.scale.z = objDraggable.userData.L;
        //           object.rotation.y = objDraggable.rotation.y;
        //         }
        //       } else {
        //         if (uuidsRight.length == 0) {
        //           object.scale.x =
        //             uuidsLeft[uuidsLeft.length - 1].position.z -
        //             (objDraggable.position.z - widthTop);
        //           object.scale.z = objDraggable.userData.L;
        //           object.rotation.y = objDraggable.rotation.y;
        //         } else {
        //           object.scale.x =
        //             uuidsLeft[uuidsLeft.length - 1].position.z -
        //             (uuidsRight[uuidsRight.length - 1].position.z -
        //               uuidsRight[uuidsRight.length - 1].userData.W);
        //           object.scale.z = objDraggable.userData.L;
        //           object.rotation.y = objDraggable.rotation.y;
        //         }
        //       }
        //     }

        //     object.position.y =
        //       objDraggable.position.y + objDraggable.userData.H + 0.1;

        //     textureWorktops = textureLoader.load(
        //       "/colors/" + worktopsColor + ".png"
        //     );
        //     textureWorktops.wrapS = textureWorktops.wrapT =
        //       RepeatWrapping;
        //     textureWorktops.offset.set(0.02, 0.02);
        //     textureWorktops.repeat.set(0.02, 0.02);
        //     for (let t = 0; t < object.children.length; t++) {
        //       if (object.children[t].type == "Mesh") {
        //         object.children[t].userData.uuid = object.uuid;
        //         object.children[t].material.metalness = 0;
        //         object.children[t].material.map = textureWorktops;

        //         object.children[t].material.map.repeat.set(8, 8);

        //         // if(t==1)
        //         // object.children[t].material.map = shutterMaterial;
        //         // else if (t==2) object.children[t].material.map = backMaterial;
        //         // else if (t==4) object.children[t].material.map = skirtingMaterial;
        //         // else if (t==3) {
        //         //   if(wallMaterial)
        //         //   {object.children[t].material.map = wallMaterial;

        //         //     object.children[t].position.y = 0.87;
        //         //   }
        //         //   else
        //         //   object.children[t].visible = false;

        //         // }

        //         object.children[t].castShadow = true;
        //         object.children[t].receiveShadow = true;
        //       }
        //     }

        //     for (let index = 0; index < uuidsLeft.length; index++) {
        //       for (let j = 0; j < scene.children.length; j++) {
        //         for (
        //           let m = 0;
        //           m < event.object.userData.finish_uuids.length;
        //           m++
        //         ) {
        //           if (
        //             scene.children[j].uuid ==
        //             uuidsLeft[index].userData.finish_uuids[m]
        //           ) {
        //             uuidsLeft[index].userData.finish_uuids.splice(m--, 1);
        //             scene.remove(scene.children[j--]);
        //           }
        //           // }
        //         }
        //       }
        //       uuidsLeft[index].userData.finish_uuids = [];
        //       uuidsLeft[index].userData.finish_uuids.push(object.uuid);
        //     }
        //     for (let index = 0; index < uuidsRight.length; index++) {
        //       for (let j = 0; j < scene.children.length; j++) {
        //         for (
        //           let m = 0;
        //           m < event.object.userData.finish_uuids.length;
        //           m++
        //         ) {
        //           if (
        //             scene.children[j].uuid ==
        //             uuidsRight[index].userData.finish_uuids
        //           ) {
        //             uuidsRight[index].userData.finish_uuids.splice(m--, 1);
        //             scene.remove(scene.children[j--]);
        //           }
        //         }
        //       }
        //       uuidsRight[index].userData.finish_uuids = [];
        //       uuidsRight[index].userData.finish_uuids.push(object.uuid);
        //     }
        //     // object.userData.uuidObj = objDraggable.uuid;
        //     if (is2D) object.visible = false;

        //     object.name = "TOP";

        //     finishTops.push(object);

        //     // object.uuid.type='filler';
        //     scene.add(object);
        //   });
        // }
        // // }
        // //  }
        // // }

        // if (
        //   backOpenings.length > 0 ||
        //   frontOpenings.length > 0 ||
        //   leftOpenings.length > 0 ||
        //   rightOpenings.length > 0 || wallsOpen
        // ) {
        //   walls("Any thing");
        //   wallsOpen = (wallsOpen == false) ? true: (
        //     backOpenings.length > 0 ||
        //     frontOpenings.length > 0 ||
        //     leftOpenings.length > 0 ||
        //     rightOpenings.length > 0
        //   )?true:false;

        // }

        // render();
      });

      // let control;
      // // scene.add( new GridHelper( 1000, 10, 0x888888, 0x444444 ) );
      // const geometry = new BoxGeometry( 1, 1, 1 );
      // const material = new MeshLambertMaterial( { color: '#ddffaa', transparent: true } );

      // let orbit = new OrbitControls( camera, renderer.domElement );
      // orbit.update();
      // orbit.addEventListener( 'change', render );

      // control = new TransformControls( camera, renderer.domElement );
      // control.showZ = false;
      // control.size = 0.5;
      // control.addEventListener( 'change', render );

      // control.addEventListener( 'dragging-changed', function ( event ) {

      //   orbit.enabled = ! event.value;
      //   controls.enabled = ! event.value;
      //   // controls

      // } );
      postData();
      // control.attach( Objobject );
      // scene.add( control );
      window.addEventListener("keydown", onKeyDown);
      window.addEventListener("keyup", onKeyUp);
      let objDraggable = Objobject;
      if (objDraggable.name == "B") {
        // console.log("emptying rrr ", emptying);
        if (objDraggable.userData.hasSink == true) {
          // console.log('emptying 33  ',objDraggable.userData.hasSink);
          var flag = true;
          for (let index = 0; index < emptying.length; index++) {
            if (emptying[index].uuid == objDraggable.uuid) {
              flag = false;
              break;
            }
          }

          if (flag) emptying.push(objDraggable);
        }

        (uuidsLeft = []), (uuidsRight = []);
        // let finishTopId = objDraggable.userData.finish_uuids;
        // let Id = objDraggable.uuid;
        // console.log("Hena event.object.userData.finish_uuids " ,event.object.userData.finish_uuids);
        // console.log("Hena finishTops " ,finishTops);
        await finishTop(objDraggable);
        // console.log("Scene   ", scene);

        // Remove finish top
        for await (let obj of scene.children) {
          for (let m = 0; m < objDraggable.userData.finish_uuids.length; m++) {
            if (obj.uuid == objDraggable.userData.finish_uuids[m]) {
              obj.visible = false;
              obj.children = [];
              scene.remove(obj);
              objDraggable.userData.finish_uuids.splice(m--, 1);
              // break;
            }
          }
        }
        // for (let f = 0; f < finishTops.length; f++) {
        //   console.log("Here drag");
        //   if (
        //     finishTops[f].parent == null
        //   ) {
        //     finishTops.splice(f, 1);
        //     console.log("Here splice ");
        //     f--;
        //   }

        // }

        //   for (let j = 0; j < scene.children.length; j++) {
        //     for (let m = 0; m < event.object.userData.finish_uuids.length; m++) {
        //     if (scene.children[j].uuid == event.object.userData.finish_uuids[m]) {
        //       event.object.userData.finish_uuids.splice(m,1);
        //       m--;
        //       scene.remove(scene.children[j]);
        //       j--;
        //     }
        //     // }
        //   }
        // }
        let widthTop = 0;

        let remain = 0;
        //        await loaderr.load("/obj/newObjects/finish_top.glb", function (gltf) {
        await loaderr.load(
          "https://storage.googleapis.com/kitchendata/accessories/finish_top.glb",
          function (gltf) {
            // console.log("1");
            let object = gltf.scene.children[0];
            console.log("gltf.scene ", gltf.scene);
            console.log("object ", object);
            widthTop = objDraggable.userData.W;

            if (uuidsLeft.length == 0) {
              object.position.x = objDraggable.position.x;
              object.position.z = objDraggable.position.z;
            } else {
              object.position.x = uuidsLeft[uuidsLeft.length - 1].position.x;
              object.position.z = uuidsLeft[uuidsLeft.length - 1].position.z;
            }

            if (uuidsRight.length > 0) {
              widthTop = uuidsRight[uuidsRight.length - 1].userData.W;
            }

            if (objDraggable.rotation.y == degrees_to_radians(0)) {
              /**
               * widthTop is the distance with the filler
               */

              let objCheck = null;
              if (uuidsLeft.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsLeft[uuidsLeft.length - 1];
              }

              if (objCheck.position.x + 0.2 > measuresXG.max - wallWidth) {
                widthTop = measuresXG.max - wallWidth - objCheck.position.x;
                let remain = 0;
                if (uuidsRight.length > 0)
                  remain = uuidsRight[uuidsRight.length - 1].userData.W;
                else remain = objDraggable.userData.W;

                widthTop += remain;
                object.position.x = measuresXG.max - wallWidth;
              }

              if (uuidsRight.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsRight[uuidsRight.length - 1];
              }

              if (
                objCheck.position.x - objCheck.userData.W - 0.2 <
                measuresXG.min + wallWidth
              ) {
                widthTop = -measuresXG.min - wallWidth + objCheck.position.x;
              }

              /**
               * Check 4 cases about the object
               */
              if (uuidsLeft.length == 0) {
                if (uuidsRight.length == 0) {
                  object.scale.x =
                    object.position.x - (object.position.x - widthTop);
                } else {
                  if (
                    Math.abs(
                      uuidsRight[uuidsRight.length - 1].position.x -
                        uuidsRight[uuidsRight.length - 1].userData.W -
                        measuresXG.min -
                        wallWidth
                    ) <= 0.2
                  ) {
                    remain =
                      -measuresXG.min -
                      wallWidth +
                      (uuidsRight[uuidsRight.length - 1].position.x -
                        uuidsRight[uuidsRight.length - 1].userData.W);
                  }

                  object.scale.x =
                    object.position.x -
                    (uuidsRight[uuidsRight.length - 1].position.x -
                      uuidsRight[uuidsRight.length - 1].userData.W) +
                    remain;
                }
              } else {
                if (uuidsRight.length == 0) {
                  object.scale.x =
                    uuidsLeft[uuidsLeft.length - 1].position.x -
                    objDraggable.position.x +
                    widthTop;

                  // console.log(
                  //   "uuidsLeft[uuidsLeft.length - 1].position.x ",
                  //   uuidsLeft[uuidsLeft.length - 1].position.x
                  // );
                  // console.log(
                  //   "objDraggable.position.x   ",
                  //   objDraggable.position.x
                  // );
                  // console.log("widthTop  ", widthTop);
                  // console.log(
                  //   "objDraggable.userData.W  ",
                  //   objDraggable.userData.W
                  // );
                  // console.log("object.scale.x   ", object.scale.x);
                } else {
                  // console.log(
                  //   "uuidsLeft[uuidsLeft.length - 1].position.x    ",
                  //   uuidsLeft[uuidsLeft.length - 1].position.x
                  // );
                  // console.log(
                  //   "uuidsRight[uuidsRight.length - 1].position.x   ",
                  //   uuidsRight[uuidsRight.length - 1].position.x
                  // );
                  // console.log("widthTop    ", widthTop);
                  object.scale.x =
                    uuidsLeft[uuidsLeft.length - 1].position.x -
                    (uuidsRight[uuidsRight.length - 1].position.x - widthTop);
                }
              }

              object.scale.z = objDraggable.userData.L;
              object.rotation.y = objDraggable.rotation.y;
              // console.log("DDD   "  , object.scale.x);
            } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
              let objCheck = null;
              if (uuidsLeft.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsLeft[uuidsLeft.length - 1];
              }

              if (objCheck.position.x - 0.2 < measuresXG.min + wallWidth) {
                widthTop = objCheck.position.x - measuresXG.min - wallWidth;
                let remain = 0;
                if (uuidsRight.length > 0)
                  remain = uuidsRight[uuidsRight.length - 1].userData.W;
                else remain = objDraggable.userData.W;

                widthTop += remain;

                object.position.x = measuresXG.min + wallWidth;
              }

              if (uuidsRight.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsRight[uuidsRight.length - 1];
              }

              if (
                objCheck.position.x + objCheck.userData.W + 0.2 >
                measuresXG.max - wallWidth
              ) {
                widthTop = measuresXG.max - wallWidth - objCheck.position.x;
              }

              if (uuidsLeft.length == 0) {
                if (uuidsRight.length == 0) {
                  object.scale.x =
                    object.position.x - (object.position.x + widthTop);
                } else {
                  if (
                    measuresXG.max -
                      wallWidth -
                      (uuidsRight[uuidsRight.length - 1].position.x +
                        uuidsRight[uuidsRight.length - 1].userData.W) <=
                    0.2
                  ) {
                    remain =
                      measuresXG.max -
                      wallWidth -
                      (uuidsRight[uuidsRight.length - 1].position.x +
                        uuidsRight[uuidsRight.length - 1].userData.W);
                  }
                  object.scale.x =
                    object.position.x -
                    (uuidsRight[uuidsRight.length - 1].position.x +
                      uuidsRight[uuidsRight.length - 1].userData.W) -
                    remain;
                  // remain;
                }
              } else {
                if (uuidsRight.length == 0) {
                  object.scale.x =
                    uuidsLeft[uuidsLeft.length - 1].position.x -
                    (objDraggable.position.x + widthTop);
                } else {
                  object.scale.x =
                    uuidsLeft[uuidsLeft.length - 1].position.x -
                    uuidsRight[uuidsRight.length - 1].position.x -
                    widthTop;
                }
              }
              object.position.z = object.position.z - objDraggable.userData.L;
              object.scale.z = objDraggable.userData.L;
            } else if (objDraggable.rotation.y == degrees_to_radians(90)) {
              let objCheck = null;
              if (uuidsLeft.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsLeft[uuidsLeft.length - 1];
              }

              if (objCheck.position.z - 0.2 < measuresZG.min + wallWidth) {
                widthTop = objCheck.position.z - measuresZG.min - wallWidth;
                let remain = 0;

                if (uuidsRight.length > 0)
                  remain = uuidsRight[uuidsRight.length - 1].userData.W;
                else remain = objDraggable.userData.W;

                widthTop += remain;

                object.position.z = measuresZG.min + wallWidth;
              }

              if (uuidsRight.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsRight[uuidsRight.length - 1];
              }

              if (
                objCheck.position.z + objCheck.userData.W + 0.2 >
                measuresZG.max - wallWidth
              ) {
                widthTop = measuresZG.max - wallWidth - objCheck.position.z;
              }

              if (uuidsLeft.length == 0) {
                if (uuidsRight.length == 0) {
                  object.scale.z =
                    object.position.z - (object.position.z + widthTop);
                } else {
                  if (
                    measuresZG.max -
                      wallWidth -
                      (uuidsRight[uuidsRight.length - 1].position.z +
                        uuidsRight[uuidsRight.length - 1].userData.W) <=
                    0.2
                  ) {
                    remain =
                      measuresZG.max -
                      wallWidth -
                      (uuidsRight[uuidsRight.length - 1].position.z +
                        uuidsRight[uuidsRight.length - 1].userData.W);
                  }
                  object.scale.z =
                    object.position.z -
                    (uuidsRight[uuidsRight.length - 1].position.z +
                      uuidsRight[uuidsRight.length - 1].userData.W) -
                    remain;
                }
              } else {
                if (uuidsRight.length == 0) {
                  object.scale.z =
                    uuidsLeft[uuidsLeft.length - 1].position.z -
                    (objDraggable.position.z + widthTop);
                } else {
                  object.scale.z =
                    uuidsLeft[uuidsLeft.length - 1].position.z -
                    (uuidsRight[uuidsRight.length - 1].position.z + widthTop);
                }
              }

              object.rotation.y =
                objDraggable.rotation.y + degrees_to_radians(90);
              object.scale.x = objDraggable.userData.L;
            }
            // -90 degree
            else {
              let objCheck = null;
              if (uuidsLeft.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsLeft[uuidsLeft.length - 1];
              }
              if (objCheck.position.z + 0.2 > measuresZG.max - wallWidth) {
                widthTop = measuresZG.max - wallWidth - objCheck.position.z;
                let remain = 0;

                if (uuidsRight.length > 0)
                  remain = uuidsRight[uuidsRight.length - 1].userData.W;
                else remain = objDraggable.userData.W;

                widthTop += remain;

                object.position.z = measuresZG.max - wallWidth;
              }

              if (uuidsRight.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsRight[uuidsRight.length - 1];
              }

              if (
                objCheck.position.z - objCheck.userData.W - 0.2 <
                measuresZG.min + wallWidth
              ) {
                widthTop = objCheck.position.z + measuresZG.max - wallWidth;
                // object.position.z = measures.length/2;
              }

              if (uuidsLeft.length == 0) {
                if (uuidsRight.length == 0) {
                  object.scale.z =
                    object.position.z - (object.position.z + widthTop);
                  object.scale.x = objDraggable.userData.L;
                  object.rotation.y =
                    objDraggable.rotation.y + degrees_to_radians(90);
                } else {
                  if (
                    uuidsRight[uuidsRight.length - 1].position.z -
                      uuidsRight[uuidsRight.length - 1].userData.W -
                      measuresZG.min -
                      wallWidth <=
                    0.2
                  ) {
                    remain =
                      uuidsRight[uuidsRight.length - 1].position.z -
                      uuidsRight[uuidsRight.length - 1].userData.W -
                      measuresZG.min -
                      wallWidth;
                  }
                  object.scale.x =
                    object.position.z -
                    (uuidsRight[uuidsRight.length - 1].position.z -
                      uuidsRight[uuidsRight.length - 1].userData.W) +
                    remain;
                  // remain;
                  object.scale.z = objDraggable.userData.L;
                  object.rotation.y = objDraggable.rotation.y;
                }
              } else {
                if (uuidsRight.length == 0) {
                  object.scale.x =
                    uuidsLeft[uuidsLeft.length - 1].position.z -
                    (objDraggable.position.z - widthTop);
                  object.scale.z = objDraggable.userData.L;
                  object.rotation.y = objDraggable.rotation.y;
                } else {
                  object.scale.x =
                    uuidsLeft[uuidsLeft.length - 1].position.z -
                    (uuidsRight[uuidsRight.length - 1].position.z - widthTop);

                  object.scale.z = objDraggable.userData.L;
                  object.rotation.y = objDraggable.rotation.y;
                }
              }
            }

            object.position.y =
              objDraggable.position.y + objDraggable.userData.H + 0.1;

            textureWorktops = textureLoader.load(
              "./colors/" + worktopsColor + ".png"
            );
            objDraggable.userData.worktops = worktopsColor;
            textureWorktops.wrapS = textureWorktops.wrapT = RepeatWrapping;

            textureWorktops.offset.set(0.02, 0.02);
            textureWorktops.repeat.set(0.02, 0.02);

            object.material.clone();
            object.material.metalness = -0.1;
            object.material.map = textureWorktops;

            // object.material.map.repeat.set(8, 8);

            // object.material.map.repeat.set(
            //   ((object.scale.x / 2) * 2) / 0.05,
            //   ((object.scale.z / 2) * 2) / 0.05
            // );
            object.castShadow = true;
            object.receiveShadow = true;

            // if (is2D) object.visible = false;

            object.name = "TOP";
            object.scale.x = object.scale.x / 2;
            object.scale.z = object.scale.z / 2;
            if (emptying.length > 0) {
              // console.log("object  ss", object);
              // console.log("emptying[0] ", emptying[0]);
              let meshB = new Mesh(
                new BoxGeometry(
                  emptying[0].userData.sinkWidth - 0.03,
                  0.55,
                  0.036
                ),
                new MeshStandardMaterial({
                  color: new Color("#FF5512"),
                })
              );
              //  console.log("position  ",meshB.position);
              let x = 0;
              let z = 0;
              if (objDraggable.rotation.y == degrees_to_radians(0)) {
                x = emptying[0].position.x - emptying[0].userData.W / 2;
                z = emptying[0].position.z + 0.55 / 2;
                meshB.rotation.z = degrees_to_radians(90);
                meshB.rotation.x = degrees_to_radians(90);
              } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
                x = emptying[0].position.x + emptying[0].userData.W / 2;
                z = emptying[0].position.z - 0.55 / 2;
                meshB.rotation.x = degrees_to_radians(-90);
                meshB.rotation.z = degrees_to_radians(-90);
              } else if (objDraggable.rotation.y == degrees_to_radians(90)) {
                z = emptying[0].position.z + emptying[0].userData.W / 2;
                x = emptying[0].position.x + 0.55 / 2;
                meshB.rotation.z = degrees_to_radians(-90);
                meshB.rotation.x = degrees_to_radians(90);
              } else if (objDraggable.rotation.y == degrees_to_radians(-90)) {
                z = emptying[0].position.z - emptying[0].userData.W / 2;
                x = emptying[0].position.x - 0.55 / 2;
                meshB.rotation.z = degrees_to_radians(90);
                meshB.rotation.x = degrees_to_radians(-90);
              }
              meshB.position.add(new Vector3(x, object.position.y + 0.018, z));

              meshB.updateMatrix();
              object.updateMatrix();

              let bspA = CSG.default.fromMesh(object);
              let bspB = CSG.default.fromMesh(meshB);
              let bspResult = "";

              if (objDraggable.rotation.y == degrees_to_radians(0))
                bspResult = bspA.subtract(bspB);
              else bspResult = bspA.union(bspB);

              if (
                objDraggable.rotation.y == degrees_to_radians(-90) &&
                emptying.length > 1
              )
                bspResult = bspA.subtract(bspB);

              for (let b = 1; b < emptying.length; b++) {
                let meshB = new Mesh(
                  new BoxGeometry(
                    emptying[b].userData.sinkWidth - 0.03,
                    0.55,
                    0.036
                  ),
                  new MeshStandardMaterial({
                    color: new Color("#FF5512"),
                  })
                );
                // scene.add(meshB);

                if (objDraggable.rotation.y == degrees_to_radians(0)) {
                  x = emptying[b].position.x - emptying[b].userData.W / 2;
                  z = emptying[b].position.z + 0.55 / 2;
                  meshB.rotation.z = degrees_to_radians(90);
                  meshB.rotation.x = degrees_to_radians(90);
                } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
                  x = emptying[b].position.x + emptying[b].userData.W / 2;
                  z = emptying[b].position.z - 0.55 / 2;
                  meshB.rotation.x = degrees_to_radians(-90);
                } else if (objDraggable.rotation.y == degrees_to_radians(90)) {
                  z = emptying[b].position.z + emptying[b].userData.W / 2;
                  x = emptying[b].position.x + 0.55 / 2;
                  meshB.rotation.x = degrees_to_radians(90);
                } else if (objDraggable.rotation.y == degrees_to_radians(-90)) {
                  z = emptying[b].position.z - emptying[b].userData.W / 2;
                  x = emptying[b].position.x - 0.55 / 2;
                  meshB.rotation.z = degrees_to_radians(90);
                  meshB.rotation.x = degrees_to_radians(-90);
                }

                meshB.position.add(
                  new Vector3(x, object.position.y + 0.018, z)
                );

                meshB.updateMatrix();
                let bspB = CSG.default.fromMesh(meshB);

                if (
                  objDraggable.rotation.y == degrees_to_radians(0) ||
                  objDraggable.rotation.y == degrees_to_radians(-90)
                )
                  bspResult = bspResult.subtract(bspB);
                else bspResult = bspResult.union(bspB);
              }
              // object.userData.uuid = object.uuid;
              object.material.clone();
              object.material.metalness = -0.1;
              object.material.map = textureWorktops;

              // object.material.map.repeat.set(8, 8);

              object.castShadow = true;
              object.receiveShadow = true;
              object = CSG.default.toMesh(
                bspResult,
                object.matrix,
                object.material
              );
              console.log("ddcobject ", object);
            }

            object.userData.uuid = object.uuid;

            object.name = "Top";
            objDraggable.userData.finish_uuids = [];
            objDraggable.userData.finish_uuids.push(object.uuid);

            for (let index = 0; index < uuidsLeft.length; index++) {
              for (let j = 0; j < scene.children.length; j++) {
                for (
                  let m = 0;
                  m < objDraggable.userData.finish_uuids.length;
                  m++
                ) {
                  if (
                    scene.children[j].uuid ==
                    uuidsLeft[index].userData.finish_uuids[m]
                  ) {
                    uuidsLeft[index].userData.finish_uuids.splice(m--, 1);
                    scene.children[j].children = [];
                    scene.remove(scene.children[j--]);
                  }
                  // }
                }
              }
              uuidsLeft[index].userData.finish_uuids = [];
              uuidsLeft[index].userData.finish_uuids.push(object.uuid);
            }
            for (let index = 0; index < uuidsRight.length; index++) {
              for (let j = 0; j < scene.children.length; j++) {
                for (
                  let m = 0;
                  m < objDraggable.userData.finish_uuids.length;
                  m++
                ) {
                  if (
                    scene.children[j].uuid ==
                    uuidsRight[index].userData.finish_uuids
                  ) {
                    uuidsRight[index].userData.finish_uuids.splice(m--, 1);
                    scene.children[j].children = [];
                    scene.remove(scene.children[j--]);
                  }
                }
              }
              uuidsRight[index].userData.finish_uuids = [];
              uuidsRight[index].userData.finish_uuids.push(object.uuid);
            }

            object.scale.x = object.scale.x;
            object.userData.rotationY = objDraggable.rotation.y;

            if (is2D) object.visible = false;
            // console.log("object.scale.x   ", object.scale.x);
            // console.log("object.scale.y   ", object.scale.y);
            // console.log("object.scale.z   ", object.scale.z);
            finishTops.push(object);
            // console.log("finishTops finish top again  ", finishTops);

            scene.add(object);
          }
        );
        setTimeout(async () => {
          if (objectSideSave != null) {
            // console.log("Call finish top again");
            // if(objectSideType =='Left')
            // objectSideSave.userData.objBesideRight = null;
            // else
            // objectSideSave.userData.objBesideLeft = null;

            await drawFinishTop(objectSideSave);
            // console.log("emptying rrr ", emptying);
            objectSideSave = null;
          }
        }, 500);
        postData();
      }
    }
  );
};

async function dragstart(event) {
  console.log("dragstart now");
  isUpdatedBeside = false;
  //  document.getElementById("update_dimensions").style.display = "none";
  //  document.getElementById("update_attributes").style.display = "none";

  // console.log("OBJ ", event.object);
  /**
   * Delete the finish top of the determined object.
   */
  // console.log('finishTops  ',finishTops);
  // console.log('event.object.userData.finish_uuids  ',event.object.userData.finish_uuids);
  // for (let index = 0; index < finishTops.length; index++) {
  //   for (let m = 0; m < event.object.userData.finish_uuids.length; m++) {
  //     if (finishTops[index].uuid == event.object.userData.finish_uuids[m]) {
  //       // console.log("ok splice");
  //       finishTops.splice(index, 1);
  //       index--;
  //       // break;
  //     }
  //   }
  // }

  // for await (let obj of scene.children) {
  //   for (let m = 0; m < event.object.userData.finish_uuids.length; m++) {
  //     if (obj.uuid == event.object.userData.finish_uuids[m]) {
  //       event.object.userData.finish_uuids.splice(m--, 1);
  //       scene.remove(obj);
  //       // break;
  //     }
  //   }
  // }

  // event.object.userData.finish_uuids = [];

  // uuids = [];

  // // stop camera
  // controls.enabled = false;

  // let objDraggable = event.object;

  // // Remove filler of the draggable object.
  // for (let index = 0; index < scene.children.length; index++) {
  //   if (
  //     scene.children[index].uuid == objDraggable.userData.rightFillerId ||
  //     scene.children[index].uuid == objDraggable.userData.leftFillerId
  //   ) {
  //     for (let f = 0; f < fillers.length; f++) {
  //       if (fillers[f].uuid == scene.children[index].uuid) {
  //         fillers.splice(f, 1);
  //         break;
  //       }
  //     }
  //     scene.remove(scene.children[index]);
  //     index--;
  //   }
  // }

  // if (objDraggable.userData.objBesideLeft != null) {
  //   for await (let obj of scene.children) {
  //     if (
  //       obj.uuid === objDraggable.userData.objBesideLeft.userData.rightFillerId
  //     ) {
  //       for await (let objInner of scene.children) {
  //         if (objDraggable.userData.objBesideLeft.uuid == objInner.uuid) {
  //           objInner.userData.rightFillerId = null;

  //           break;
  //         }
  //       }
  //       scene.remove(obj);
  //     }
  //   }
  // }
  // if (objDraggable.userData.objBesideRight != null) {
  //   for await (let obj of scene.children) {
  //     if (
  //       obj.uuid === objDraggable.userData.objBesideRight.userData.leftFillerId
  //     ) {
  //       for await (let objInner of scene.children) {
  //         if (objDraggable.userData.objBesideRight.uuid == objInner.uuid) {
  //           objInner.userData.leftFillerId = null;

  //           break;
  //         }
  //       }
  //       scene.remove(obj);
  //     }
  //   }
  // }

  // objDraggable.userData.rightFillerId = null;
  // objDraggable.userData.leftFillerId = null;
  // scene.add(objDraggable);
}
var dragged = false;
let shutterMaterial, skirtingMaterial, backMaterial, wallMaterial, wallScale;

async function dragend(event) {
  console.log("dragend now");
  if (dragged) {
    dragged = false;
    let objDraggable = event.object;

    if (!is2D) {
      controls.enabled = true;
    }

    // var changed = false;
    // var counter = 0;
    // console.log("Drag End ");
    // do {
    //   changed = false;
    //   counter = counter + 1;
    //   if (counter > 10) break;

    // console.log("OOObjects ",objects);

    // Intersect check
    let i = 0;
    for (let g = 0; g < objects.length; g++) {
      if (objects[g].uuid === objDraggable.uuid) {
        i = g;
        break;
      }
    }
    objectsAltered = [];

    // for ( i ; i < objects.length; i++) {

    for (let j = 0; j < objects.length; j++) {
      if (i != j && objects[i].position.y === objects[j].position.y) {
        /// Z
        // 90 degree
        if (objects[j].rotation.y == degrees_to_radians(90)) {
          if (
            Math.abs(objects[i].position.x - objects[j].position.x) <
              Math.max(objects[i].userData.L, objects[j].userData.L) &&
            objects[i].rotation.y == degrees_to_radians(90)
          ) {
            if (
              objects[i].position.z <
                objects[j].position.z + objects[j].userData.W &&
              objects[i].position.z >= objects[j].position.z
            ) {
              if (
                objects[j].position.z +
                  objects[j].userData.W +
                  objects[i].userData.W >
                measuresZG.max - wallWidth
              )
                if (
                  objects[j].position.z - objects[i].userData.W <
                  measuresZG.min + wallWidth
                )
                  objects[i].position.x =
                    objects[j].position.x + objects[j].userData.L;
                else
                  objects[i].position.z =
                    objects[j].position.z - objects[i].userData.W;
              else
                objects[i].position.z =
                  objects[j].position.z + objects[j].userData.W;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);

              // if (is2D) {
              //   to2D();
              //   to2D();
              // }
              if (objects[i].userData.hasLeftCover) {
                // console.log("objects[i].userData.hasLeftCover ");
                for (let index = 0; index < leftCovers.length; index++) {
                  if (
                    leftCovers[index].uuid == objects[i].userData.uuidLeftCover
                  ) {
                    leftCovers[index].visible = false;
                    // objects[i].userData.visibleLeftCover = false;
                    scene.add(leftCovers[index]);
                    // objects[i].userData.hasLeftCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              if (objects[j].userData.hasRightCover) {
                // console.log("objects[i].userData.hasRightCover ");

                for (let index = 0; index < rightCovers.length; index++) {
                  if (
                    rightCovers[index].uuid ==
                    objects[j].userData.uuidRightCover
                  ) {
                    rightCovers[index].visible = false;
                    // objects[j].userData.visibleRightCover = false;

                    scene.add(rightCovers[index]);
                    // objects[i].userData.hasRightCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              objects[j].userData.Beside = objects[i];
              objects[i].userData.Beside = objects[j];
              objects[i].userData.typeBeside = "right";
            } else if (
              objects[i].position.z + objects[i].userData.W >
                objects[j].position.z &&
              objects[i].position.z <= objects[j].position.z
            ) {
              if (
                objects[j].position.z - objects[i].userData.W <
                measuresZG.min + wallWidth
              )
                if (
                  objects[j].position.z + objects[j].userData.W >
                  measuresZG.max - wallWidth
                )
                  objects[i].position.x =
                    objects[j].position.x + objects[j].userData.L;
                else
                  objects[i].position.z =
                    objects[j].position.z + objects[j].userData.W;
              else
                objects[i].position.z =
                  objects[j].position.z - objects[i].userData.W;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);
              // if (is2D) {
              //   to2D();
              //   to2D();
              // }

              if (objects[j].userData.hasLeftCover) {
                // console.log("objects[i].userData.hasLeftCover ");
                for (let index = 0; index < leftCovers.length; index++) {
                  if (
                    leftCovers[index].uuid == objects[j].userData.uuidLeftCover
                  ) {
                    leftCovers[index].visible = false;
                    // objects[j].userData.visibleLeftCover = false;
                    scene.add(leftCovers[index]);
                    // objects[i].userData.hasLeftCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              if (objects[i].userData.hasRightCover) {
                // console.log("objects[i].userData.hasRightCover ");

                for (let index = 0; index < rightCovers.length; index++) {
                  if (
                    rightCovers[index].uuid ==
                    objects[i].userData.uuidRightCover
                  ) {
                    rightCovers[index].visible = false;
                    // objects[i].userData.visibleRightCover = false;
                    scene.add(rightCovers[index]);
                    // objects[i].userData.hasRightCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              objects[i].userData.Beside = objects[j];
              objects[j].userData.Beside = objects[i];
              objects[i].userData.typeBeside = "left";
            }
          }
          if (
            objects[i].position.x - objects[j].position.x <
              objects[i].userData.L + objects[j].userData.L &&
            objects[i].rotation.y == degrees_to_radians(-90) &&
            objects[i].position.x > objects[j].position.x
          ) {
            if (
              objects[i].position.z <
                objects[j].position.z + objects[j].userData.W &&
              objects[i].position.z >= objects[j].position.z
            ) {
              if (
                objects[j].position.z - objects[i].userData.W <
                measuresZG.min + wallWidth
              )
                if (
                  objects[j].position.z +
                    objects[i].userData.W +
                    objects[j].userData.W >
                  measuresZG.max - wallWidth
                )
                  objects[i].position.x = objects[j].position.x;
                else
                  objects[i].position.z =
                    objects[j].position.z +
                    objects[i].userData.W +
                    objects[j].userData.W;
              else objects[i].position.z = objects[j].position.z;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);

              // if (is2D) {
              //   to2D();
              //   to2D();
              // }
              if (objects[i].userData.hasLeftCover) {
                // console.log("objects[i].userData.hasLeftCover ");
                for (let index = 0; index < leftCovers.length; index++) {
                  if (
                    leftCovers[index].uuid == objects[i].userData.uuidLeftCover
                  ) {
                    leftCovers[index].visible = false;
                    // objects[i].userData.visibleLeftCover = false;
                    scene.add(leftCovers[index]);
                    // objects[i].userData.hasLeftCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              if (objects[j].userData.hasRightCover) {
                // console.log("objects[i].userData.hasRightCover ");

                for (let index = 0; index < rightCovers.length; index++) {
                  if (
                    rightCovers[index].uuid ==
                    objects[j].userData.uuidRightCover
                  ) {
                    rightCovers[index].visible = false;
                    // objects[j].userData.visibleRightCover = false;

                    scene.add(rightCovers[index]);
                    // objects[i].userData.hasRightCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              objects[j].userData.Beside = objects[i];
              objects[i].userData.Beside = objects[j];
              objects[i].userData.typeBeside = "right";
            } else if (
              objects[i].position.z - objects[i].userData.W <
                objects[j].position.z + objects[j].userData.W &&
              objects[i].position.z >=
                objects[j].position.z + objects[j].userData.W
            ) {
              if (
                objects[j].position.z +
                  objects[i].userData.W +
                  objects[j].userData.W >
                measuresZG.max - wallWidth
              )
                if (
                  objects[j].position.z - objects[i].userData.W <
                  measuresZG.min + wallWidth
                )
                  objects[i].position.x = objects[j].position.x;
                // objects[j].position.x + objects[j].userData.L + objects[i].userData.L;
                else objects[i].position.z = objects[j].position.z;
              else
                objects[i].position.z =
                  objects[j].position.z +
                  objects[i].userData.W +
                  objects[j].userData.W;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);
              // if (is2D) {
              //   to2D();
              //   to2D();
              // }

              if (objects[j].userData.hasLeftCover) {
                // console.log("objects[i].userData.hasLeftCover ");
                for (let index = 0; index < leftCovers.length; index++) {
                  if (
                    leftCovers[index].uuid == objects[j].userData.uuidLeftCover
                  ) {
                    leftCovers[index].visible = false;
                    // objects[j].userData.visibleLeftCover = false;
                    scene.add(leftCovers[index]);
                    // objects[i].userData.hasLeftCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              if (objects[i].userData.hasRightCover) {
                // console.log("objects[i].userData.hasRightCover ");

                for (let index = 0; index < rightCovers.length; index++) {
                  if (
                    rightCovers[index].uuid ==
                    objects[i].userData.uuidRightCover
                  ) {
                    rightCovers[index].visible = false;
                    // objects[i].userData.visibleRightCover = false;
                    scene.add(rightCovers[index]);
                    // objects[i].userData.hasRightCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              objects[i].userData.Beside = objects[j];
              objects[j].userData.Beside = objects[i];
              objects[i].userData.typeBeside = "left";
            }
          }

          if (
            objects[i].position.z <
              objects[j].userData.W + objects[j].position.z &&
            objects[i].position.z + objects[i].userData.L >
              objects[j].position.z &&
            objects[i].rotation.y == degrees_to_radians(0) &&
            objects[i].position.x > objects[j].position.x
          ) {
            if (
              objects[i].position.x <
                objects[j].position.x + objects[j].userData.L &&
              objects[i].position.x >= objects[j].position.x
            ) {
              if (
                objects[j].position.x - objects[j].userData.W <
                measuresXG.min + wallWidth
              )
                objects[i].position.x =
                  objects[j].position.x +
                  objects[i].userData.L +
                  objects[i].userData.W;
              else objects[i].position.x = objects[j].position.x;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);

              // if (is2D) {
              //   to2D();
              //   to2D();
              // }
              // if (objects[i].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[i].userData.visibleLeftCover = false;
              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[j].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[j].userData.visibleRightCover = false;

              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.Beside = objects[j];
              // objects[i].userData.typeBeside = "right";
            } else if (
              objects[i].position.x - objects[i].userData.W <
                objects[j].position.x + objects[j].userData.L &&
              objects[i].position.x >=
                objects[j].position.x + objects[j].userData.L
            ) {
              if (
                objects[j].position.x +
                  objects[j].userData.L +
                  objects[i].userData.W >
                measuresXG.max - wallWidth
              )
                objects[i].position.x = objects[j].position.x;
              else
                objects[i].position.x =
                  objects[j].position.x +
                  objects[j].userData.L +
                  objects[i].userData.W;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);
              // if (is2D) {
              //   to2D();
              //   to2D();
              // }

              // if (objects[j].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[j].userData.visibleLeftCover = false;
              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[i].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[i].userData.visibleRightCover = false;
              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // objects[i].userData.Beside = objects[j];
              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.typeBeside = "left";
            }
          }

          if (
            objects[i].position.z > objects[j].position.z &&
            objects[i].position.z - objects[i].userData.L <
              objects[j].position.z + objects[j].userData.W &&
            objects[i].rotation.y == degrees_to_radians(180)
          ) {
            if (
              objects[i].position.x + objects[i].userData.W <
                objects[j].position.x + objects[j].userData.L &&
              objects[i].position.z >= objects[j].position.z &&
              objects[i].position.x + objects[i].userData.W >
                objects[j].position.x
            ) {
              if (
                objects[j].position.x - objects[i].userData.W <
                measuresXG.min + wallWidth
              )
                objects[i].position.x =
                  objects[j].position.x + objects[j].userData.L;
              else
                objects[i].position.x =
                  objects[j].position.x - objects[i].userData.W;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);

              // if (is2D) {
              //   to2D();
              //   to2D();
              // }
              // if (objects[i].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[i].userData.visibleLeftCover = false;
              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[j].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[j].userData.visibleRightCover = false;

              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.Beside = objects[j];
              // objects[i].userData.typeBeside = "right";
            } else if (
              objects[i].position.x + objects[i].userData.W >
                objects[j].position.x + objects[j].userData.L &&
              objects[i].position.x <=
                objects[j].position.x + objects[j].userData.L
            ) {
              if (
                objects[j].position.x +
                  objects[j].userData.L +
                  objects[i].userData.W >
                measuresXG.max - wallWidth
              )
                objects[i].position.x =
                  objects[j].position.x - objects[i].userData.W;
              else
                objects[i].position.x =
                  objects[j].position.x + objects[j].userData.L;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);
              // if (is2D) {
              //   to2D();
              //   to2D();
              // }

              // if (objects[j].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[j].userData.visibleLeftCover = false;
              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[i].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[i].userData.visibleRightCover = false;
              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // objects[i].userData.Beside = objects[j];
              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.typeBeside = "left";
            }
          }
        }

        // -90 degree
        if (objects[j].rotation.y == degrees_to_radians(-90)) {
          if (
            Math.abs(objects[i].position.x - objects[j].position.x) <
              Math.max(objects[i].userData.L, objects[j].userData.L) &&
            objects[i].rotation.y == degrees_to_radians(-90)
          ) {
            if (
              objects[i].position.z <
                objects[j].position.z + objects[i].userData.W &&
              objects[i].position.z >= objects[j].position.z
            ) {
              if (
                objects[j].position.z + objects[i].userData.W >
                measuresZG.max - wallWidth
              )
                if (
                  objects[j].position.z -
                    objects[j].userData.W -
                    objects[i].userData.W <
                  measuresZG.min + wallWidth
                )
                  objects[i].position.x =
                    objects[j].position.x - objects[j].userData.L;
                else
                  objects[i].position.z =
                    objects[j].position.z - objects[j].userData.W;
              else
                objects[i].position.z =
                  objects[j].position.z + objects[i].userData.W;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);
              // if (is2D) {
              //   to2D();
              //   to2D();
              // }

              if (objects[j].userData.hasLeftCover) {
                // console.log("objects[i].userData.hasLeftCover ");
                for (let index = 0; index < leftCovers.length; index++) {
                  if (
                    leftCovers[index].uuid == objects[j].userData.uuidLeftCover
                  ) {
                    leftCovers[index].visible = false;
                    // objects[j].userData.visibleLeftCover = false;

                    scene.add(leftCovers[index]);
                    // objects[i].userData.hasLeftCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              if (objects[i].userData.hasRightCover) {
                // console.log("objects[i].userData.hasRightCover ");

                for (let index = 0; index < rightCovers.length; index++) {
                  if (
                    rightCovers[index].uuid ==
                    objects[i].userData.uuidRightCover
                  ) {
                    rightCovers[index].visible = false;
                    // objects[i].userData.visibleRightCover = false;

                    scene.add(rightCovers[index]);
                    // objects[i].userData.hasRightCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              objects[i].userData.Beside = objects[j];
              objects[j].userData.Beside = objects[i];
              objects[i].userData.typeBeside = "left";
            } else if (
              objects[i].position.z + objects[j].userData.W >
                objects[j].position.z &&
              objects[i].position.z <= objects[j].position.z
            ) {
              if (
                objects[j].position.z -
                  objects[j].userData.W -
                  objects[i].userData.W <
                measuresZG.min + wallWidth
              )
                if (
                  objects[j].position.z + objects[i].userData.W >
                  measuresZG.max - wallWidth
                )
                  objects[i].position.x =
                    objects[j].position.x - objects[j].userData.L;
                else
                  objects[i].position.z =
                    objects[j].position.z + objects[i].userData.W;
              else
                objects[i].position.z =
                  objects[j].position.z - objects[j].userData.W;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);
              // if (is2D) {
              //   to2D();
              //   to2D();
              // }
              if (objects[i].userData.hasLeftCover) {
                // console.log("objects[i].userData.hasLeftCover ");
                for (let index = 0; index < leftCovers.length; index++) {
                  if (
                    leftCovers[index].uuid == objects[i].userData.uuidLeftCover
                  ) {
                    leftCovers[index].visible = false;
                    // objects[i].userData.visibleLeftCover = false;

                    scene.add(leftCovers[index]);
                    // objects[i].userData.hasLeftCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              if (objects[j].userData.hasRightCover) {
                // console.log("objects[i].userData.hasRightCover ");

                for (let index = 0; index < rightCovers.length; index++) {
                  if (
                    rightCovers[index].uuid ==
                    objects[j].userData.uuidRightCover
                  ) {
                    rightCovers[index].visible = false;
                    // objects[j].userData.visibleRightCover = false;

                    scene.add(rightCovers[index]);
                    // objects[i].userData.hasRightCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              objects[j].userData.Beside = objects[i];
              objects[i].userData.Beside = objects[j];
              objects[i].userData.typeBeside = "right";
            }
          } else if (
            objects[j].position.x - objects[i].position.x <
              objects[i].userData.L + objects[j].userData.L &&
            objects[i].rotation.y == degrees_to_radians(90) &&
            objects[j].position.x >= objects[i].position.x
          ) {
            if (
              objects[i].position.z >
                objects[j].position.z - objects[j].userData.W &&
              objects[i].position.z <= objects[j].position.z
            ) {
              if (
                objects[j].position.z + objects[j].userData.W >
                measuresZG.max - wallWidth
              )
                if (
                  objects[j].position.z -
                    objects[j].userData.W -
                    objects[i].userData.W <
                  measuresZG.min + wallWidth
                )
                  objects[i].position.x = objects[j].position.x;
                else
                  objects[i].position.z =
                    objects[j].position.z -
                    objects[j].userData.W -
                    objects[i].userData.W;
              else objects[i].position.z = objects[j].position.z;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);
              // if (is2D) {
              //   to2D();
              //   to2D();
              // }

              // if (objects[j].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[j].userData.visibleLeftCover = false;

              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[i].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[i].userData.visibleRightCover = false;

              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // objects[i].userData.Beside = objects[j];
              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.typeBeside = "left";
            } else if (
              objects[i].position.z + objects[i].userData.W >
                objects[j].position.z - objects[j].userData.W &&
              objects[i].position.z <= objects[j].position.z
            ) {
              if (
                objects[j].position.z -
                  objects[j].userData.W -
                  objects[i].userData.W <
                measuresZG.min + wallWidth
              )
                if (
                  objects[j].position.z + objects[i].userData.W >
                  measuresZG.max - wallWidth
                )
                  objects[i].position.x =
                    objects[j].position.x - objects[j].userData.L;
                else
                  objects[i].position.z =
                    objects[j].position.z + objects[i].userData.W;
              else
                objects[i].position.z =
                  objects[j].position.z -
                  objects[j].userData.W -
                  objects[i].userData.W;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);
              // if (is2D) {
              //   to2D();
              //   to2D();
              // }
              // if (objects[i].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[i].userData.visibleLeftCover = false;

              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[j].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[j].userData.visibleRightCover = false;

              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.Beside = objects[j];
              // objects[i].userData.typeBeside = "right";
            }
          } else if (
            objects[i].position.z + objects[i].userData.L >=
              objects[j].position.z - objects[j].userData.W &&
            objects[i].rotation.y == degrees_to_radians(0) &&
            objects[j].position.z >= objects[i].position.z
          ) {
            if (
              objects[i].position.x <= objects[j].position.x &&
              objects[i].position.x >=
                objects[j].position.x - objects[j].userData.L
            ) {
              if (
                objects[j].position.x - objects[j].userData.L <
                measuresXG.min + wallWidth
              )
                objects[i].position.x =
                  objects[j].position.x + objects[i].userData.W;
              else
                objects[i].position.x =
                  objects[j].position.x - objects[j].userData.L;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);
              // if (is2D) {
              //   to2D();
              //   to2D();
              // }

              // if (objects[j].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[j].userData.visibleLeftCover = false;

              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[i].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[i].userData.visibleRightCover = false;

              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // objects[i].userData.Beside = objects[j];
              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.typeBeside = "left";
            } else if (
              objects[i].position.x - objects[i].userData.W <
                objects[j].position.x &&
              objects[i].position.x >= objects[j].position.x
            ) {
              if (
                objects[j].position.x + objects[i].userData.W >
                measuresXG.max - wallWidth
              )
                objects[i].position.x =
                  objects[j].position.x - objects[j].userData.L;
              else
                objects[i].position.x =
                  objects[j].position.x + objects[i].userData.W;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);
              // if (is2D) {
              //   to2D();
              //   to2D();
              // }
              // if (objects[i].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[i].userData.visibleLeftCover = false;

              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[j].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[j].userData.visibleRightCover = false;

              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.Beside = objects[j];
              // objects[i].userData.typeBeside = "right";
            }
          } else if (
            objects[i].position.z - objects[i].userData.L <=
              objects[j].position.z &&
            objects[i].position.z >
              objects[j].position.z - objects[j].userData.W &&
            objects[i].rotation.y == degrees_to_radians(180)
            // && objects[j].position.z  <= objects[i].position.z
          ) {
            if (
              objects[i].position.x <= objects[j].position.x &&
              objects[i].position.x >=
                objects[j].position.x - objects[j].userData.L
            ) {
              if (
                objects[j].position.x + objects[i].userData.W <
                measuresXG.min + wallWidth
              )
                objects[i].position.x =
                  objects[j].position.x -
                  objects[j].userData.L -
                  objects[i].userData.W;
              else objects[i].position.x = objects[j].position.x;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);
              // if (is2D) {
              //   to2D();
              //   to2D();
              // }

              // if (objects[j].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[j].userData.visibleLeftCover = false;

              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[i].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[i].userData.visibleRightCover = false;

              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // objects[i].userData.Beside = objects[j];
              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.typeBeside = "left";
            } else if (
              objects[i].position.x + objects[i].userData.W >
                objects[j].position.x - objects[j].userData.L &&
              objects[i].position.x <= objects[j].position.x
            ) {
              if (
                objects[j].position.x -
                  objects[j].userData.L -
                  objects[i].userData.W <
                measuresXG.min + wallWidth
              )
                objects[i].position.x = objects[j].position.x;
              else
                objects[i].position.x =
                  objects[j].position.x -
                  objects[j].userData.L -
                  objects[i].userData.W;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);
              // if (is2D) {
              //   to2D();
              //   to2D();
              // }
              // if (objects[i].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[i].userData.visibleLeftCover = false;

              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[j].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[j].userData.visibleRightCover = false;

              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.Beside = objects[j];
              // objects[i].userData.typeBeside = "right";
            }
          }
        }

        ///  X
        // 180 degree
        if (objects[j].rotation.y == degrees_to_radians(180)) {
          if (
            Math.abs(objects[i].position.z - objects[j].position.z) <
              Math.max(objects[i].userData.L, objects[j].userData.L) &&
            objects[i].rotation.y == degrees_to_radians(180)
          ) {
            if (
              objects[i].position.x <
                objects[j].position.x + objects[j].userData.W &&
              objects[i].position.x >= objects[j].position.x
            ) {
              if (
                objects[j].position.x +
                  objects[j].userData.W +
                  objects[i].userData.W >
                measuresXG.max - wallWidth
              )
                if (
                  objects[j].position.x - objects[i].userData.W <
                  measuresXG.min + wallWidth
                ) {
                  objects[i].position.z =
                    objects[j].position.z - objects[j].userData.L;
                  // objects[i].position.x = objects[j].position.x ;
                } else
                  objects[i].position.x =
                    objects[j].position.x - objects[i].userData.W;
              else
                objects[i].position.x =
                  objects[j].position.x + objects[j].userData.W;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);
              // if (is2D) {
              //   to2D();
              //   to2D();
              // }
              if (objects[i].userData.hasLeftCover) {
                // console.log("objects[i].userData.hasLeftCover ");
                for (let index = 0; index < leftCovers.length; index++) {
                  if (
                    leftCovers[index].uuid == objects[i].userData.uuidLeftCover
                  ) {
                    leftCovers[index].visible = false;
                    // objects[i].userData.visibleLeftCover = false;

                    scene.add(leftCovers[index]);
                    // objects[i].userData.hasLeftCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              if (objects[j].userData.hasRightCover) {
                // console.log("objects[i].userData.hasRightCover ");

                for (let index = 0; index < rightCovers.length; index++) {
                  if (
                    rightCovers[index].uuid ==
                    objects[j].userData.uuidRightCover
                  ) {
                    rightCovers[index].visible = false;
                    // objects[j].userData.visibleRightCover = false;

                    scene.add(rightCovers[index]);
                    // objects[i].userData.hasRightCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              objects[j].userData.Beside = objects[i];
              objects[i].userData.Beside = objects[j];
              objects[i].userData.typeBeside = "right";
            } else if (
              objects[i].position.x + objects[i].userData.W >
                objects[j].position.x &&
              objects[i].position.x <= objects[j].position.x
            ) {
              if (
                objects[j].position.x - objects[i].userData.W <
                measuresXG.min + wallWidth
              )
                if (
                  objects[j].position.x +
                    objects[j].userData.W +
                    objects[i].userData.W >
                  measuresXG.max - wallWidth
                ) {
                  objects[i].position.z =
                    objects[j].position.z - objects[j].userData.L;
                } else
                  objects[i].position.x =
                    objects[j].position.x + objects[j].userData.W;
              else
                objects[i].position.x =
                  objects[j].position.x - objects[i].userData.W;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);

              if (objects[j].userData.hasLeftCover) {
                // console.log("objects[i].userData.hasLeftCover ");
                for (let index = 0; index < leftCovers.length; index++) {
                  if (
                    leftCovers[index].uuid == objects[j].userData.uuidLeftCover
                  ) {
                    leftCovers[index].visible = false;
                    // objects[j].userData.visibleLeftCover = false;

                    scene.add(leftCovers[index]);
                    // objects[i].userData.hasLeftCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              if (objects[i].userData.hasRightCover) {
                // console.log("objects[i].userData.hasRightCover ");

                for (let index = 0; index < rightCovers.length; index++) {
                  if (
                    rightCovers[index].uuid ==
                    objects[i].userData.uuidRightCover
                  ) {
                    rightCovers[index].visible = false;
                    // objects[i].userData.visibleRightCover = false;

                    scene.add(rightCovers[index]);
                    // objects[i].userData.hasRightCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              objects[j].userData.Beside = objects[i];
              objects[i].userData.Beside = objects[j];
              objects[i].userData.typeBeside = "left";
            }
          } else if (
            Math.abs(objects[i].position.z - objects[j].position.z) <
              objects[i].userData.L + objects[j].userData.L &&
            objects[i].position.z < objects[j].position.z &&
            objects[i].rotation.y == degrees_to_radians(0)
          ) {
            if (
              objects[i].position.x <
                objects[j].position.x +
                  objects[i].userData.W +
                  objects[j].userData.W &&
              objects[i].position.x >=
                objects[j].position.x + objects[j].userData.W
            ) {
              if (
                objects[j].position.x +
                  objects[i].userData.W +
                  objects[j].userData.W >
                measuresXG.max - wallWidth
              )
                if (
                  objects[j].position.x - objects[i].userData.W <
                  measuresXG.min + wallWidth
                ) {
                  objects[i].position.z =
                    objects[j].position.z -
                    objects[j].userData.L -
                    objects[i].userData.L;
                  // objects[i].position.x = objects[j].position.x ;
                } else objects[i].position.x = objects[j].position.x;
              else
                objects[i].position.x =
                  objects[j].position.x +
                  objects[i].userData.W +
                  objects[j].userData.W;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);
              // if (is2D) {
              //   to2D();
              //   to2D();
              // }
              if (objects[i].userData.hasLeftCover) {
                // console.log("objects[i].userData.hasLeftCover ");
                for (let index = 0; index < leftCovers.length; index++) {
                  if (
                    leftCovers[index].uuid == objects[i].userData.uuidLeftCover
                  ) {
                    leftCovers[index].visible = false;
                    // objects[i].userData.visibleLeftCover = false;

                    scene.add(leftCovers[index]);
                    // objects[i].userData.hasLeftCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              if (objects[j].userData.hasRightCover) {
                // console.log("objects[i].userData.hasRightCover ");

                for (let index = 0; index < rightCovers.length; index++) {
                  if (
                    rightCovers[index].uuid ==
                    objects[j].userData.uuidRightCover
                  ) {
                    rightCovers[index].visible = false;
                    // objects[j].userData.visibleRightCover = false;

                    scene.add(rightCovers[index]);
                    // objects[i].userData.hasRightCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              objects[j].userData.Beside = objects[i];
              objects[i].userData.Beside = objects[j];
              objects[i].userData.typeBeside = "right";
            } else if (
              objects[i].position.x - objects[i].userData.W <
                objects[j].position.x &&
              objects[j].position.x <= objects[i].position.x
            ) {
              if (
                objects[j].position.x - objects[i].userData.W <
                measuresXG.min + wallWidth
              )
                if (
                  objects[j].position.x +
                    objects[j].userData.W +
                    objects[i].userData.W >
                  measuresXG.max - wallWidth
                ) {
                  objects[i].position.z =
                    objects[j].position.z -
                    objects[j].userData.L -
                    objects[i].userData.L;
                } else
                  objects[i].position.x =
                    objects[j].position.x +
                    objects[j].userData.W +
                    objects[i].userData.W;
              else objects[i].position.x = objects[j].position.x;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);

              if (objects[j].userData.hasLeftCover) {
                // console.log("objects[i].userData.hasLeftCover ");
                for (let index = 0; index < leftCovers.length; index++) {
                  if (
                    leftCovers[index].uuid == objects[j].userData.uuidLeftCover
                  ) {
                    leftCovers[index].visible = false;
                    // objects[j].userData.visibleLeftCover = false;

                    scene.add(leftCovers[index]);
                    // objects[i].userData.hasLeftCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              if (objects[i].userData.hasRightCover) {
                // console.log("objects[i].userData.hasRightCover ");

                for (let index = 0; index < rightCovers.length; index++) {
                  if (
                    rightCovers[index].uuid ==
                    objects[i].userData.uuidRightCover
                  ) {
                    rightCovers[index].visible = false;
                    // objects[i].userData.visibleRightCover = false;

                    scene.add(rightCovers[index]);
                    // objects[i].userData.hasRightCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              objects[j].userData.Beside = objects[i];
              objects[i].userData.Beside = objects[j];
              objects[i].userData.typeBeside = "left";
            }
          } else if (
            objects[i].position.x <
              objects[j].position.x + objects[j].userData.W &&
            objects[i].rotation.y == degrees_to_radians(90) &&
            objects[i].position.x + objects[i].userData.L >
              objects[j].position.x
          ) {
            if (
              objects[j].position.z <
                objects[i].position.z + objects[j].userData.L &&
              objects[i].position.z <= objects[j].position.z
            ) {
              if (
                objects[j].position.z - objects[i].userData.W >
                measuresZG.max - wallWidth
              )
                objects[i].position.z =
                  objects[j].position.z -
                  objects[j].userData.L -
                  objects[i].userData.W;
              else objects[i].position.z = objects[j].position.z;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);

              // if (objects[i].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[i].userData.visibleLeftCover = false;

              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[j].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[j].userData.visibleRightCover = false;

              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.Beside = objects[j];
              // objects[i].userData.typeBeside = "right";
            } else if (
              objects[i].position.z + objects[i].userData.W >
                objects[j].position.z - objects[j].userData.L &&
              objects[j].position.z - objects[j].userData.L >
                objects[i].position.z
            ) {
              if (
                objects[j].position.z -
                  objects[j].userData.L -
                  objects[i].userData.W <
                measuresZG.min + wallWidth
              )
                objects[i].position.z = objects[j].position.z;
              else
                objects[i].position.z =
                  objects[j].position.z -
                  objects[j].userData.L -
                  objects[i].userData.W;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);

              // if (objects[j].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[j].userData.visibleLeftCover = false;

              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[i].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[i].userData.visibleRightCover = false;

              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.Beside = objects[j];
              // objects[i].userData.typeBeside = "left";
            }
          } else if (
            objects[i].position.x <
              objects[j].position.x +
                objects[j].userData.W +
                objects[i].userData.L &&
            objects[i].rotation.y == degrees_to_radians(-90) &&
            objects[i].position.x > objects[j].position.x
          ) {
            if (
              objects[j].position.z <
                objects[i].position.z + objects[j].userData.L &&
              objects[i].position.z <= objects[j].position.z
            ) {
              if (
                objects[j].position.z - objects[j].userData.L <
                measuresZG.min + wallWidth
              )
                objects[i].position.z =
                  objects[j].position.z + objects[i].userData.W;
              else
                objects[i].position.z =
                  objects[j].position.z - objects[j].userData.L;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);

              // if (objects[i].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[i].userData.visibleLeftCover = false;

              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[j].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[j].userData.visibleRightCover = false;

              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.Beside = objects[j];
              // objects[i].userData.typeBeside = "right";
            } else if (
              objects[i].position.z - objects[i].userData.W <
                objects[j].position.z &&
              objects[j].position.z < objects[i].position.z
            ) {
              if (
                objects[j].position.z + objects[i].userData.W >
                measuresZG.max - wallWidth
              )
                objects[i].position.z =
                  objects[j].position.z + objects[j].userData.L;
              else
                objects[i].position.z =
                  objects[j].position.z + objects[i].userData.W;

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);

              // if (objects[j].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[j].userData.visibleLeftCover = false;

              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[i].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[i].userData.visibleRightCover = false;

              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.Beside = objects[j];
              // objects[i].userData.typeBeside = "left";
            }
          }
        }
        // 0 degree
        if (objects[j].rotation.y == degrees_to_radians(0)) {
          if (
            Math.abs(objects[i].position.z - objects[j].position.z) <
              Math.max(objects[i].userData.L, objects[j].userData.L) &&
            objects[i].rotation.y == degrees_to_radians(0)
          ) {
            if (
              objects[i].position.x <
                objects[j].position.x + objects[i].userData.W &&
              objects[i].position.x >= objects[j].position.x
            ) {
              if (
                objects[j].position.x + objects[i].userData.W >
                measuresXG.max - wallWidth
              ) {
                if (
                  objects[j].position.x - objects[j].userData.W <
                  measuresXG.min + wallWidth
                )
                  objects[i].position.z =
                    objects[j].position.z + objects[j].userData.L;
                else
                  objects[i].position.x =
                    objects[j].position.x - objects[j].userData.W;
              } else {
                objects[i].position.x =
                  objects[j].position.x + objects[i].userData.W;
              }

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);

              if (objects[j].userData.hasLeftCover) {
                // console.log("objects[i].userData.hasLeftCover ");
                for (let index = 0; index < leftCovers.length; index++) {
                  if (
                    leftCovers[index].uuid == objects[j].userData.uuidLeftCover
                  ) {
                    leftCovers[index].visible = false;
                    // objects[j].userData.visibleLeftCover = false;

                    scene.add(leftCovers[index]);
                    // objects[i].userData.hasLeftCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              if (objects[i].userData.hasRightCover) {
                // console.log("objects[i].userData.hasRightCover ");

                for (let index = 0; index < rightCovers.length; index++) {
                  if (
                    rightCovers[index].uuid ==
                    objects[i].userData.uuidRightCover
                  ) {
                    rightCovers[index].visible = false;
                    // objects[i].userData.visibleRightCover = false;

                    scene.add(rightCovers[index]);
                    // objects[i].userData.hasRightCover = false
                    // scene.add(objects[i]);
                  }
                }
              }

              objects[j].userData.Beside = objects[i];
              objects[i].userData.Beside = objects[j];
              objects[i].userData.typeBeside = "left";
            } else if (
              objects[i].position.x + objects[j].userData.W >
                objects[j].position.x &&
              objects[i].position.x <= objects[j].position.x
            ) {
              if (
                objects[j].position.x -
                  objects[j].userData.W -
                  objects[i].userData.W <
                measuresXG.min + wallWidth
              ) {
                if (
                  objects[j].position.x + objects[i].userData.W >
                  measuresXG.max - wallWidth
                )
                  objects[i].position.z =
                    objects[j].position.z + objects[j].userData.L;
                else
                  objects[i].position.x =
                    objects[j].position.x + objects[i].userData.W;
              } else {
                objects[i].position.x =
                  objects[j].position.x - objects[j].userData.W;
              }

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);

              if (objects[i].userData.hasLeftCover) {
                // console.log("objects[i].userData.hasLeftCover ");
                for (let index = 0; index < leftCovers.length; index++) {
                  if (
                    leftCovers[index].uuid == objects[i].userData.uuidLeftCover
                  ) {
                    leftCovers[index].visible = false;
                    // objects[i].userData.visibleLeftCover = false;

                    scene.add(leftCovers[index]);
                    // objects[i].userData.hasLeftCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              if (objects[j].userData.hasRightCover) {
                // console.log("objects[i].userData.hasRightCover ");

                for (let index = 0; index < rightCovers.length; index++) {
                  if (
                    rightCovers[index].uuid ==
                    objects[j].userData.uuidRightCover
                  ) {
                    rightCovers[index].visible = false;
                    // objects[j].userData.visibleRightCover = false;

                    scene.add(rightCovers[index]);
                    // objects[i].userData.hasRightCover = false
                    // scene.add(objects[i]);
                  }
                }
              }
              // console.log("OKKKAAAYY  ");
              objects[j].userData.Beside = objects[i];
              objects[i].userData.Beside = objects[j];
              objects[i].userData.typeBeside = "right";
            }
          } else if (
            objects[i].rotation.y == degrees_to_radians(180) &&
            Math.abs(objects[i].position.z - objects[j].position.z) <
              objects[j].userData.L + objects[i].userData.L &&
            objects[i].position.z > objects[j].position.z
          ) {
            if (
              objects[j].position.x <
                objects[i].position.x + objects[i].userData.W &&
              objects[j].position.x >= objects[i].position.x
            ) {
              if (
                objects[j].position.x + objects[i].userData.W >
                measuresXG.max - wallWidth
              ) {
                if (
                  objects[j].position.x -
                    objects[j].userData.W -
                    objects[i].userData.W <
                  measuresXG.min + wallWidth
                ) {
                  objects[i].position.z = objects[j].position.z;
                  objects[i].position.x -= objects[i].userData.W;
                } else
                  objects[i].position.x =
                    objects[j].position.x -
                    objects[j].userData.W -
                    objects[i].userData.W;
              } else {
                objects[i].position.x = objects[j].position.x;
              }

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);

              // if (objects[j].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[j].userData.visibleLeftCover = false;

              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[i].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[i].userData.visibleRightCover = false;

              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }

              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.Beside = objects[j];
              // objects[i].userData.typeBeside = "left";
            } else if (
              objects[i].position.x + objects[i].userData.W >
                objects[j].position.x - objects[j].userData.W &&
              objects[i].position.x <= objects[j].position.x
            ) {
              if (
                objects[j].position.x -
                  objects[j].userData.W -
                  objects[i].userData.W <
                measuresXG.min + wallWidth
              ) {
                if (objects[j].position.x >= measuresXG.max - wallWidth) {
                  objects[i].position.z = objects[j].position.z;
                  objects[i].position.x -= objects[i].userData.W;
                } else objects[i].position.x = objects[j].position.x;
              } else {
                objects[i].position.x =
                  objects[j].position.x -
                  objects[j].userData.W -
                  objects[i].userData.W;
              }

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);

              // if (objects[i].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[i].userData.visibleLeftCover = false;

              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[j].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[j].userData.visibleRightCover = false;

              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // // console.log("OKKKAAAYY  ");
              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.Beside = objects[j];
              // objects[i].userData.typeBeside = "right";
            }
          } else if (
            objects[i].rotation.y == degrees_to_radians(90) &&
            objects[i].position.x + objects[i].userData.L >
              objects[j].position.x - objects[j].userData.W &&
            objects[i].position.x < objects[j].position.x
          ) {
            if (
              objects[i].position.z <
                objects[j].position.z + objects[j].userData.L &&
              objects[j].position.z <= objects[i].position.z
            ) {
              if (
                objects[j].position.z +
                  objects[j].userData.L +
                  objects[i].userData.W >
                measuresZG.max - wallWidth
              ) {
                objects[i].position.z =
                  objects[j].position.z - objects[i].userData.W;
              } else {
                objects[i].position.z =
                  objects[j].position.z + objects[j].userData.L;
              }

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);

              // if (objects[j].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[j].userData.visibleLeftCover = false;

              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[i].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[i].userData.visibleRightCover = false;

              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }

              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.Beside = objects[j];
              // objects[i].userData.typeBeside = "left";
            } else if (
              objects[i].position.z + objects[i].userData.W >
                objects[j].position.z &&
              objects[i].position.z <= objects[j].position.z
            ) {
              if (
                objects[j].position.z - objects[i].userData.W <
                measuresZG.min + wallWidth
              ) {
                objects[i].position.z =
                  objects[j].position.z + objects[j].userData.L;
              } else {
                objects[i].position.z =
                  objects[j].position.z - objects[i].userData.W;
              }

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);

              // if (objects[i].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[i].userData.visibleLeftCover = false;

              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[j].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[j].userData.visibleRightCover = false;

              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // // console.log("OKKKAAAYY  ");
              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.Beside = objects[j];
              // objects[i].userData.typeBeside = "right";
            }
          } else if (
            objects[i].rotation.y == degrees_to_radians(-90) &&
            objects[i].position.x - objects[i].userData.L <
              objects[j].position.x &&
            objects[i].position.x >
              objects[j].position.x - objects[j].userData.W
          ) {
            if (
              objects[i].position.z - objects[i].userData.W <
                objects[j].position.z + objects[j].userData.L &&
              objects[j].position.z <=
                objects[i].position.z - objects[i].userData.W
            ) {
              if (
                objects[j].position.z +
                  objects[j].userData.L +
                  objects[i].userData.W >
                measuresZG.max - wallWidth
              ) {
                objects[i].position.z = objects[j].position.z;
              } else {
                objects[i].position.z =
                  objects[j].position.z +
                  objects[j].userData.L +
                  objects[i].userData.W;
              }

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);

              // if (objects[j].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[j].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[j].userData.visibleLeftCover = false;

              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[i].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[i].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[i].userData.visibleRightCover = false;

              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }

              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.Beside = objects[j];
              // objects[i].userData.typeBeside = "left";
            } else if (
              objects[j].position.z + objects[j].userData.L >
                objects[i].position.z &&
              objects[i].position.z >= objects[j].position.z
            ) {
              if (
                objects[j].position.z - objects[i].userData.W <
                measuresZG.min + wallWidth
              ) {
                objects[i].position.z =
                  objects[j].position.z + objects[j].userData.L;
              } else {
                objects[i].position.z = objects[j].position.z;
              }

              if (objects[i].name == "B") objectsAltered.push(objects[i]);

              // if (objects[j].name == "B") objectsAltered.push(objects[j]);

              // if (objects[i].userData.hasLeftCover) {
              //   // console.log("objects[i].userData.hasLeftCover ");
              //   for (let index = 0; index < leftCovers.length; index++) {
              //     if (
              //       leftCovers[index].uuid == objects[i].userData.uuidLeftCover
              //     ) {
              //       leftCovers[index].visible = false;
              //       // objects[i].userData.visibleLeftCover = false;

              //       scene.add(leftCovers[index]);
              //       // objects[i].userData.hasLeftCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // if (objects[j].userData.hasRightCover) {
              //   // console.log("objects[i].userData.hasRightCover ");

              //   for (let index = 0; index < rightCovers.length; index++) {
              //     if (
              //       rightCovers[index].uuid == objects[j].userData.uuidRightCover
              //     ) {
              //       rightCovers[index].visible = false;
              //       // objects[j].userData.visibleRightCover = false;

              //       scene.add(rightCovers[index]);
              //       // objects[i].userData.hasRightCover = false
              //       // scene.add(objects[i]);
              //     }
              //   }
              // }
              // // console.log("OKKKAAAYY  ");
              // objects[j].userData.Beside = objects[i];
              // objects[i].userData.Beside = objects[j];
              // objects[i].userData.typeBeside = "right";
            }
          }
        }

        scene.add(objects[i]);
      }
    }

    // Change coordinates of the Handle Direction
    if (
      !(objects[i].name == "Element" && objects[i].userData.ElType != "opening")
    ) {
      if (objects[i].userData.hasHandleDirection == true) {
        let positionX, positionZ;

        for (let index = 0; index < directions.length; index++) {
          if (directions[index].uuid == objects[i].userData.uuidDirection) {
            if (objects[i].userData.ElType != "opening") {
              if (objects[i].rotation.y == degrees_to_radians(0)) {
                // if(objects[i].userData.Direction == "L"){
                positionX = objects[i].position.x;
                // }else{
                //   positionX = objects[i].position.x -  objects[i].userData.W;
                //   directions[index].rotation.z = degrees_to_radians(-180);
                // }
                positionZ =
                  objects[i].position.z +
                  (objects[i].userData.ElType == "opening"
                    ? 0.1
                    : objects[i].userData.L);
              } else if (objects[i].rotation.y == degrees_to_radians(90)) {
                // if(objects[i].userData.Direction == "L"){
                positionZ = objects[i].position.z;

                // }else{
                //   positionZ = objects[i].position.z +  objects[i].userData.W;
                //   directions[index].rotation.x = degrees_to_radians(0);
                // }
                positionX =
                  objects[i].position.x +
                  (objects[i].userData.ElType == "opening"
                    ? 0.1
                    : objects[i].userData.L);
              } else if (objects[i].rotation.y == degrees_to_radians(180)) {
                // if(objects[i].userData.Direction == "L"){
                positionX = objects[i].position.x;
                // }else{
                //   positionX = objects[i].position.x  + objects[i].userData.W;
                //   directions[index].rotation.z = degrees_to_radians(-180);
                // }

                positionZ =
                  objects[i].position.z -
                  (objects[i].userData.ElType == "opening"
                    ? 0.1
                    : objects[i].userData.L);
              } else if (objects[i].rotation.y == degrees_to_radians(-90)) {
                // if(objects[i].userData.Direction == "L"){
                positionZ = objects[i].position.z;
                // }else{
                //   positionZ = objects[i].position.z - objects[i].userData.W;
                //   directions[index].rotation.x = degrees_to_radians(0);
                // }
                positionX =
                  objects[i].position.x -
                  (objects[i].userData.ElType == "opening"
                    ? 0.1
                    : objects[i].userData.L);
              }

              // directions[index].position.x = positionX;
              // directions[index].position.z = positionZ;
              directions[index].rotation.y = objects[i].rotation.y;
            } else {
              // if (objects[i].rotation.y == degrees_to_radians(0)) {
              //   positionX = objects[i].position.x;
              //   positionZ = objects[i].position.z +  ((objects[i].userData.ElType == 'opening')? 0.1:objects[i].userData.L);
              //   directions[index].rotation.x = degrees_to_radians(-180);
              //   directions[index].rotation.z = degrees_to_radians(0);
              //   directions[index].rotation.y = objects[i].rotation.y;
              // } else if (objects[i].rotation.y == degrees_to_radians(90)) {
              //   positionX = objects[i].position.x +  ((objects[i].userData.ElType == 'opening')? 0.1:objects[i].userData.L);
              //   positionZ = objects[i].position.z;
              //   directions[index].rotation.z = degrees_to_radians(90);
              //   directions[index].rotation.x = degrees_to_radians(-90);
              //   directions[index].rotation.y = degrees_to_radians(-90);
              // } else if (objects[i].rotation.y == degrees_to_radians(180)) {
              //   positionX = objects[i].position.x;
              //   positionZ = objects[i].position.z -  ((objects[i].userData.ElType == 'opening')? 0.1:objects[i].userData.L);
              //   directions[index].rotation.x = degrees_to_radians(-180);
              //   directions[index].rotation.z = degrees_to_radians(0);
              //   directions[index].rotation.y = objects[i].rotation.y;
              // } else if (objects[i].rotation.y == degrees_to_radians(-90)) {
              //   positionX = objects[i].position.x -  ((objects[i].userData.ElType == 'opening')? 0.1:objects[i].userData.L);
              //   positionZ = objects[i].position.z;
              //   directions[index].rotation.z = degrees_to_radians(-90);
              //   directions[index].rotation.x = degrees_to_radians(-90);
              //   directions[index].rotation.y = degrees_to_radians(90);
              // }
              // directions[index].position.x = positionX;
              // directions[index].position.z = positionZ;
            }
            if (objects[i].rotation.y == degrees_to_radians(0)) {
              positionX = objects[i].position.x;
              positionZ =
                objects[i].position.z +
                (objects[i].userData.ElType == "opening"
                  ? 0.1
                  : objects[i].userData.L);
              // console.log(
              //   "objects[i].userData.openingDir ",
              //   objects[i].userData.openingDir
              // );
              if (objects[i].userData.openingDir == "in")
                directions[index].rotation.x = degrees_to_radians(0);
              else directions[index].rotation.x = degrees_to_radians(-180);

              directions[index].rotation.z = degrees_to_radians(0);
              directions[index].rotation.y = objects[i].rotation.y;
            } else if (objects[i].rotation.y == degrees_to_radians(90)) {
              positionX =
                objects[i].position.x +
                (objects[i].userData.ElType == "opening"
                  ? 0.1
                  : objects[i].userData.L);
              positionZ = objects[i].position.z;
              if (objects[i].userData.openingDir == "in")
                directions[index].rotation.y = degrees_to_radians(90);
              else directions[index].rotation.y = degrees_to_radians(-90);

              directions[index].rotation.z = degrees_to_radians(90);
              directions[index].rotation.x = degrees_to_radians(-90);
            } else if (objects[i].rotation.y == degrees_to_radians(180)) {
              positionX = objects[i].position.x;
              positionZ =
                objects[i].position.z -
                (objects[i].userData.ElType == "opening"
                  ? 0.1
                  : objects[i].userData.L);

              if (objects[i].userData.openingDir == "in")
                directions[index].rotation.x = degrees_to_radians(0);
              else directions[index].rotation.x = degrees_to_radians(-180);
              directions[index].rotation.z = degrees_to_radians(0);
              directions[index].rotation.y = objects[i].rotation.y;
            } else if (objects[i].rotation.y == degrees_to_radians(-90)) {
              positionX =
                objects[i].position.x -
                (objects[i].userData.ElType == "opening"
                  ? 0.1
                  : objects[i].userData.L);
              positionZ = objects[i].position.z;
              if (objects[i].userData.openingDir == "in")
                directions[index].rotation.y = degrees_to_radians(-90);
              else directions[index].rotation.y = degrees_to_radians(90);

              directions[index].rotation.z = degrees_to_radians(-90);

              directions[index].rotation.x = degrees_to_radians(-90);
            }
            directions[index].position.x = positionX;
            directions[index].position.z = positionZ;
            // directions[index].rotation.y = objects[i].rotation.y;

            scene.add(directions[index]);
          }
        }
      }
    }
    // change position of parts of objects
    if (objects[i].name != "Element") {
      // Change coordinates of the left Cover
      if (objects[i].userData.hasLeftCover == true) {
        let positionX, positionY, positionZ;
        if (objects[i].rotation.y == degrees_to_radians(0)) {
          positionX = objects[i].position.x + 0.018;
          positionZ = objects[i].position.z;
          positionY = objects[i].position.y + 0.1;
        } else if (objects[i].rotation.y == degrees_to_radians(90)) {
          positionX = objects[i].position.x;
          positionZ = objects[i].position.z - 0.018;
          positionY = objects[i].position.y + 0.1;
        } else if (objects[i].rotation.y == degrees_to_radians(180)) {
          positionX = objects[i].position.x - 0.018;
          positionZ = objects[i].position.z;
          positionY = objects[i].position.y + 0.1;
        } else if (objects[i].rotation.y == degrees_to_radians(-90)) {
          positionX = objects[i].position.x;
          positionZ = objects[i].position.z + 0.018;
          positionY = objects[i].position.y + 0.1;
        }

        for (let index = 0; index < leftCovers.length; index++) {
          if (leftCovers[index].uuid == objects[i].userData.uuidLeftCover) {
            leftCovers[index].position.x = positionX;
            leftCovers[index].position.z = positionZ;
            leftCovers[index].rotation.y = objects[i].rotation.y;
            scene.add(leftCovers[index]);
          }
        }
      }

      //  Change coordinates of the right Cover
      if (objects[i].userData.hasRightCover == true) {
        let positionX, positionY, positionZ;
        if (objects[i].rotation.y == degrees_to_radians(0)) {
          positionX = objects[i].position.x - objects[i].userData.W;
          positionZ = objects[i].position.z;
          positionY = objects[i].position.y + 0.1;
        } else if (objects[i].rotation.y == degrees_to_radians(90)) {
          positionX = objects[i].position.x;
          positionZ = objects[i].position.z + objects[i].userData.W;
          positionY = objects[i].position.y + 0.1;
        } else if (objects[i].rotation.y == degrees_to_radians(180)) {
          positionX = objects[i].position.x + objects[i].userData.W;
          positionZ = objects[i].position.z;

          positionY = objects[i].position.y + 0.1;
        } else if (objects[i].rotation.y == degrees_to_radians(-90)) {
          positionX = objects[i].position.x;
          positionZ = objects[i].position.z - objects[i].userData.W;
          positionY = objects[i].position.y + 0.1;
        }

        for (let index = 0; index < rightCovers.length; index++) {
          if (rightCovers[index].uuid == objects[i].userData.uuidRightCover) {
            rightCovers[index].position.x = positionX;
            rightCovers[index].position.z = positionZ;
            rightCovers[index].rotation.y = objects[i].rotation.y;
            scene.add(rightCovers[index]);
          }
        }
      }
      //  Change coordinates of the Cornice
      if (objects[i].userData.hasCornice == true) {
        let positionX, positionY, positionZ;
        positionX = objects[i].position.x;
        positionZ = objects[i].position.z;

        var lightPosX;
        var lightPosZ;
        if (objects[i].rotation.y == degrees_to_radians(0)) {
          positionZ = objects[i].position.z + objects[i].userData.L - 0.05;
          lightPosX = objects[i].position.x - objects[i].userData.W / 2;
          lightPosZ = objects[i].position.z + objects[i].userData.L - 0.05;
          positionX += 0.018;
        } else if (objects[i].rotation.y == degrees_to_radians(180)) {
          positionZ = objects[i].position.z - objects[i].userData.L + 0.05;
          lightPosX = objects[i].position.x + objects[i].userData.W / 2;
          lightPosZ = objects[i].position.z - objects[i].userData.L + 0.05;
          positionX -= 0.018;
        } else if (objects[i].rotation.y == degrees_to_radians(90)) {
          positionX = objects[i].position.x + objects[i].userData.L - 0.05;
          lightPosZ = objects[i].position.z + objects[i].userData.W / 2;
          lightPosX = objects[i].position.x + objects[i].userData.L - 0.05;
          positionZ -= 0.018;
        } else {
          positionX = objects[i].position.x - objects[i].userData.L + 0.05;
          lightPosZ = objects[i].position.z - objects[i].userData.W / 2;
          lightPosX = objects[i].position.x - objects[i].userData.L + 0.05;
          positionZ += 0.018;
        }

        for (let index = 0; index < Cornices.length; index++) {
          if (Cornices[index].uuid == objects[i].userData.uuidCornice) {
            Cornices[index].position.x = positionX;
            Cornices[index].position.z = positionZ;
            // Cornices[index].position.y = positionY;
            Cornices[index].rotation.y = objects[i].rotation.y;
            // wallPanels[index].scale.x = objects[i].userData.W;

            // wallPanels[index].scale.x = objects[i].userData.W;

            scene.add(Cornices[index]);
          }
        }
        for (let index = 0; index < lightObjects.length; index++) {
          if (
            lightObjects[index].uuid == objects[i].userData.uuidLightCornice
          ) {
            lightObjects[index].position.x = lightPosX;
            lightObjects[index].position.z = lightPosZ;
            lightObjects[index].rotation.y = objects[i].rotation.y;
            scene.add(lightObjects[index]);
          }
        }
      }
      //  Change coordinates of the Deco strip
      if (objects[i].userData.hasDecoStrip == true) {
        let positionX, positionY, positionZ;
        positionX = objects[i].position.x;
        positionZ = objects[i].position.z;

        var lightPosX;
        var lightPosZ;
        var lightRotX = 0;
        var lightRotZ = 0;
        var lightRotY = 0;

        if (objects[i].rotation.y == degrees_to_radians(0)) {
          positionZ = objects[i].position.z + objects[i].userData.L - 0.018;
          lightPosX = objects[i].position.x - objects[i].userData.W / 2;
          lightPosZ = objects[i].position.z + objects[i].userData.L - 0.118;
          lightRotX = degrees_to_radians(-90);
          lightRotZ = degrees_to_radians(0);
          lightRotY = objects[i].rotation.y;
        } else if (objects[i].rotation.y == degrees_to_radians(180)) {
          positionZ = objects[i].position.z - objects[i].userData.L + 0.018;
          lightPosX = objects[i].position.x + objects[i].userData.W / 2;
          lightPosZ = objects[i].position.z - objects[i].userData.L + 0.118;
          lightRotX = degrees_to_radians(90);
          lightRotZ = degrees_to_radians(180);
          lightRotY = objects[i].rotation.y;
        } else if (objects[i].rotation.y == degrees_to_radians(90)) {
          positionX = objects[i].position.x + objects[i].userData.L - 0.018;
          lightPosZ = objects[i].position.z + objects[i].userData.W / 2;
          lightPosX = objects[i].position.x + objects[i].userData.L - 0.118;
          lightRotZ = degrees_to_radians(180);
          lightRotY = objects[i].rotation.y;
        } else {
          positionX = objects[i].position.x - objects[i].userData.L + 0.018;
          lightPosZ = objects[i].position.z - objects[i].userData.W / 2;
          lightPosX = objects[i].position.x - objects[i].userData.L + 0.118;
          lightRotZ = degrees_to_radians(180);
          lightRotY = objects[i].rotation.y;
        }
        // if(objects[i].rotation.y == degrees_to_radians(0))
        // positionZ = objects[i].position.z + objects[i].userData.L - 0.018;
        // else if(objects[i].rotation.y == degrees_to_radians(180))
        // positionZ = objects[i].position.z - objects[i].userData.L + 0.018;
        // else if(objects[i].rotation.y == degrees_to_radians(90))
        // positionX = objects[i].position.x + objects[i].userData.L - 0.018;
        // else
        // positionX = objects[i].position.x - objects[i].userData.L + 0.018;
        positionY = objects[i].position.y - 0.1;

        for (let index = 0; index < decoStrips.length; index++) {
          if (decoStrips[index].uuid == objects[i].userData.uuidDecoStrip) {
            decoStrips[index].position.x = positionX;
            decoStrips[index].position.z = positionZ;
            decoStrips[index].position.y = positionY;
            decoStrips[index].rotation.y = objects[i].rotation.y;
            // wallPanels[index].scale.x = objects[i].userData.W;

            // wallPanels[index].scale.x = objects[i].userData.W;

            scene.add(decoStrips[index]);
          }
        }
        for (let index = 0; index < lightObjects.length; index++) {
          if (lightObjects[index].uuid == objects[i].userData.uuidLight) {
            lightObjects[index].position.x = lightPosX;
            lightObjects[index].position.z = lightPosZ;
            lightObjects[index].position.y = positionY + 0.1;
            if (lightRotX == 0) {
              lightObjects[index].rotation.y = lightRotZ;
              lightObjects[index].rotation.z = degrees_to_radians(-90);
              lightObjects[index].rotation.x = degrees_to_radians(90);
              // console.log("Here1 lights");
            } else {
              lightObjects[index].rotation.x = lightRotX;
              lightObjects[index].rotation.z = lightRotZ;
              lightObjects[index].rotation.y = lightRotY;
              // console.log("Here2 lights");
            }

            // lightObjects[index].rotation.y = objects[i].rotation.y;
            scene.add(lightObjects[index]);
            // console.log("lightObjects[index]  ", lightObjects[index]);
            break;
          }
        }
      }
      //  Change coordinates of the wall panel
      if (objects[i].userData.hasWallPanel == true) {
        let positionX, positionY, positionZ;
        positionX = objects[i].position.x;
        positionZ = objects[i].position.z;
        positionY = objects[i].userData.H + 0.2;

        for (let index = 0; index < wallPanels.length; index++) {
          if (wallPanels[index].uuid == objects[i].userData.uuidWallPanel) {
            wallPanels[index].position.x = positionX;
            wallPanels[index].position.z = positionZ;
            wallPanels[index].position.y = positionY;
            wallPanels[index].rotation.y = objects[i].rotation.y;
            // wallPanels[index].scale.x = objects[i].userData.W;
            wallPanels[index].scale.x = objects[i].userData.W;

            if (
              positionX == measuresXG.max - wallWidth ||
              positionX == measuresXG.min + wallWidth ||
              positionZ == measuresZG.max - wallWidth ||
              positionZ == measuresZG.min + wallWidth
            )
              wallPanels[index].visible = true;
            else wallPanels[index].visible = false;
            scene.add(wallPanels[index]);
          }
        }
      }

      //  Change coordinates of the back Cover
      if (objects[i].userData.hasBackCover == true) {
        let positionX, positionY, positionZ;
        positionX = objects[i].position.x;
        positionZ = objects[i].position.z;
        if (objects[i].rotation.y == degrees_to_radians(0)) {
          positionZ = objects[i].position.z - 0.001;
        } else if (objects[i].rotation.y == degrees_to_radians(90)) {
          positionX = objects[i].position.x - 0.001;
        } else if (objects[i].rotation.y == degrees_to_radians(180)) {
          positionZ = objects[i].position.z + 0.001;
        } else if (objects[i].rotation.y == degrees_to_radians(-90)) {
          positionX = objects[i].position.x + 0.001;
        }
        positionY = objects[i].position.y + 0.1;

        for (let index = 0; index < backCovers.length; index++) {
          if (backCovers[index].uuid == objects[i].userData.uuidBackCover) {
            backCovers[index].position.x = positionX;
            backCovers[index].position.z = positionZ;
            backCovers[index].rotation.y = objects[i].rotation.y;

            if (
              positionX == measuresXG.max - wallWidth + 0.001 ||
              positionX == measuresXG.min + wallWidth - 0.001 ||
              positionZ == measuresZG.max - wallWidth + 0.001 ||
              positionZ == measuresZG.min + wallWidth - 0.001
            ) {
              backCovers[index].visible = false;
            } else {
              if (objects[i].userData.visibleBackCover == true)
                backCovers[index].visible = true;
            }

            // console.log("backCovers  ", backCovers);

            scene.add(backCovers[index]);
          }
        }
      }

      //  Change coordinates of the light of skirting
      if (objects[i].userData.hasLightSkirting == true) {
        var lightPosX;
        var lightPosZ;
        if (objects[i].rotation.y == degrees_to_radians(0)) {
          lightPosX = objects[i].position.x - objects[i].userData.W / 2;
          lightPosZ = objects[i].position.z + objects[i].userData.L - 0.014;
        } else if (objects[i].rotation.y == degrees_to_radians(180)) {
          lightPosX = objects[i].position.x + objects[i].userData.W / 2;
          lightPosZ = objects[i].position.z - objects[i].userData.L + 0.014;
        } else if (objects[i].rotation.y == degrees_to_radians(90)) {
          lightPosZ = objects[i].position.z + objects[i].userData.W / 2;
          lightPosX = objects[i].position.x + objects[i].userData.L - 0.014;
        } else {
          lightPosZ = objects[i].position.z - objects[i].userData.W / 2;
          lightPosX = objects[i].position.x - objects[i].userData.L + 0.014;
        }

        for (let index = 0; index < lightObjects.length; index++) {
          if (
            lightObjects[index].uuid == objects[i].userData.uuidLightSkirting
          ) {
            lightObjects[index].position.x = lightPosX;
            lightObjects[index].position.z = lightPosZ;
            lightObjects[index].rotation.y = objects[i].rotation.y;
            scene.add(lightObjects[index]);
          }
        }
      }
    }
    // }
    // console.log("scene   ", scene);

    // For finish tops and sides

    let RightLine = new Measures();
    let LeftLine = new Measures();

    const loaderr = new GLTFLoader();
    let j;
    (drawR = false),
      (drawL = false),
      (drawF = false),
      (drawB = false),
      (drawT = false),
      (drawBO = false);

    obj = objDraggable;

    let maxRight = 0;
    let maxLeft = 0;

    let objBeside = null;
    let objBesideLeft = null;
    let objBesideRight = null;

    if (objDraggable.rotation.y == degrees_to_radians(0)) {
      // Right Line
      if (
        objDraggable.position.x - objDraggable.userData.W >
        measuresXG.min + wallWidth
      ) {
        maxRight = measuresXG.min + wallWidth;
        RightLine.line1X = maxRight;
        RightLine.line2X = objDraggable.position.x - objDraggable.userData.W;
        RightLine.line1Z =
          objDraggable.position.z + objDraggable.userData.L / 2;
        RightLine.line2Z =
          objDraggable.position.z + objDraggable.userData.L / 2;
        // drawR = true;
      }
      // Left Line
      if (objDraggable.position.x < +measuresXG.max - wallWidth) {
        maxLeft = +measuresXG.max - wallWidth;
        LeftLine.line1X = maxLeft;
        LeftLine.line2X = objDraggable.position.x;
        LeftLine.line1Z = objDraggable.position.z + objDraggable.userData.L / 2;
        LeftLine.line2Z = objDraggable.position.z + objDraggable.userData.L / 2;
        // drawL = true;
      }
    } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
      // Right Line
      if (
        objDraggable.position.x + objDraggable.userData.W <
        measuresXG.max - wallWidth
      ) {
        maxRight = measuresXG.max - wallWidth;
        RightLine.line1X = maxRight;
        RightLine.line2X = objDraggable.position.x + objDraggable.userData.W;
        RightLine.line1Z =
          objDraggable.position.z - objDraggable.userData.L / 2;
        RightLine.line2Z =
          objDraggable.position.z - objDraggable.userData.L / 2;
        // drawR = true;
      }
      // Left Line
      if (objDraggable.position.x > measuresXG.min + wallWidth) {
        maxLeft = measuresXG.min + wallWidth;
        LeftLine.line1X = maxLeft;
        LeftLine.line2X = objDraggable.position.x;
        LeftLine.line1Z = objDraggable.position.z - objDraggable.userData.L / 2;
        LeftLine.line2Z = objDraggable.position.z - objDraggable.userData.L / 2;
        // drawL = true;
      }
    } else if (objDraggable.rotation.y == degrees_to_radians(-90)) {
      // Right Line
      if (
        objDraggable.position.z - objDraggable.userData.W >
        measuresZG.min + wallWidth
      ) {
        maxRight = measuresZG.min + wallWidth;
        RightLine.line1X =
          +objDraggable.position.x - objDraggable.userData.L / 2;
        RightLine.line2X =
          +objDraggable.position.x - objDraggable.userData.L / 2;
        RightLine.line1Z = maxRight;
        RightLine.line2Z = objDraggable.position.z - objDraggable.userData.W;
        // drawR = true;
      }
      // Left Line
      if (objDraggable.position.z < measuresZG.max - wallWidth) {
        maxLeft = measuresZG.max - wallWidth;
        LeftLine.line1X =
          +objDraggable.position.x - objDraggable.userData.L / 2;
        LeftLine.line2X =
          +objDraggable.position.x - objDraggable.userData.L / 2;
        LeftLine.line1Z = maxLeft;
        LeftLine.line2Z = objDraggable.position.z;
        // drawL = true;
      }
    } else {
      // Right Line
      if (
        objDraggable.position.z + objDraggable.userData.W <
        measuresZG.max - wallWidth
      ) {
        maxRight = measuresZG.max - wallWidth;
        RightLine.line1X =
          +objDraggable.position.x + objDraggable.userData.L / 2;
        RightLine.line2X =
          +objDraggable.position.x + objDraggable.userData.L / 2;
        RightLine.line1Z = maxRight;
        RightLine.line2Z = objDraggable.position.z + objDraggable.userData.W;
        // drawR = true;
      }
      // Left Line
      if (objDraggable.position.z > measuresZG.min + wallWidth) {
        maxLeft = measuresZG.min + wallWidth;
        LeftLine.line1X =
          +objDraggable.position.x + objDraggable.userData.L / 2;
        LeftLine.line2X =
          +objDraggable.position.x + objDraggable.userData.L / 2;
        LeftLine.line1Z = maxLeft;
        LeftLine.line2Z = objDraggable.position.z;
        // drawL = true;
      }
    }

    let rightCoordinates = {
      x: 0,
      z: 0,
    };

    let leftCoordinates = {
      x: 0,
      z: 0,
    };

    for await (const object of objects) {
      if (
        objects.length > 1 &&
        object.name == objDraggable.name &&
        object.uuid != objDraggable.uuid
      ) {
        if (
          object.rotation.y == degrees_to_radians(0) &&
          objDraggable.rotation.y == degrees_to_radians(0)
        ) {

          if (
            maxRight < object.position.x &&
            ((object.position.z >= objDraggable.position.z &&
              object.position.z <=
                objDraggable.position.z + objDraggable.userData.L) ||
              (object.position.z + objDraggable.userData.L >=
                objDraggable.position.z &&
                object.position.z + objDraggable.userData.L <=
                  objDraggable.position.z + objDraggable.userData.L)) &&
            object.position.x <=
              objDraggable.position.x - objDraggable.userData.W
          ) {
           
            maxRight = object.position.x;
            RightLine.line1X = object.position.x;
            drawR = true;
            objBeside = object;
            objBesideRight = object;
            // console.log("objBesideRight setted ", objBesideRight);
          }
          if (
            maxLeft > object.position.x &&
            ((object.position.z >= objDraggable.position.z &&
              object.position.z <=
                objDraggable.position.z + objDraggable.userData.L) ||
              (object.position.z + objDraggable.userData.L >=
                objDraggable.position.z &&
                object.position.z + objDraggable.userData.L <=
                  objDraggable.position.z + objDraggable.userData.L)) &&
            object.position.x > objDraggable.position.x
          ) {
            maxLeft = object.position.x - object.userData.W;
            LeftLine.line1X = object.position.x - object.userData.W;
            drawL = true;
            objBeside = object;
            objBesideLeft = object;
          }
        } else if (
          object.rotation.y == degrees_to_radians(90) &&
          objDraggable.rotation.y == degrees_to_radians(90)
        ) {
          if (
            maxRight > object.position.z &&
            ((object.position.x >= objDraggable.position.x &&
              object.position.x <=
                objDraggable.position.x + objDraggable.userData.L) ||
              (object.position.x + objDraggable.userData.L >=
                objDraggable.position.x &&
                object.position.x + objDraggable.userData.L <=
                  objDraggable.position.x + objDraggable.userData.L)) &&
            object.position.z >=
              objDraggable.position.z + objDraggable.userData.W
          ) {
            maxRight = object.position.z;
            RightLine.line1Z = object.position.z;
            drawR = true;
            objBeside = object;
            objBesideRight = object;
            // await drawLines(objDraggable.userData.L/2);
          }

          if (
            maxLeft < object.position.z &&
            ((object.position.x >= objDraggable.position.x &&
              object.position.x <=
                objDraggable.position.x + objDraggable.userData.L) ||
              (object.position.x + objDraggable.userData.L >=
                objDraggable.position.x &&
                object.position.x + objDraggable.userData.L <=
                  objDraggable.position.x + objDraggable.userData.L)) &&
            object.position.z < objDraggable.position.z
          ) {
            maxLeft = object.position.z + object.userData.W;
            LeftLine.line1Z = object.position.z + object.userData.W;
            drawL = true;
            objBeside = object;
            objBesideLeft = object;
          }
        } else if (
          object.rotation.y == degrees_to_radians(180) &&
          objDraggable.rotation.y == degrees_to_radians(180)
        ) {
          if (
            maxRight > object.position.x &&
            ((object.position.z <= objDraggable.position.z &&
              object.position.z >=
                objDraggable.position.z - objDraggable.userData.L) ||
              (object.position.z - objDraggable.userData.L <
                objDraggable.position.z &&
                object.position.z - objDraggable.userData.L >
                  objDraggable.position.z - objDraggable.userData.L)) &&
            object.position.x >=
              objDraggable.position.x + objDraggable.userData.W
          ) {
            maxRight = object.position.x;
            RightLine.line1X = object.position.x;

            drawR = true;
            objBeside = object;
            objBesideRight = object;
            // await drawLines(objDraggable.userData.L/2);
          }

          if (
            maxLeft < object.position.x &&
            ((object.position.z <= objDraggable.position.z &&
              object.position.z >=
                objDraggable.position.z - objDraggable.userData.L) ||
              (object.position.z - objDraggable.userData.L <
                objDraggable.position.z &&
                object.position.z - objDraggable.userData.L >
                  objDraggable.position.z - objDraggable.userData.L)) &&
            object.position.x < objDraggable.position.x
          ) {
            maxLeft = object.position.x + object.userData.W;
            LeftLine.line1X = object.position.x + object.userData.W;
            drawL = true;
            objBeside = object;
            objBesideLeft = object;
          }
        } else if (
          object.rotation.y == degrees_to_radians(-90) &&
          objDraggable.rotation.y == degrees_to_radians(-90)
        ) {
          if (
            maxRight < object.position.z &&
            ((object.position.x <= objDraggable.position.x &&
              object.position.x >=
                objDraggable.position.x - objDraggable.userData.L) ||
              (object.position.x - objDraggable.userData.L <
                objDraggable.position.x &&
                object.position.x - objDraggable.userData.L >
                  objDraggable.position.x - objDraggable.userData.L)) &&
            object.position.z <=
              objDraggable.position.z - objDraggable.userData.W
          ) {
            maxRight = object.position.z;
            RightLine.line1Z = object.position.z;
            drawR = true;
            objBeside = object;
            objBesideRight = object;
          }

          if (
            maxLeft > object.position.z &&
            ((object.position.x <= objDraggable.position.x &&
              object.position.x >=
                objDraggable.position.x - objDraggable.userData.L) ||
              (object.position.x - objDraggable.userData.L <
                objDraggable.position.x &&
                object.position.x - objDraggable.userData.L >
                  objDraggable.position.x - objDraggable.userData.L)) &&
            object.position.z > objDraggable.position.z
          ) {
            maxLeft = object.position.z - object.userData.W;
            LeftLine.line1Z = object.position.z - object.userData.W;
            drawL = true;
            objBeside = object;
            objBesideLeft = object;
          }
        }
      }
    }

    // Set the right position of the filler.
    if (objDraggable.rotation.y == degrees_to_radians(0)) {
      rightCoordinates.x = objDraggable.position.x - objDraggable.userData.W;
      rightCoordinates.z = objDraggable.position.z;
      leftCoordinates.x = maxLeft;
      leftCoordinates.z = objDraggable.position.z;
    } else if (objDraggable.rotation.y == degrees_to_radians(90)) {
      rightCoordinates.x = objDraggable.position.x;
      rightCoordinates.z = objDraggable.position.z + objDraggable.userData.W;
      leftCoordinates.x = objDraggable.position.x;
      leftCoordinates.z = maxLeft;
    } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
      rightCoordinates.x = objDraggable.position.x + objDraggable.userData.W;
      rightCoordinates.z = objDraggable.position.z;
      leftCoordinates.x = maxLeft;
      leftCoordinates.z = objDraggable.position.z;
    } else {
      rightCoordinates.x = objDraggable.position.x;
      rightCoordinates.z = objDraggable.position.z - objDraggable.userData.W;
      leftCoordinates.x = objDraggable.position.x;
      leftCoordinates.z = maxLeft;
    }

    // console.log("maxRight ", RightLine.getValue() * 1000);
    ///// Important
    for (let index = 0; index < objDraggable.children.length; index++) {
      if (objDraggable.children[index].name.match(/Shutter.*/)) {
        for (
          let ch = 0;
          ch < objDraggable.children[index].children.length;
          ch++
        ) {
          // console.log('shutter  ' ,objDraggable.children[index].children[ch].material.name);

          if (
            objDraggable.children[index].children[ch].material.name.match(
              /shutter-out.*/
            )
          ) {
            shutterMaterial =
              objDraggable.children[index].children[ch].material.map;
          }
        }
      }
      if (objDraggable.children[index].name.match(/Skirting.*/)) {
        skirtingMaterial = objDraggable.children[index].material.map;
      }
      if (objDraggable.children[index].name.match(/carcass.*/)) {
        for (
          let ch = 0;
          ch < objDraggable.children[index].children.length;
          ch++
        ) {
          // console.log(
          //   "carcass  ",
          //   objDraggable.children[index].children[ch].material.name
          // );
          if (
            objDraggable.children[index].children[ch].material.name.match(
              /carcass-out.*/
            )
          ) {
            backMaterial =
              objDraggable.children[index].children[ch].material.map;
          }
        }
      }
    }

    if (objDraggable.userData.hasWallPanel) {
      for (let index = 0; index < wallPanels.length; index++) {
        if (wallPanels[index].uuid == objDraggable.userData.uuidWallPanel) {
          // console.log("wallPanels[index].scale.y   " ,wallPanels[index].scale.y);
          wallMaterial = wallPanels[index].children[4].material.map;
          wallScale = wallPanels[index].scale.y;
          // wallPosition = objDraggable.position.y + objDraggable.userData.H;
        }
      }
    }

    // if(objBesideLeft != null ){
    //   // objDraggable.userData.objBesideLeft =  null;
    //   // objDraggable.userData.objBesideLeft.userData.objBesideRight = null ;
    //   objDraggable.userData.objBesideLeft =  objBesideLeft;
    //   objDraggable.userData.objBesideLeft.userData.objBesideRight = objDraggable;
    // }

    // if(objBesideRight != null){
    //   // objDraggable.userData.objBesideRight =  null;
    //   // objDraggable.userData.objBesideRight.userData.objBesideLeft = null;
    //   objDraggable.userData.objBesideRight =  objBesideRight;
    //   objDraggable.userData.objBesideRight.userData.objBesideLeft = objDraggable;
    //         }

    console.log('R ',RightLine.getValue() );
    console.log('R ',RightLine);
    console.log('L ' ,LeftLine.getValue() );
    console.log('L ' ,LeftLine);

    if (
      RightLine.getValue() === undefined ||
      (RightLine.getValue() * 1000 <= 200 &&
      RightLine.getValue() * 1000 > 0 ) &&
      maxRight != 0 &&
      objDraggable.name != "Element"
    ) {
      if(objDraggable.name != "W")
          objDraggable.userData.hasRightObject = true;
       else 
          objDraggable.userData.hasRightWallObject = true;
    } else {
      if(objDraggable.name != "W")
         objDraggable.userData.hasRightObject = false;
      else 
         objDraggable.userData.hasRightWallObject = false;
    }

    if (
      LeftLine.getValue()  === undefined ||
      ( LeftLine.getValue() * 1000 <= 200 &&
      LeftLine.getValue() * 1000 > 0) &&
      maxLeft != 0 &&
      objDraggable.name != "Element" 
    ) {
      if(objDraggable.name != "W")
         objDraggable.userData.hasLeftObject = true;
      else
         objDraggable.userData.hasLeftWallObject = true;

    } else {
      if(objDraggable.name != "W")
         objDraggable.userData.hasLeftObject = false;
      else
         objDraggable.userData.hasLeftWallObject = false;
        }

    if (
      objDraggable.position.x != measuresXG.max - wallWidth &&
      objDraggable.position.x != measuresXG.min + wallWidth &&
      objDraggable.position.z != measuresZG.max - wallWidth &&
      objDraggable.position.z != measuresZG.min + wallWidth &&
      objDraggable.name != "Element" &&
      objDraggable.name != "W"
    ) {
      objDraggable.userData.hasBackObject = true;
    } else {
      objDraggable.userData.hasBackObject = false;
    }

    // Right filler
    if (
      RightLine.getValue() * 1000 <= 200 &&
      RightLine.getValue() * 1000 > 0 &&
      maxRight != 0 &&
      objDraggable.name != "Element"
    ) {
      if (objBesideRight != null) {
        objDraggable.userData.objBesideRight = objBesideRight;
        objDraggable.userData.objBesideRight.userData.objBesideLeft =
          objDraggable;
      }
      var drawFiller = false;
      if (objBesideRight == null) {
        drawFiller = true;
      } else if (
        objBesideRight.rotation.y == degrees_to_radians(0) ||
        objBesideRight.rotation.y == degrees_to_radians(180)
      ) {
        if (
          objBesideRight.position.z == objDraggable.position.z &&
          objBesideRight.position.y == objDraggable.position.y
        ) {
          drawFiller = true;
        }
      } else if (
        objBesideRight.rotation.y == degrees_to_radians(90) ||
        objBesideRight.rotation.y == degrees_to_radians(-90)
      ) {
        if (
          objBesideRight.position.x == objDraggable.position.x &&
          objBesideRight.position.y == objDraggable.position.y
        ) {
          drawFiller = true;
        }
      }
      // if(objDraggable.position.y == objBesideRight.position.y && objBesideRight != null){
      if (drawFiller == true) {
        let filler = objDraggable.name != "B" ? "wall_filler" : "filler";
        //      loaderr.load("/obj/newObjects/" + filler + ".glb", function (gltf) {
        loaderr.load(
          "https://storage.googleapis.com/kitchendata/accessories/" +
            filler +
            ".glb",
          function (gltf) {
            let object = gltf.scene;

            object.position.x = rightCoordinates.x;
            object.position.z = rightCoordinates.z;
            object.name = "filler";

            object.position.y = objDraggable.position.y;
            object.scale.x = RightLine.getValue();
            object.rotation.y = objDraggable.rotation.y;
            objDraggable.userData.rightFillerId = object.uuid;
            // console.log("Right filler ", object);
            for (let t = 0; t < object.children.length; t++) {
              if (object.children[t].type == "Mesh") {
                object.children[t].userData.uuid = object.uuid;
                object.children[t].material.metalness = 0;
                // shutterMaterial.offset.set(0.02, 0.02);
                // shutterMaterial.repeat.set(0, 1);
                // skirtingMaterial.metalness = -1;
                if (t == 2) object.children[t].material.map = shutterMaterial;
                else if (t == 4) object.children[t].material.map = backMaterial;
                else if (t == 3) {
                  object.children[t].material.metalness = -1;
                  object.children[t].material.map = skirtingMaterial;
                } else if (t == 1) {
                  if (wallMaterial) {
                    object.children[t].clone();
                    let color = "MC4";
                    for (let k = 0; k < wallPanels.length; k++) {
                      if (
                        wallPanels[k].uuid ==
                        objDraggable.userData.uuidWallPanel
                      ) {
                        color = wallPanels[k].userData.color;
                      }
                      // 1;
                    }

                    let texture = textureLoader.load(
                      "./colors/" + color + ".png"
                    );
                    // texture.offset.set(0.05, 0.002);
                    // texture.repeat.set(0.02, 0.002);
                    texture.magFilter = NearestFilter;
                    texture.mapping = UVMapping;
                    texture.wrapS = RepeatWrapping;
                    texture.wrapT = RepeatWrapping;
                    texture.side = DoubleSide;
                    texture.rotation = degrees_to_radians(270);
                    texture.flipY = true;
                    object.children[t].material.map = texture;
                    // object.children[t].material.map = wallMaterial;
                    object.children[t].material.map.repeat.set(16, 1);
                    // object.children[t].material.map.rotate.set(1.55);
                    // object.children[t].material.map.rotate = 1.55;
                    // console.log("wallScale   ", wallScale);
                    object.children[t].scale.y = wallScale;
                  } else object.children[t].visible = false;
                }
                object.children[t].castShadow = true;
                object.children[t].receiveShadow = true;
              }
            }
            if (is2D) {
              object.scale.y = 0.1;
            }
            fillers.push(object);
            scene.add(object);
            postData();
          }
        );

        for (let i = 0; i < rightCovers.length; i++) {
          if (rightCovers[i].uuid == objDraggable.userData.uuidRightCover) {
            rightCovers[i].visible = false;
            // objDraggable.userData.visibleRightCover = false;

            scene.add(rightCovers[i]);
          }
        }

        if (
          objBesideRight != null &&
          objBesideRight.name != "Element" &&
          objBesideRight.name === objDraggable.name
        ) {
          for (let i = 0; i < leftCovers.length; i++) {
            if (leftCovers[i].uuid == objBesideRight.userData.uuidLeftCover) {
              leftCovers[i].visible = false;
              // objBesideRight.userData.visibleLeftCover = false;

              scene.add(leftCovers[i]);
            }
          }

          objBesideRight.userData.Beside = objDraggable;
          objDraggable.userData.objBesideRight = objBesideRight;
          objDraggable.userData.typeBeside = "right";

          scene.add(objDraggable);
          scene.add(objBesideRight);
        }
      }
      // }
    }
    // Left filler
    if (
      LeftLine.getValue() * 1000 <= 200 &&
      LeftLine.getValue() * 1000 > 0 &&
      maxLeft != 0 &&
      objDraggable.name != "Element"
    ) {
      if (objBesideLeft != null) {
        objDraggable.userData.objBesideLeft = objBesideLeft;
        objDraggable.userData.objBesideLeft.userData.objBesideRight =
          objDraggable;
      }
      var drawFiller = false;
      // console.log("objBesideLeft.rotation.y " , objBesideLeft.rotation.y);
      // console.log("degrees_to_radians(0) " , degrees_to_radians(0));
      // console.log("degrees_to_radians(180)" , degrees_to_radians(180));
      // console.log("objBesideLeft.position.x" , objBesideLeft.position.x);
      // console.log("objDraggable.position.x" , objDraggable.position.x);
      // console.log("objBesideLeft.position.y" , objBesideLeft.position.y);
      // console.log("objDraggable.position.y" , objDraggable.position.y);
      if (objBesideLeft == null) {
        drawFiller = true;
      } else if (
        objBesideLeft.rotation.y == degrees_to_radians(0) ||
        objBesideLeft.rotation.y == degrees_to_radians(180)
      ) {
        if (
          objBesideLeft.position.z == objDraggable.position.z &&
          objBesideLeft.position.y == objDraggable.position.y
        ) {
          drawFiller = true;
        }
      }
      //  console.log("objBesideLeft.rotation.y " , objBesideLeft.rotation.y);
      //   console.log("degrees_to_radians(0) " , degrees_to_radians(90));
      //   console.log("degrees_to_radians(180)" , degrees_to_radians(-90));
      //   console.log("objBesideLeft.position.x" , objBesideLeft.position.x);
      //   console.log("objDraggable.position.x" , objDraggable.position.x);
      //   console.log("objBesideLeft.position.y" , objBesideLeft.position.y);
      //   console.log("objDraggable.position.y" , objDraggable.position.y);
      else if (
        objBesideLeft.rotation.y == degrees_to_radians(90) ||
        objBesideLeft.rotation.y == degrees_to_radians(-90)
      ) {
        if (
          objBesideLeft.position.x == objDraggable.position.x &&
          objBesideLeft.position.y == objDraggable.position.y
        ) {
          drawFiller = true;
        }
      }
      // if(objDraggable.position.y == objBesideLeft.position.y && objBesideLeft != null){
      if (drawFiller == true) {
        let filler = objDraggable.name != "B" ? "wall_filler" : "filler";
        //      loaderr.load("/obj/newObjects/" + filler + ".glb", function (gltf) {
        loaderr.load(
          "https://storage.googleapis.com/kitchendata/accessories/" +
            filler +
            ".glb",
          function (gltf) {
            let object = gltf.scene;

            object.position.x = leftCoordinates.x;
            object.position.z = leftCoordinates.z;
            object.name = "filler";
            object.position.y = objDraggable.position.y;
            object.scale.x = LeftLine.getValue();
            object.rotation.y = objDraggable.rotation.y;
            objDraggable.userData.leftFillerId = object.uuid;
            // console.log("Left filler    ", object);
            for (let t = 0; t < object.children.length; t++) {
              if (object.children[t].type == "Mesh") {
                object.children[t].userData.uuid = object.uuid;
                object.children[t].material.metalness = 0;

                if (t == 2) object.children[t].material.map = shutterMaterial;
                else if (t == 4) object.children[t].material.map = backMaterial;
                else if (t == 3) {
                  object.children[t].material.metalness = -1;
                  object.children[t].material.map = skirtingMaterial;
                }
                // else if (t == 3) object.children[t].material.map = skirtingMaterial;
                else if (t == 1) {
                  if (wallMaterial) {
                    object.children[t].clone();
                    let color = "MC4";
                    for (let k = 0; k < wallPanels.length; k++) {
                      if (
                        wallPanels[k].uuid ==
                        objDraggable.userData.uuidWallPanel
                      ) {
                        color = wallPanels[k].userData.color;
                      }
                      1;
                    }
                    let texture = textureLoader.load(
                      "./colors/" + color + ".png"
                    );
                    // texture.offset.set(0.05, 0.002);
                    // texture.repeat.set(0.02, 0.002);
                    texture.magFilter = NearestFilter;
                    texture.mapping = UVMapping;
                    texture.wrapS = RepeatWrapping;
                    texture.wrapT = RepeatWrapping;
                    texture.side = DoubleSide;
                    texture.flipY = true;
                    texture.rotation = degrees_to_radians(270);
                    object.children[t].material.map = texture;
                    object.children[t].material.map.repeat.set(16, 1);
                    // object.children[t].material.map.rotate = 1.55;

                    object.children[t].scale.y = wallScale;

                    // object.children[t].position.y = 0.87;
                  } else object.children[t].visible = false;
                }

                object.children[t].castShadow = true;
                object.children[t].receiveShadow = true;
              }
            }
            // console.log("filler  ", object);

            if (is2D) {
              object.scale.y = 0.1;
            }
            // object.uuid.type='filler';
            fillers.push(object);
            scene.add(object);
            postData();
          }
        );

        for (let i = 0; i < leftCovers.length; i++) {
          if (leftCovers[i].uuid == objDraggable.userData.uuidLeftCover) {
            leftCovers[i].visible = false;
            // objDraggable.userData.visibleLeftCover = false;
            scene.add(leftCovers[i]);
          }
        }
        if (
          objBesideLeft != null &&
          objBesideLeft.name != "Element" &&
          objBesideLeft.name === objDraggable.name
        ) {
          for (let i = 0; i < rightCovers.length; i++) {
            if (rightCovers[i].uuid == objBesideLeft.userData.uuidRightCover) {
              rightCovers[i].visible = false;
              // objBesideLeft.userData.visibleRightCover = false;

              scene.add(rightCovers[i]);
            }
          }

          objBesideLeft.userData.Beside = objDraggable;
          objDraggable.userData.Beside = objBesideLeft;
          objDraggable.userData.typeBeside = "left";

          scene.add(objDraggable);
          scene.add(objBesideLeft);
        }
      }
    }

    scene.add(objDraggable);

    if (is2D) {
      to2D(false, false);
      to2D(false, true);
    }

    //  for (let h = 0; h < scene.children.length; h++) {
    //    if(scene.children[h].uuid == objDraggable.userData.Beside.uuid){
    //     scene.children[h].Beside = null;
    //     objDraggable.userData.Beside = null;
    //     break;
    //    }
    // for await (const object of scene.children) {
    //   finishTops.splice(index, 1);
    //   for (let j = 0; j < scene.children.length; j++) {
    //     if (
    //       scene.children[j].uuid == finishTops.uuid
    //     ) {
    //       scene.remove(scene.children[j]);
    //       --j;
    //     }
    //   }
    // }

    // for (let index = 0; index < finishTops.length; index++) {

    // }
    // let savedObj = objDraggable;
    // objects.unshift(savedObj);
    // let repeated = 0;
    // for (let index = 0; index < objects.length; index++) {
    // let objDraggable = objects[index];

    // if (objDraggable.uuid == savedObj.uuid) {
    //   if (repeated == 0) repeated = 1;
    //   else continue;
    // }
    // console.log("repeated  ", repeated);
    // console.log("objDraggable.uuid    ", objDraggable.uuid);
    // console.log("uuids  ", uuids);
    // if (!uuids.includes(objDraggable.uuid)) {
    emptying = [];
    // console.log('emptying ' , emptying);
    // console.log('objDraggable ' , objDraggable);
    // if (objDraggable.userData.hasSink == true) {
    //   console.log('emptying 33  ',objDraggable.userData.hasSink);
    //   emptying.push(objDraggable);
    // }
    var uuid = objDraggable.uuid;
    // Finish Top for this object

    if (objDraggable.name == "B") {
      // console.log("emptying rrr ", emptying);
      if (objDraggable.userData.hasSink == true) {
        // console.log('emptying 33  ',objDraggable.userData.hasSink);
        var flag = true;
        for (let index = 0; index < emptying.length; index++) {
          if (emptying[index].uuid == objDraggable.uuid) {
            flag = false;
            break;
          }
        }

        if (flag) emptying.push(objDraggable);
      }

      (uuidsLeft = []), (uuidsRight = []);
      // let finishTopId = objDraggable.userData.finish_uuids;
      // let Id = objDraggable.uuid;
      // console.log("Hena event.object.userData.finish_uuids " ,event.object.userData.finish_uuids);
      // console.log("Hena finishTops " ,finishTops);
      await finishTop(objDraggable);
      // console.log("Scene   ", scene);

      // Remove finish top
      for await (let obj of scene.children) {
        for (let m = 0; m < objDraggable.userData.finish_uuids.length; m++) {
          if (obj.uuid == objDraggable.userData.finish_uuids[m]) {
            obj.visible = false;
            obj.children = [];
            scene.remove(obj);
            objDraggable.userData.finish_uuids.splice(m--, 1);
            // break;
          }
        }
      }
      // console.log("scene ", scene);
      // for (let f = 0; f < finishTops.length; f++) {
      //   console.log("Here drag");
      //   if (
      //     finishTops[f].parent == null
      //   ) {
      //     finishTops.splice(f, 1);
      //     console.log("Here splice ");
      //     f--;
      //   }

      // }

      //   for (let j = 0; j < scene.children.length; j++) {
      //     for (let m = 0; m < event.object.userData.finish_uuids.length; m++) {
      //     if (scene.children[j].uuid == event.object.userData.finish_uuids[m]) {
      //       event.object.userData.finish_uuids.splice(m,1);
      //       m--;
      //       scene.remove(scene.children[j]);
      //       j--;
      //     }
      //     // }
      //   }
      // }
      let widthTop = 0;

      let remain = 0;
      //    await loaderr.load("/obj/newObjects/finish_top.glb", function (gltf) {
      await loaderr.load(
        "https://storage.googleapis.com/kitchendata/accessories/finish_top.glb",
        function (gltf) {
          console.log("2");
          console.log(gltf.scene);
          console.log(gltf.scene.children[0]);

          let object = gltf.scene.children[0];

          widthTop = objDraggable.userData.W;

          if (uuidsLeft.length == 0) {
            object.position.x = objDraggable.position.x;
            object.position.z = objDraggable.position.z;
          } else {
            object.position.x = uuidsLeft[uuidsLeft.length - 1].position.x;
            object.position.z = uuidsLeft[uuidsLeft.length - 1].position.z;
          }

          if (uuidsRight.length > 0) {
            widthTop = uuidsRight[uuidsRight.length - 1].userData.W;
          }

          if (objDraggable.rotation.y == degrees_to_radians(0)) {
            /**
             * widthTop is the distance with the filler
             */

            let objCheck = null;
            if (uuidsLeft.length == 0) {
              objCheck = objDraggable;
            } else {
              objCheck = uuidsLeft[uuidsLeft.length - 1];
            }

            if (objCheck.position.x + 0.2 > measuresXG.max - wallWidth) {
              widthTop = measuresXG.max - wallWidth - objCheck.position.x;
              let remain = 0;
              if (uuidsRight.length > 0)
                remain = uuidsRight[uuidsRight.length - 1].userData.W;
              else remain = objDraggable.userData.W;

              widthTop += remain;
              object.position.x = measuresXG.max - wallWidth;
            }

            if (uuidsRight.length == 0) {
              objCheck = objDraggable;
            } else {
              objCheck = uuidsRight[uuidsRight.length - 1];
            }

            if (
              objCheck.position.x - objCheck.userData.W - 0.2 <
              measuresXG.min + wallWidth
            ) {
              widthTop = -measuresXG.min - wallWidth + objCheck.position.x;
            }

            /**
             * Check 4 cases about the object
             */
            if (uuidsLeft.length == 0) {
              if (uuidsRight.length == 0) {
                object.scale.x =
                  object.position.x - (object.position.x - widthTop);
              } else {
                if (
                  Math.abs(
                    uuidsRight[uuidsRight.length - 1].position.x -
                      uuidsRight[uuidsRight.length - 1].userData.W -
                      measuresXG.min -
                      wallWidth
                  ) <= 0.2
                ) {
                  remain =
                    -measuresXG.min -
                    wallWidth +
                    (uuidsRight[uuidsRight.length - 1].position.x -
                      uuidsRight[uuidsRight.length - 1].userData.W);
                }

                object.scale.x =
                  object.position.x -
                  (uuidsRight[uuidsRight.length - 1].position.x -
                    uuidsRight[uuidsRight.length - 1].userData.W) +
                  remain;
              }
            } else {
              if (uuidsRight.length == 0) {
                object.scale.x =
                  uuidsLeft[uuidsLeft.length - 1].position.x -
                  objDraggable.position.x +
                  widthTop;

                // console.log(
                //   "uuidsLeft[uuidsLeft.length - 1].position.x ",
                //   uuidsLeft[uuidsLeft.length - 1].position.x
                // );
                // console.log("objDraggable.position.x   ", objDraggable.position.x);
                // console.log("widthTop  ", widthTop);
                // console.log("objDraggable.userData.W  ", objDraggable.userData.W);
                // console.log("object.scale.x   ", object.scale.x);
              } else {
                // console.log(
                //   "uuidsLeft[uuidsLeft.length - 1].position.x    ",
                //   uuidsLeft[uuidsLeft.length - 1].position.x
                // );
                // console.log(
                //   "uuidsRight[uuidsRight.length - 1].position.x   ",
                //   uuidsRight[uuidsRight.length - 1].position.x
                // );
                // console.log("widthTop    ", widthTop);
                object.scale.x =
                  uuidsLeft[uuidsLeft.length - 1].position.x -
                  (uuidsRight[uuidsRight.length - 1].position.x - widthTop);
              }
            }

            object.scale.z = objDraggable.userData.L;
            object.rotation.y = objDraggable.rotation.y;
            // console.log("DDD   "  , object.scale.x);
          } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
            let objCheck = null;
            if (uuidsLeft.length == 0) {
              objCheck = objDraggable;
            } else {
              objCheck = uuidsLeft[uuidsLeft.length - 1];
            }

            if (objCheck.position.x - 0.2 < measuresXG.min + wallWidth) {
              widthTop = objCheck.position.x - measuresXG.min - wallWidth;
              let remain = 0;
              if (uuidsRight.length > 0)
                remain = uuidsRight[uuidsRight.length - 1].userData.W;
              else remain = objDraggable.userData.W;

              widthTop += remain;

              object.position.x = measuresXG.min + wallWidth;
            }

            if (uuidsRight.length == 0) {
              objCheck = objDraggable;
            } else {
              objCheck = uuidsRight[uuidsRight.length - 1];
            }

            if (
              objCheck.position.x + objCheck.userData.W + 0.2 >
              measuresXG.max - wallWidth
            ) {
              widthTop = measuresXG.max - wallWidth - objCheck.position.x;
            }

            if (uuidsLeft.length == 0) {
              if (uuidsRight.length == 0) {
                object.scale.x =
                  object.position.x - (object.position.x + widthTop);
              } else {
                if (
                  measuresXG.max -
                    wallWidth -
                    (uuidsRight[uuidsRight.length - 1].position.x +
                      uuidsRight[uuidsRight.length - 1].userData.W) <=
                  0.2
                ) {
                  remain =
                    measuresXG.max -
                    wallWidth -
                    (uuidsRight[uuidsRight.length - 1].position.x +
                      uuidsRight[uuidsRight.length - 1].userData.W);
                }
                object.scale.x =
                  object.position.x -
                  (uuidsRight[uuidsRight.length - 1].position.x +
                    uuidsRight[uuidsRight.length - 1].userData.W) -
                  remain;
                // remain;
              }
            } else {
              if (uuidsRight.length == 0) {
                object.scale.x =
                  uuidsLeft[uuidsLeft.length - 1].position.x -
                  (objDraggable.position.x + widthTop);
              } else {
                object.scale.x =
                  uuidsLeft[uuidsLeft.length - 1].position.x -
                  uuidsRight[uuidsRight.length - 1].position.x -
                  widthTop;
              }
            }
            object.position.z = object.position.z - objDraggable.userData.L;
            object.scale.z = objDraggable.userData.L;
          } else if (objDraggable.rotation.y == degrees_to_radians(90)) {
            let objCheck = null;
            if (uuidsLeft.length == 0) {
              objCheck = objDraggable;
            } else {
              objCheck = uuidsLeft[uuidsLeft.length - 1];
            }

            if (objCheck.position.z - 0.2 < measuresZG.min + wallWidth) {
              widthTop = objCheck.position.z - measuresZG.min - wallWidth;
              let remain = 0;

              if (uuidsRight.length > 0)
                remain = uuidsRight[uuidsRight.length - 1].userData.W;
              else remain = objDraggable.userData.W;

              widthTop += remain;

              object.position.z = measuresZG.min + wallWidth;
            }

            if (uuidsRight.length == 0) {
              objCheck = objDraggable;
            } else {
              objCheck = uuidsRight[uuidsRight.length - 1];
            }

            if (
              objCheck.position.z + objCheck.userData.W + 0.2 >
              measuresZG.max - wallWidth
            ) {
              widthTop = measuresZG.max - wallWidth - objCheck.position.z;
            }

            if (uuidsLeft.length == 0) {
              if (uuidsRight.length == 0) {
                object.scale.z =
                  object.position.z - (object.position.z + widthTop);
              } else {
                if (
                  measuresZG.max -
                    wallWidth -
                    (uuidsRight[uuidsRight.length - 1].position.z +
                      uuidsRight[uuidsRight.length - 1].userData.W) <=
                  0.2
                ) {
                  remain =
                    measuresZG.max -
                    wallWidth -
                    (uuidsRight[uuidsRight.length - 1].position.z +
                      uuidsRight[uuidsRight.length - 1].userData.W);
                }
                object.scale.z =
                  object.position.z -
                  (uuidsRight[uuidsRight.length - 1].position.z +
                    uuidsRight[uuidsRight.length - 1].userData.W) -
                  remain;
              }
            } else {
              if (uuidsRight.length == 0) {
                object.scale.z =
                  uuidsLeft[uuidsLeft.length - 1].position.z -
                  (objDraggable.position.z + widthTop);
              } else {
                object.scale.z =
                  uuidsLeft[uuidsLeft.length - 1].position.z -
                  (uuidsRight[uuidsRight.length - 1].position.z + widthTop);
              }
            }

            object.rotation.y =
              objDraggable.rotation.y + degrees_to_radians(90);
            object.scale.x = objDraggable.userData.L;
          }
          // -90 degree
          else {
            let objCheck = null;
            if (uuidsLeft.length == 0) {
              objCheck = objDraggable;
            } else {
              objCheck = uuidsLeft[uuidsLeft.length - 1];
            }
            if (objCheck.position.z + 0.2 > measuresZG.max - wallWidth) {
              widthTop = measuresZG.max - wallWidth - objCheck.position.z;
              let remain = 0;

              if (uuidsRight.length > 0)
                remain = uuidsRight[uuidsRight.length - 1].userData.W;
              else remain = objDraggable.userData.W;

              widthTop += remain;

              object.position.z = measuresZG.max - wallWidth;
            }

            if (uuidsRight.length == 0) {
              objCheck = objDraggable;
            } else {
              objCheck = uuidsRight[uuidsRight.length - 1];
            }

            if (
              objCheck.position.z - objCheck.userData.W - 0.2 <
              measuresZG.min + wallWidth
            ) {
              widthTop = objCheck.position.z + measuresZG.max - wallWidth;
              // object.position.z = measures.length/2;
            }

            if (uuidsLeft.length == 0) {
              if (uuidsRight.length == 0) {
                object.scale.z =
                  object.position.z - (object.position.z + widthTop);
                object.scale.x = objDraggable.userData.L;
                object.rotation.y =
                  objDraggable.rotation.y + degrees_to_radians(90);
              } else {
                if (
                  uuidsRight[uuidsRight.length - 1].position.z -
                    uuidsRight[uuidsRight.length - 1].userData.W -
                    measuresZG.min -
                    wallWidth <=
                  0.2
                ) {
                  remain =
                    uuidsRight[uuidsRight.length - 1].position.z -
                    uuidsRight[uuidsRight.length - 1].userData.W -
                    measuresZG.min -
                    wallWidth;
                }
                object.scale.x =
                  object.position.z -
                  (uuidsRight[uuidsRight.length - 1].position.z -
                    uuidsRight[uuidsRight.length - 1].userData.W) +
                  remain;
                // remain;
                object.scale.z = objDraggable.userData.L;
                object.rotation.y = objDraggable.rotation.y;
              }
            } else {
              if (uuidsRight.length == 0) {
                object.scale.x =
                  uuidsLeft[uuidsLeft.length - 1].position.z -
                  (objDraggable.position.z - widthTop);
                object.scale.z = objDraggable.userData.L;
                object.rotation.y = objDraggable.rotation.y;
              } else {
                object.scale.x =
                  uuidsLeft[uuidsLeft.length - 1].position.z -
                  (uuidsRight[uuidsRight.length - 1].position.z - widthTop);

                object.scale.z = objDraggable.userData.L;
                object.rotation.y = objDraggable.rotation.y;
              }
            }
          }

          object.position.y =
            objDraggable.position.y + objDraggable.userData.H + 0.1;

          textureWorktops = textureLoader.load(
            "./colors/" + worktopsColor + ".png"
          );
          objDraggable.userData.worktops = worktopsColor;
          textureWorktops.wrapS = textureWorktops.wrapT = RepeatWrapping;

          textureWorktops.offset.set(0.02, 0.02);
          textureWorktops.repeat.set(0.02, 0.02);

          object.material.clone();
          object.material.metalness = -0.1;
          object.material.map = textureWorktops;

          // object.material.map.repeat.set(8, 8);
          // object.material.map.repeat.set(
          //   ((object.scale.x / 2) * 2) / 0.05,
          //   ((object.scale.z / 2) * 2) / 0.05
          // );
          object.castShadow = true;
          object.receiveShadow = true;

          // if (is2D) object.visible = false;

          object.name = "TOP";
          object.scale.x = object.scale.x / 2;
          object.scale.z = object.scale.z / 2;
          if (emptying.length > 0) {
            // console.log("object  ss", object);
            // console.log("emptying[0] ", emptying[0]);
            let meshB = new Mesh(
              new BoxGeometry(
                emptying[0].userData.sinkWidth - 0.03,
                0.55,
                0.036
              ),
              new MeshStandardMaterial({ color: new Color("#FF5512") })
            );
            //  console.log("position  ",meshB.position);
            let x = 0;
            let z = 0;
            if (objDraggable.rotation.y == degrees_to_radians(0)) {
              x = emptying[0].position.x - emptying[0].userData.W / 2;
              z = emptying[0].position.z + 0.55 / 2;
              meshB.rotation.z = degrees_to_radians(90);
              meshB.rotation.x = degrees_to_radians(90);
            } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
              x = emptying[0].position.x + emptying[0].userData.W / 2;
              z = emptying[0].position.z - 0.55 / 2;
              meshB.rotation.x = degrees_to_radians(-90);
              meshB.rotation.z = degrees_to_radians(-90);
            } else if (objDraggable.rotation.y == degrees_to_radians(90)) {
              z = emptying[0].position.z + emptying[0].userData.W / 2;
              x = emptying[0].position.x + 0.55 / 2;
              meshB.rotation.z = degrees_to_radians(-90);
              meshB.rotation.x = degrees_to_radians(90);
            } else if (objDraggable.rotation.y == degrees_to_radians(-90)) {
              z = emptying[0].position.z - emptying[0].userData.W / 2;
              x = emptying[0].position.x - 0.55 / 2;
              meshB.rotation.z = degrees_to_radians(90);
              meshB.rotation.x = degrees_to_radians(-90);
            }
            meshB.position.add(new Vector3(x, object.position.y + 0.018, z));

            meshB.updateMatrix();
            object.updateMatrix();

            let bspA = CSG.default.fromMesh(object);
            let bspB = CSG.default.fromMesh(meshB);
            let bspResult = "";

            if (objDraggable.rotation.y == degrees_to_radians(0))
              bspResult = bspA.subtract(bspB);
            else bspResult = bspA.union(bspB);

            if (
              objDraggable.rotation.y == degrees_to_radians(-90) &&
              emptying.length > 1
            )
              bspResult = bspA.subtract(bspB);

            for (let b = 1; b < emptying.length; b++) {
              let meshB = new Mesh(
                new BoxGeometry(
                  emptying[b].userData.sinkWidth - 0.03,
                  0.55,
                  0.036
                ),
                new MeshStandardMaterial({
                  color: new Color("#FF5512"),
                })
              );
              // scene.add(meshB);

              if (objDraggable.rotation.y == degrees_to_radians(0)) {
                x = emptying[b].position.x - emptying[b].userData.W / 2;
                z = emptying[b].position.z + 0.55 / 2;
                meshB.rotation.z = degrees_to_radians(90);
                meshB.rotation.x = degrees_to_radians(90);
              } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
                x = emptying[b].position.x + emptying[b].userData.W / 2;
                z = emptying[b].position.z - 0.55 / 2;
                meshB.rotation.x = degrees_to_radians(-90);
              } else if (objDraggable.rotation.y == degrees_to_radians(90)) {
                z = emptying[b].position.z + emptying[b].userData.W / 2;
                x = emptying[b].position.x + 0.55 / 2;
                meshB.rotation.x = degrees_to_radians(90);
              } else if (objDraggable.rotation.y == degrees_to_radians(-90)) {
                z = emptying[b].position.z - emptying[b].userData.W / 2;
                x = emptying[b].position.x - 0.55 / 2;
                meshB.rotation.z = degrees_to_radians(90);
                meshB.rotation.x = degrees_to_radians(-90);
              }

              meshB.position.add(new Vector3(x, object.position.y + 0.018, z));

              meshB.updateMatrix();
              let bspB = CSG.default.fromMesh(meshB);

              if (
                objDraggable.rotation.y == degrees_to_radians(0) ||
                objDraggable.rotation.y == degrees_to_radians(-90)
              )
                bspResult = bspResult.subtract(bspB);
              else bspResult = bspResult.union(bspB);
            }
            // object.userData.uuid = object.uuid;
            object.material.clone();
            object.material.metalness = -0.1;
            object.material.map = textureWorktops;

            // object.material.map.repeat.set(8, 8);

            object.castShadow = true;
            object.receiveShadow = true;
            object = CSG.default.toMesh(
              bspResult,
              object.matrix,
              object.material
            );
            console.log("ddcobject ", object);
          }

          object.userData.uuid = object.uuid;

          object.name = "Top";
          objDraggable.userData.finish_uuids = [];
          objDraggable.userData.finish_uuids.push(object.uuid);

          for (let index = 0; index < uuidsLeft.length; index++) {
            for (let j = 0; j < scene.children.length; j++) {
              for (
                let m = 0;
                m < objDraggable.userData.finish_uuids.length;
                m++
              ) {
                if (
                  scene.children[j].uuid ==
                  uuidsLeft[index].userData.finish_uuids[m]
                ) {
                  uuidsLeft[index].userData.finish_uuids.splice(m--, 1);
                  scene.children[j].children = [];
                  scene.remove(scene.children[j--]);
                }
                // }
              }
            }
            uuidsLeft[index].userData.finish_uuids = [];
            uuidsLeft[index].userData.finish_uuids.push(object.uuid);
          }
          for (let index = 0; index < uuidsRight.length; index++) {
            for (let j = 0; j < scene.children.length; j++) {
              for (
                let m = 0;
                m < objDraggable.userData.finish_uuids.length;
                m++
              ) {
                if (
                  scene.children[j].uuid ==
                  uuidsRight[index].userData.finish_uuids
                ) {
                  uuidsRight[index].userData.finish_uuids.splice(m--, 1);
                  scene.children[j].children = [];
                  scene.remove(scene.children[j--]);
                }
              }
            }
            uuidsRight[index].userData.finish_uuids = [];
            uuidsRight[index].userData.finish_uuids.push(object.uuid);
          }

          object.scale.x = object.scale.x;
          object.userData.rotationY = objDraggable.rotation.y;

          if (is2D) object.visible = false;

          finishTops.push(object);

          scene.add(object);
        }
      );
      setTimeout(async () => {
        if (objectSideSave != null) {
          // console.log("Call finish top again");
          // if(objectSideType =='Left')
          // objectSideSave.userData.objBesideRight = null;
          // else
          // objectSideSave.userData.objBesideLeft = null;

          await drawFinishTop(objectSideSave);
          // console.log("emptying rrr " ,emptying);
          objectSideSave = null;
        }
      }, 500);
      postData();
    }

    // }
    //  }
    // }

    if (
      backOpenings.length > 0 ||
      frontOpenings.length > 0 ||
      leftOpenings.length > 0 ||
      rightOpenings.length > 0 ||
      wallsOpen
    ) {
      walls("Any thing");
      wallsOpen =
        wallsOpen == false
          ? true
          : backOpenings.length > 0 ||
            frontOpenings.length > 0 ||
            leftOpenings.length > 0 ||
            rightOpenings.length > 0
          ? true
          : false;
    }

    for (let alt = 0; alt < objectsAltered.length; alt++) {
      objDraggable = objectsAltered[alt];
      if (objDraggable.name == "B" && objDraggable.uuid != uuid) {
        if (objDraggable.userData.hasSink == true) {
          // console.log('emptying 33  ',objDraggable.userData.hasSink);
          var flag = true;
          for (let index = 0; index < emptying.length; index++) {
            if (emptying[index].uuid == objDraggable.uuid) {
              flag = false;
              break;
            }
          }

          if (flag) emptying.push(objDraggable);
        }

        (uuidsLeft = []), (uuidsRight = []);

        await finishTop(objDraggable);

        // Remove finish top
        for await (let obj of scene.children) {
          for (let m = 0; m < objDraggable.userData.finish_uuids.length; m++) {
            if (obj.uuid == objDraggable.userData.finish_uuids[m]) {
              obj.visible = false;
              obj.children = [];
              scene.remove(obj);
              objDraggable.userData.finish_uuids.splice(m--, 1);
              // break;
            }
          }
        }

        let widthTop = 0;

        let remain = 0;
        // console.log("111111  ");
        //      await loaderr.load("/obj/newObjects/finish_top.glb", function (gltf) {
        await loaderr.load(
          "https://storage.googleapis.com/kitchendata/accessories/finish_top.glb",
          function (gltf) {
            // console.log("3");

            // console.log("222  ");

            let object = gltf.scene.children[0];
            widthTop = objDraggable.userData.W;

            if (uuidsLeft.length == 0) {
              object.position.x = objDraggable.position.x;
              object.position.z = objDraggable.position.z;
            } else {
              object.position.x = uuidsLeft[uuidsLeft.length - 1].position.x;
              object.position.z = uuidsLeft[uuidsLeft.length - 1].position.z;
            }

            if (uuidsRight.length > 0) {
              widthTop = uuidsRight[uuidsRight.length - 1].userData.W;
            }

            if (objDraggable.rotation.y == degrees_to_radians(0)) {
              /**
               * widthTop is the distance with the filler
               */

              let objCheck = null;
              if (uuidsLeft.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsLeft[uuidsLeft.length - 1];
              }

              if (objCheck.position.x + 0.2 > measuresXG.max - wallWidth) {
                widthTop = measuresXG.max - wallWidth - objCheck.position.x;
                let remain = 0;
                if (uuidsRight.length > 0)
                  remain = uuidsRight[uuidsRight.length - 1].userData.W;
                else remain = objDraggable.userData.W;

                widthTop += remain;
                object.position.x = measuresXG.max - wallWidth;
              }

              if (uuidsRight.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsRight[uuidsRight.length - 1];
              }

              if (
                objCheck.position.x - objCheck.userData.W - 0.2 <
                measuresXG.min + wallWidth
              ) {
                widthTop = -measuresXG.min - wallWidth + objCheck.position.x;
              }

              /**
               * Check 4 cases about the object
               */
              if (uuidsLeft.length == 0) {
                if (uuidsRight.length == 0) {
                  object.scale.x =
                    object.position.x - (object.position.x - widthTop);
                } else {
                  if (
                    Math.abs(
                      uuidsRight[uuidsRight.length - 1].position.x -
                        uuidsRight[uuidsRight.length - 1].userData.W -
                        measuresXG.min -
                        wallWidth
                    ) <= 0.2
                  ) {
                    remain =
                      -measuresXG.min -
                      wallWidth +
                      (uuidsRight[uuidsRight.length - 1].position.x -
                        uuidsRight[uuidsRight.length - 1].userData.W);
                  }

                  object.scale.x =
                    object.position.x -
                    (uuidsRight[uuidsRight.length - 1].position.x -
                      uuidsRight[uuidsRight.length - 1].userData.W) +
                    remain;
                }
              } else {
                if (uuidsRight.length == 0) {
                  object.scale.x =
                    uuidsLeft[uuidsLeft.length - 1].position.x -
                    objDraggable.position.x +
                    widthTop;

                  // console.log(
                  //   "uuidsLeft[uuidsLeft.length - 1].position.x ",
                  //   uuidsLeft[uuidsLeft.length - 1].position.x
                  // );
                  // console.log(
                  //   "objDraggable.position.x   ",
                  //   objDraggable.position.x
                  // );
                  // console.log("widthTop  ", widthTop);
                  // console.log("objDraggable.userData.W  ", objDraggable.userData.W);
                  // console.log("object.scale.x   ", object.scale.x);
                } else {
                  // console.log(
                  //   "uuidsLeft[uuidsLeft.length - 1].position.x    ",
                  //   uuidsLeft[uuidsLeft.length - 1].position.x
                  // );
                  // console.log(
                  //   "uuidsRight[uuidsRight.length - 1].position.x   ",
                  //   uuidsRight[uuidsRight.length - 1].position.x
                  // );
                  // console.log("widthTop    ", widthTop);
                  object.scale.x =
                    uuidsLeft[uuidsLeft.length - 1].position.x -
                    (uuidsRight[uuidsRight.length - 1].position.x - widthTop);
                }
              }

              object.scale.z = objDraggable.userData.L;
              object.rotation.y = objDraggable.rotation.y;
              // console.log("DDD   "  , object.scale.x);
            } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
              let objCheck = null;
              if (uuidsLeft.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsLeft[uuidsLeft.length - 1];
              }

              if (objCheck.position.x - 0.2 < measuresXG.min + wallWidth) {
                widthTop = objCheck.position.x - measuresXG.min - wallWidth;
                let remain = 0;
                if (uuidsRight.length > 0)
                  remain = uuidsRight[uuidsRight.length - 1].userData.W;
                else remain = objDraggable.userData.W;

                widthTop += remain;

                object.position.x = measuresXG.min + wallWidth;
              }

              if (uuidsRight.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsRight[uuidsRight.length - 1];
              }

              if (
                objCheck.position.x + objCheck.userData.W + 0.2 >
                measuresXG.max - wallWidth
              ) {
                widthTop = measuresXG.max - wallWidth - objCheck.position.x;
              }

              if (uuidsLeft.length == 0) {
                if (uuidsRight.length == 0) {
                  object.scale.x =
                    object.position.x - (object.position.x + widthTop);
                } else {
                  if (
                    measuresXG.max -
                      wallWidth -
                      (uuidsRight[uuidsRight.length - 1].position.x +
                        uuidsRight[uuidsRight.length - 1].userData.W) <=
                    0.2
                  ) {
                    remain =
                      measuresXG.max -
                      wallWidth -
                      (uuidsRight[uuidsRight.length - 1].position.x +
                        uuidsRight[uuidsRight.length - 1].userData.W);
                  }
                  object.scale.x =
                    object.position.x -
                    (uuidsRight[uuidsRight.length - 1].position.x +
                      uuidsRight[uuidsRight.length - 1].userData.W) -
                    remain;
                  // remain;
                }
              } else {
                if (uuidsRight.length == 0) {
                  object.scale.x =
                    uuidsLeft[uuidsLeft.length - 1].position.x -
                    (objDraggable.position.x + widthTop);
                } else {
                  object.scale.x =
                    uuidsLeft[uuidsLeft.length - 1].position.x -
                    uuidsRight[uuidsRight.length - 1].position.x -
                    widthTop;
                }
              }
              object.position.z = object.position.z - objDraggable.userData.L;
              object.scale.z = objDraggable.userData.L;
            } else if (objDraggable.rotation.y == degrees_to_radians(90)) {
              let objCheck = null;
              if (uuidsLeft.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsLeft[uuidsLeft.length - 1];
              }

              if (objCheck.position.z - 0.2 < measuresZG.min + wallWidth) {
                widthTop = objCheck.position.z - measuresZG.min - wallWidth;
                let remain = 0;

                if (uuidsRight.length > 0)
                  remain = uuidsRight[uuidsRight.length - 1].userData.W;
                else remain = objDraggable.userData.W;

                widthTop += remain;

                object.position.z = measuresZG.min + wallWidth;
              }

              if (uuidsRight.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsRight[uuidsRight.length - 1];
              }

              if (
                objCheck.position.z + objCheck.userData.W + 0.2 >
                measuresZG.max - wallWidth
              ) {
                widthTop = measuresZG.max - wallWidth - objCheck.position.z;
              }

              if (uuidsLeft.length == 0) {
                if (uuidsRight.length == 0) {
                  object.scale.z =
                    object.position.z - (object.position.z + widthTop);
                } else {
                  if (
                    measuresZG.max -
                      wallWidth -
                      (uuidsRight[uuidsRight.length - 1].position.z +
                        uuidsRight[uuidsRight.length - 1].userData.W) <=
                    0.2
                  ) {
                    remain =
                      measuresZG.max -
                      wallWidth -
                      (uuidsRight[uuidsRight.length - 1].position.z +
                        uuidsRight[uuidsRight.length - 1].userData.W);
                  }
                  object.scale.z =
                    object.position.z -
                    (uuidsRight[uuidsRight.length - 1].position.z +
                      uuidsRight[uuidsRight.length - 1].userData.W) -
                    remain;
                }
              } else {
                if (uuidsRight.length == 0) {
                  object.scale.z =
                    uuidsLeft[uuidsLeft.length - 1].position.z -
                    (objDraggable.position.z + widthTop);
                } else {
                  object.scale.z =
                    uuidsLeft[uuidsLeft.length - 1].position.z -
                    (uuidsRight[uuidsRight.length - 1].position.z + widthTop);
                }
              }

              object.rotation.y =
                objDraggable.rotation.y + degrees_to_radians(90);
              object.scale.x = objDraggable.userData.L;
            }
            // -90 degree
            else {
              let objCheck = null;
              if (uuidsLeft.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsLeft[uuidsLeft.length - 1];
              }
              if (objCheck.position.z + 0.2 > measuresZG.max - wallWidth) {
                widthTop = measuresZG.max - wallWidth - objCheck.position.z;
                let remain = 0;

                if (uuidsRight.length > 0)
                  remain = uuidsRight[uuidsRight.length - 1].userData.W;
                else remain = objDraggable.userData.W;

                widthTop += remain;

                object.position.z = measuresZG.max - wallWidth;
              }

              if (uuidsRight.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsRight[uuidsRight.length - 1];
              }

              if (
                objCheck.position.z - objCheck.userData.W - 0.2 <
                measuresZG.min + wallWidth
              ) {
                widthTop = objCheck.position.z + measuresZG.max - wallWidth;
                // object.position.z = measures.length/2;
              }

              if (uuidsLeft.length == 0) {
                if (uuidsRight.length == 0) {
                  object.scale.z =
                    object.position.z - (object.position.z + widthTop);
                  object.scale.x = objDraggable.userData.L;
                  object.rotation.y =
                    objDraggable.rotation.y + degrees_to_radians(90);
                } else {
                  if (
                    uuidsRight[uuidsRight.length - 1].position.z -
                      uuidsRight[uuidsRight.length - 1].userData.W -
                      measuresZG.min -
                      wallWidth <=
                    0.2
                  ) {
                    remain =
                      uuidsRight[uuidsRight.length - 1].position.z -
                      uuidsRight[uuidsRight.length - 1].userData.W -
                      measuresZG.min -
                      wallWidth;
                  }
                  object.scale.x =
                    object.position.z -
                    (uuidsRight[uuidsRight.length - 1].position.z -
                      uuidsRight[uuidsRight.length - 1].userData.W) +
                    remain;
                  // remain;
                  object.scale.z = objDraggable.userData.L;
                  object.rotation.y = objDraggable.rotation.y;
                }
              } else {
                if (uuidsRight.length == 0) {
                  object.scale.x =
                    uuidsLeft[uuidsLeft.length - 1].position.z -
                    (objDraggable.position.z - widthTop);
                  object.scale.z = objDraggable.userData.L;
                  object.rotation.y = objDraggable.rotation.y;
                } else {
                  object.scale.x =
                    uuidsLeft[uuidsLeft.length - 1].position.z -
                    (uuidsRight[uuidsRight.length - 1].position.z - widthTop);

                  object.scale.z = objDraggable.userData.L;
                  object.rotation.y = objDraggable.rotation.y;
                }
              }
            }

            object.position.y =
              objDraggable.position.y + objDraggable.userData.H + 0.1;

            textureWorktops = textureLoader.load(
              "./colors/" + worktopsColor + ".png"
            );
            objDraggable.userData.worktops = worktopsColor;
            textureWorktops.wrapS = textureWorktops.wrapT = RepeatWrapping;

            textureWorktops.offset.set(0.02, 0.02);
            textureWorktops.repeat.set(0.02, 0.02);

            object.material.clone();
            object.material.metalness = -0.1;
            object.material.map = textureWorktops;

            // object.material.map.repeat.set(8, 8);
            // object.material.map.repeat.set(
            //   ((object.scale.x / 2) * 2) / 0.05,
            //   ((object.scale.z / 2) * 2) / 0.05
            // );
            object.castShadow = true;
            object.receiveShadow = true;

            // if (is2D) object.visible = false;

            object.name = "TOP";
            object.scale.x = object.scale.x / 2;
            object.scale.z = object.scale.z / 2;
            if (emptying.length > 0) {
              // console.log("object  ss", object);
              // console.log("emptying[0] ", emptying[0]);
              let meshB = new Mesh(
                new BoxGeometry(
                  emptying[0].userData.sinkWidth - 0.03,
                  0.55,
                  0.036
                ),
                new MeshStandardMaterial({
                  color: new Color("#FF5512"),
                })
              );
              //  console.log("position  ",meshB.position);
              let x = 0;
              let z = 0;
              if (objDraggable.rotation.y == degrees_to_radians(0)) {
                x = emptying[0].position.x - emptying[0].userData.W / 2;
                z = emptying[0].position.z + 0.55 / 2;
                meshB.rotation.z = degrees_to_radians(90);
                meshB.rotation.x = degrees_to_radians(90);
              } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
                x = emptying[0].position.x + emptying[0].userData.W / 2;
                z = emptying[0].position.z - 0.55 / 2;
                meshB.rotation.x = degrees_to_radians(-90);
                meshB.rotation.z = degrees_to_radians(-90);
              } else if (objDraggable.rotation.y == degrees_to_radians(90)) {
                z = emptying[0].position.z + emptying[0].userData.W / 2;
                x = emptying[0].position.x + 0.55 / 2;
                meshB.rotation.z = degrees_to_radians(-90);
                meshB.rotation.x = degrees_to_radians(90);
              } else if (objDraggable.rotation.y == degrees_to_radians(-90)) {
                z = emptying[0].position.z - emptying[0].userData.W / 2;
                x = emptying[0].position.x - 0.55 / 2;
                meshB.rotation.z = degrees_to_radians(90);
                meshB.rotation.x = degrees_to_radians(-90);
              }
              meshB.position.add(new Vector3(x, object.position.y + 0.018, z));

              meshB.updateMatrix();
              object.updateMatrix();

              let bspA = CSG.default.fromMesh(object);
              let bspB = CSG.default.fromMesh(meshB);
              let bspResult = "";

              if (objDraggable.rotation.y == degrees_to_radians(0))
                bspResult = bspA.subtract(bspB);
              else bspResult = bspA.union(bspB);

              if (
                objDraggable.rotation.y == degrees_to_radians(-90) &&
                emptying.length > 1
              )
                bspResult = bspA.subtract(bspB);

              for (let b = 1; b < emptying.length; b++) {
                let meshB = new Mesh(
                  new BoxGeometry(
                    emptying[b].userData.sinkWidth - 0.03,
                    0.55,
                    0.036
                  ),
                  new MeshStandardMaterial({
                    color: new Color("#FF5512"),
                  })
                );
                // scene.add(meshB);

                if (objDraggable.rotation.y == degrees_to_radians(0)) {
                  x = emptying[b].position.x - emptying[b].userData.W / 2;
                  z = emptying[b].position.z + 0.55 / 2;
                  meshB.rotation.z = degrees_to_radians(90);
                  meshB.rotation.x = degrees_to_radians(90);
                } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
                  x = emptying[b].position.x + emptying[b].userData.W / 2;
                  z = emptying[b].position.z - 0.55 / 2;
                  meshB.rotation.x = degrees_to_radians(-90);
                } else if (objDraggable.rotation.y == degrees_to_radians(90)) {
                  z = emptying[b].position.z + emptying[b].userData.W / 2;
                  x = emptying[b].position.x + 0.55 / 2;
                  meshB.rotation.x = degrees_to_radians(90);
                } else if (objDraggable.rotation.y == degrees_to_radians(-90)) {
                  z = emptying[b].position.z - emptying[b].userData.W / 2;
                  x = emptying[b].position.x - 0.55 / 2;
                  meshB.rotation.z = degrees_to_radians(90);
                  meshB.rotation.x = degrees_to_radians(-90);
                }

                meshB.position.add(
                  new Vector3(x, object.position.y + 0.018, z)
                );

                meshB.updateMatrix();
                let bspB = CSG.default.fromMesh(meshB);

                if (
                  objDraggable.rotation.y == degrees_to_radians(0) ||
                  objDraggable.rotation.y == degrees_to_radians(-90)
                )
                  bspResult = bspResult.subtract(bspB);
                else bspResult = bspResult.union(bspB);
              }
              // object.userData.uuid = object.uuid;
              object.material.clone();
              object.material.metalness = -0.1;
              object.material.map = textureWorktops;

              // object.material.map.repeat.set(8, 8);

              object.castShadow = true;
              object.receiveShadow = true;
              object = CSG.default.toMesh(
                bspResult,
                object.matrix,
                object.material
              );
              console.log("ddcobject ", object);
            }

            object.userData.uuid = object.uuid;

            object.name = "Top";
            objDraggable.userData.finish_uuids = [];
            objDraggable.userData.finish_uuids.push(object.uuid);

            for (let index = 0; index < uuidsLeft.length; index++) {
              for (let j = 0; j < scene.children.length; j++) {
                for (
                  let m = 0;
                  m < objDraggable.userData.finish_uuids.length;
                  m++
                ) {
                  if (
                    scene.children[j].uuid ==
                    uuidsLeft[index].userData.finish_uuids[m]
                  ) {
                    uuidsLeft[index].userData.finish_uuids.splice(m--, 1);
                    scene.children[j].children = [];
                    scene.remove(scene.children[j--]);
                  }
                  // }
                }
              }
              uuidsLeft[index].userData.finish_uuids = [];
              uuidsLeft[index].userData.finish_uuids.push(object.uuid);
            }
            for (let index = 0; index < uuidsRight.length; index++) {
              for (let j = 0; j < scene.children.length; j++) {
                for (
                  let m = 0;
                  m < objDraggable.userData.finish_uuids.length;
                  m++
                ) {
                  if (
                    scene.children[j].uuid ==
                    uuidsRight[index].userData.finish_uuids
                  ) {
                    uuidsRight[index].userData.finish_uuids.splice(m--, 1);
                    scene.children[j].children = [];
                    scene.remove(scene.children[j--]);
                  }
                }
              }
              uuidsRight[index].userData.finish_uuids = [];
              uuidsRight[index].userData.finish_uuids.push(object.uuid);
            }

            object.scale.x = object.scale.x;
            object.userData.rotationY = objDraggable.rotation.y;

            if (is2D) object.visible = false;

            finishTops.push(object);
            // console.log("finishTops finish top again  ", finishTops);
            // console.log("object.scale.x   ", object.scale.x);
            // console.log("object.scale.y   ", object.scale.y);
            // console.log("object.scale.z   ", object.scale.z);
            scene.add(object);
          }
        );
        setTimeout(async () => {
          if (objectSideSave != null) {
            // console.log("Call finish top again");
            // if(objectSideType =='Left')
            // objectSideSave.userData.objBesideRight = null;
            // else
            // objectSideSave.userData.objBesideLeft = null;

            await drawFinishTop(objectSideSave);
            // console.log("emptying rrr ", emptying);
            objectSideSave = null;
          }
        }, 500);
      }
    }

    postData();
    render();
  }
}

window.animation = (objId) => {
  let data = { hide_update_dialog: true };
  window.parent.postMessage(JSON.stringify(data), "*");
  let gltfSave = scene.children[objId].userData.objectSaved;
  if (scene.children[objId].name == "Element") return;
  mixer = new AnimationMixer(gltfSave.scene);

  let timescale = scene.children[objId].userData.timeScale;
  // console.log("gltfSave.animations  ", gltfSave.animations);
  // for (let index = 0; index < gltfSave.animations.length; index++) {
  // const element = array[index];

  for (let index = 0; index < gltfSave.animations.length; index++) {
    const clip = AnimationClip.findByName(
      gltfSave.animations,
      gltfSave.animations[index].name
    );

    const action = mixer.clipAction(clip);

    action.timeScale = timescale;
    action.repetitions = 0.1;
    // action.repetitions = 0;
    // console.log("timescale ", timescale);
    if (timescale < 0) {
      scene.children[objId].userData.timeScale = 0.039;
      // action.reset();/
      action.loop = LoopRepeat;
    } else {
      scene.children[objId].userData.timeScale = -0.039;
      action.loop = LoopOnce;
    }

    // action.repetitions = 1;

    action.clampWhenFinished = true;
    action.play();
  }

  // }
  // console.log("clip ", clip);
  // console.log("action ", action);

  // mixer.addEventListener("loop", function (e) {});

  // mixer.addEventListener("finished", (/*event*/) => {});
};

async function dragRight() {
  if (!is2D) {
    dragRightWall = false;
    return;
  }

  // let width = planeRight.position.x * 2;
  measuresXG.max = planeRight.position.x;
  // else if (width < 2.0) measures.width = 2.0;
  // else measures.width = width;
  // await deleteLines(null, "Es-line");
  let setted = false;
  for (let index = 0; index < scene.children.length; index++) {
    if (scene.children[index].name == "planeBottom") {
      if (!setted) {
        let plane = new BoxGeometry(
          measuresXG.max - measuresXG.min + 0.2,
          measuresZG.max - measuresZG.min + 0.2,
          0.2
        );

        scene.children[index].geometry = plane;
        scene.children[index].position.x =
          (measuresXG.max + measuresXG.min) / 2;
        // scene.children[index].material.map.repeat.set(
        //   (measuresXG.max - measuresXG.min) / 0.6,
        //   (measuresZG.max - measuresZG.min) / 0.6
        // );

        setted = true;
        // measures.width + 0.05,
        // measures. + 0.05,
        // scene.add(scene.children[index]);
        // console.log("scene ", scene);
        // console.log("scene.children.length ", scene.children.length);
      } else {
        scene.children[index].children = [];
        scene.remove(scene.children[index]);
      }
    }
  }
  await essentialText();

  // planeBottom = new Mesh(
  //   planeGeo,
  //   new MeshPhongMaterial({ map: textureFloor })
  // );
  // planeBottom.material.map.repeat.set(10, 10);
  // planeBottom.rotateX(-Math.PI / 2);
  // planeBottom.castShadow = true;
  // planeBottom.receiveShadow = true;
  // planeBottom.name = "planeBottom";

  // scene.add(planeBottom);

  // await updateChangeDimensions(true, "planeRight", "wallRight");
}
async function dragLeft() {
  if (!is2D) {
    dragLeftWall = false;
    return;
  }
  measuresXG.min = planeLeft.position.x;
  // console.log("dragLeft OK");
  // let width = -planeLeft.position.x * 2;
  // if (width > 6.0) measures.width = 6.0;
  // else if (width < 2.0) measures.width = 2.0;
  // else measures.width = width;
  // await deleteLines(null, "Es-line");
  let setted = false;
  for (let index = 0; index < scene.children.length; index++) {
    if (scene.children[index].name == "planeBottom") {
      // console.log("scene.children[index].scale" , scene.children[index]);
      // console.log("measures.width/10 + 0.05" , measures.width + 0.05);
      if (!setted) {
        let plane = new BoxGeometry(
          measuresXG.max - measuresXG.min + 0.2,
          measuresZG.max - measuresZG.min + 0.2,
          0.2
        );
        scene.children[index].geometry = plane;
        scene.children[index].position.x =
          (measuresXG.max + measuresXG.min) / 2;
        // scene.children[index].material.map.repeat.set(
        //   (measuresXG.max - measuresXG.min) / 0.6,
        //   (measuresZG.max - measuresZG.min) / 0.6
        // );

        setted = true;
        // measures.width + 0.05,
        // measures. + 0.05,
        // scene.add(scene.children[index]);
      } else {
        scene.children[index].children = [];
        scene.remove(scene.children[index]);
      }
    }
  }
  await essentialText();

  // planeBottom = new Mesh(
  //   planeGeo,
  //   new MeshPhongMaterial({ map: textureFloor })
  // );
  // planeBottom.material.map.repeat.set(10, 10);
  // planeBottom.rotateX(-Math.PI / 2);
  // planeBottom.castShadow = true;
  // planeBottom.receiveShadow = true;
  // planeBottom.name = "planeBottom";

  // scene.add(planeBottom);
  // await updateChangeDimensions(true, "planeLeft", "wallLeft");
  // controls.enabled = true;

  // controls.enabled = true;
}
async function dragBack() {
  if (!is2D) {
    dragBackWall = false;
    return;
  }
  measuresZG.min = planeBack.position.z;

  let setted = false;
  for (let index = 0; index < scene.children.length; index++) {
    if (scene.children[index].name == "planeBottom") {
      if (!setted) {
        let plane = new BoxGeometry(
          measuresXG.max - measuresXG.min + 0.2,
          measuresZG.max - measuresZG.min + 0.2,
          0.2
        );
        scene.children[index].geometry = plane;
        scene.children[index].position.z =
          (measuresZG.max + measuresZG.min) / 2;
        // scene.children[index].material.map.repeat.set(
        //   (measuresXG.max - measuresXG.min) / 0.6,
        //   (measuresZG.max - measuresZG.min) / 0.6
        // );

        setted = true;
      } else {
        scene.children[index].children = [];
        scene.remove(scene.children[index]);
        index--;
      }
    }
  }
  await essentialText();

  // planeBottom = new Mesh(
  //   planeGeo,
  //   new MeshPhongMaterial({ map: textureFloor })
  // );
  // planeBottom.material.map.repeat.set(10, 10);
  // planeBottom.rotateX(-Math.PI / 2);
  // planeBottom.castShadow = true;
  // planeBottom.receiveShadow = true;
  // planeBottom.name = "planeBottom";

  // scene.add(planeBottom);
  // await updateChangeDimensions(true, "planeBack", "wallBack");
}
async function dragFront() {
  if (!is2D) {
    dragFrontWall = false;
    return;
  }
  measuresZG.max = planeFront.position.z;

  let setted = false;
  for (let index = 0; index < scene.children.length; index++) {
    if (scene.children[index].name == "planeBottom") {
      if (!setted) {
        let plane = new BoxGeometry(
          measuresXG.max - measuresXG.min + 0.2,
          measuresZG.max - measuresZG.min + 0.2,
          0.2
        );
        scene.children[index].geometry = plane;
        scene.children[index].position.z =
          (measuresZG.max + measuresZG.min) / 2;
        // scene.children[index].material.map.repeat.set(
        //   (measuresXG.max - measuresXG.min) / 0.6,
        //   (measuresZG.max - measuresZG.min) / 0.6
        // );
        setted = true;
        // measures.width + 0.05,
        // measures. + 0.05,
        // scene.add(scene.children[index]);
      } else {
        scene.children[index].children = [];
        scene.remove(scene.children[index]);
      }
    }
  }

  await essentialText();

  // planeBottom = new Mesh(
  //   planeGeo,
  //   new MeshPhongMaterial({ map: textureFloor })
  // );
  // planeBottom.material.map.repeat.set(10, 10);
  // planeBottom.rotateX(-Math.PI / 2);
  // planeBottom.castShadow = true;
  // planeBottom.receiveShadow = true;
  // planeBottom.name = "planeBottom";

  // scene.add(planeBottom);
  // await updateChangeDimensions(true, "planeFront", "wallFront");
}
let objectSideSave = null;
let objectSideType = "Left";
// Drag the object.
async function drag(objDraggable) {
  //  console.log('drag now');
  let data = { hide_update_dialog: true };
  window.parent.postMessage(JSON.stringify(data), "*");

  dragged = true;
  backOpenings = [];
  frontOpenings = [];
  leftOpenings = [];
  rightOpenings = [];
  if (objDraggable.userData.objBesideLeft != null) {
    objectSideSave = objDraggable.userData.objBesideLeft;
  } else if (objDraggable.userData.objBesideRight != null) {
    objectSideSave = objDraggable.userData.objBesideRight;
    objectSideType = "Right";
  }
  // isUpdatedBeside is a variable to check the code will run just once.
  if (!isUpdatedBeside) {
    for (let index = 0; index < finishTops.length; index++) {
      for (let m = 0; m < objDraggable.userData.finish_uuids.length; m++) {
        if (finishTops[index].uuid == objDraggable.userData.finish_uuids[m]) {
          // console.log("ok splice");
          finishTops.splice(index, 1);
          index--;
          // break;
        }
      }
    }

    for await (let obj of scene.children) {
      for (let m = 0; m < objDraggable.userData.finish_uuids.length; m++) {
        if (obj.uuid == objDraggable.userData.finish_uuids[m]) {
          objDraggable.userData.finish_uuids.splice(m--, 1);
          scene.remove(obj);
          // break;
        }
      }
    }

    objDraggable.userData.finish_uuids = [];

    uuids = [];

    // stop camera
    controls.enabled = false;

    // let objDraggable = event.object;

    console.log('fillers ' , fillers);
    // Remove filler of the draggable object.
    for (let index = 0; index < scene.children.length; index++) {
      if (
        scene.children[index].uuid == objDraggable.userData.rightFillerId ||
        scene.children[index].uuid == objDraggable.userData.leftFillerId
      ) {
        for (let f = 0; f < fillers.length; f++) {
          if (fillers[f].uuid == scene.children[index].uuid) {
            fillers.splice(f, 1);
            break;
          }
        }
        scene.remove(scene.children[index]);
        index--;
      }
    }

    console.log('fillers ' , fillers);


    if (objDraggable.userData.objBesideLeft != null) {
      for await (let obj of scene.children) {
        if (
          obj.uuid ===
          objDraggable.userData.objBesideLeft.userData.rightFillerId
        ) {
          for await (let objInner of scene.children) {
            if (objDraggable.userData.objBesideLeft.uuid == objInner.uuid) {
              objInner.userData.rightFillerId = null;

              break;
            }
          }
          scene.remove(obj);
        }
      }
    }
    if (objDraggable.userData.objBesideRight != null) {
      for await (let obj of scene.children) {
        if (
          obj.uuid ===
          objDraggable.userData.objBesideRight.userData.leftFillerId
        ) {
          for await (let objInner of scene.children) {
            if (objDraggable.userData.objBesideRight.uuid == objInner.uuid) {
              objInner.userData.leftFillerId = null;

              break;
            }
          }
          scene.remove(obj);
        }
      }
    }

    objDraggable.userData.rightFillerId = null;
    objDraggable.userData.leftFillerId = null;
    scene.add(objDraggable);

    // Show left cover
    if (objDraggable.userData.hasLeftCover) {
      for (let index = 0; index < leftCovers.length; index++) {
        if (leftCovers[index].uuid == objDraggable.userData.uuidLeftCover) {
          if (objDraggable.userData.visibleLeftCover == true)
            leftCovers[index].visible = true;

          scene.add(leftCovers[index]);
        }
      }
    }
    // Show right cover
    if (objDraggable.userData.hasRightCover) {
      for (let index = 0; index < rightCovers.length; index++) {
        if (rightCovers[index].uuid == objDraggable.userData.uuidRightCover) {
          if (objDraggable.userData.visibleRightCover == true)
            rightCovers[index].visible = true;

          scene.add(rightCovers[index]);
        }
      }
    }
    // Show covers of brsides objects
    for (let i = 0; i < objects.length; i++) {
      if (
        objDraggable.userData.objBesideRight != null &&
        objects[i].uuid == objDraggable.userData.objBesideRight.uuid
      ) {
        //show the left cover of the side object
        for (let index = 0; index < leftCovers.length; index++) {
          if (leftCovers[index].uuid == objects[i].userData.uuidLeftCover) {
            if (objects[i].userData.visibleLeftCover == true)
              leftCovers[index].visible = true;

            scene.add(leftCovers[index]);
          }
        }

        objects[i].userData.objBesideRight = null;
        objects[i].userData.Beside = null;
        scene.add(objects[i]);
      }
      if (
        objDraggable.userData.objBesideLeft != null &&
        objects[i].uuid == objDraggable.userData.objBesideLeft.uuid
      ) {
        //show the right cover of the side object
        for (let index = 0; index < rightCovers.length; index++) {
          if (rightCovers[index].uuid == objects[i].userData.uuidRightCover) {
            if (objects[i].userData.visibleRightCover == true)
              rightCovers[index].visible = true;

            scene.add(rightCovers[index]);
          }
        }

        objects[i].userData.Beside = null;
        objects[i].userData.objBesideLeft = null;
        scene.add(objects[i]);
      }
    }
    objDraggable.userData.Beside = null;
    objDraggable.userData.objBesideRight = null;
    objDraggable.userData.objBesideLeft = null;
    scene.add(objDraggable);
    isUpdatedBeside = true;
    // console.log("objDraggable   ", objDraggable);
  }

  // scene
  if (uuidSelected.length > 0) {
    deleteLines("SelectedObject");
    uuidSelected = [];
  }

  if (
    objDraggable.name === "W" ||
    objDraggable.name === "WC" ||
    objDraggable.name === "Win"
  ) {
    if (is2D) objDraggable.position.y = wallWidth * 2;
  }
  // else objects[i].position.y = measures.height / 2;
  // if (objects[i].position.y < 0.1) objects[i].position.y = 0.1;
  // else if (objects[i].position.y > measures.height - objects[i].userData.H)
  //   objects[i].position.y = measures.height - objects[i].userData.H;
  // } else if (
  //   objects[i].position.y != wallWidth &&
  //   objects[i].name != "Element"
  // ) {
  // objects[i].position.y = wallWidth;
  // } else if (objects[i].name === "Element") {
  if (objDraggable.userData.heightable) {
    if (objDraggable.position.y < wallWidth) {
      objDraggable.position.y = wallWidth;
    }
    if (objDraggable.position.y > measures.height - objDraggable.userData.H) {
      objDraggable.position.y = measures.height - objDraggable.userData.H;
    }
  } else {
    objDraggable.position.y = wallWidth;
  }
  scene.add(objDraggable);

  // Start Rotate The component when it will be near of the wall
  if (
    objDraggable.position.x <
      measuresXG.min +
        Math.max(objDraggable.userData.L, objDraggable.userData.W) &&
    objDraggable.position.z >
      measuresZG.min +
        Math.max(objDraggable.userData.L, objDraggable.userData.W) &&
    objDraggable.position.z <
      measuresZG.max -
        Math.max(objDraggable.userData.L, objDraggable.userData.W) &&
    objDraggable.rotation.y != degrees_to_radians(90)
  ) {
    objDraggable.rotation.y = degrees_to_radians(90);
    // for make move easier
    objDraggable.position.x -= objDraggable.userData.L;
  } else if (
    objDraggable.position.x >
      measuresXG.max -
        Math.max(objDraggable.userData.L, objDraggable.userData.W) &&
    objDraggable.position.z >
      measuresZG.min / 2 +
        Math.max(objDraggable.userData.L, objDraggable.userData.W) &&
    objDraggable.position.z <
      measuresZG.max -
        Math.max(objDraggable.userData.L, objDraggable.userData.W) &&
    objDraggable.rotation.y != degrees_to_radians(-90)
  ) {
    objDraggable.rotation.y = degrees_to_radians(-90);
    objDraggable.position.x += objDraggable.userData.L;
  } else if (
    objDraggable.position.z <
      measuresZG.min +
        Math.max(objDraggable.userData.L, objDraggable.userData.W) &&
    objDraggable.position.x >
      measuresXG.min +
        Math.max(objDraggable.userData.L, objDraggable.userData.W) &&
    objDraggable.position.x <
      measuresXG.max -
        Math.max(objDraggable.userData.L, objDraggable.userData.W) &&
    objDraggable.rotation.y != 0
  ) {
    objDraggable.rotation.y = 0.0;
    objDraggable.position.z -= objDraggable.userData.L;
  } else if (
    objDraggable.position.z >
      measuresZG.max -
        Math.max(objDraggable.userData.L, objDraggable.userData.W) &&
    objDraggable.position.x >
      measuresXG.min +
        Math.max(objDraggable.userData.L, objDraggable.userData.W) &&
    objDraggable.position.x <
      measuresXG.max -
        Math.max(objDraggable.userData.L, objDraggable.userData.W) &&
    objDraggable.rotation.y != degrees_to_radians(180)
  ) {
    objDraggable.rotation.y = degrees_to_radians(180);
    objDraggable.position.z += objDraggable.userData.L;
  }
  // End Rotate The component when it will be near of the wall

  /// Start Determine Code
  if (
    objDraggable.position.x - objDraggable.userData.wallOffset / 1000 <
    measuresXG.min + wallWidth
  ) {
    objDraggable.position.x =
      measuresXG.min + wallWidth + objDraggable.userData.wallOffset / 1000;
  } else if (
    objDraggable.position.x + objDraggable.userData.wallOffset / 1000 >
    measuresXG.max - wallWidth
  ) {
    objDraggable.position.x =
      measuresXG.max - wallWidth - objDraggable.userData.wallOffset / 1000;
  }

  if (
    objDraggable.position.z - objDraggable.userData.wallOffset / 1000 <
    measuresZG.min + wallWidth
  ) {
    objDraggable.position.z =
      measuresZG.min + wallWidth + objDraggable.userData.wallOffset / 1000;
  } else if (
    objDraggable.position.z + objDraggable.userData.wallOffset / 1000 >
    measuresZG.max - wallWidth
  ) {
    objDraggable.position.z =
      measuresZG.max - wallWidth - objDraggable.userData.wallOffset / 1000;
  }
  /// End Determine Code

  /// Start Stay the component at the kitchen
  if (
    objDraggable.rotation.y == degrees_to_radians(0) &&
    objDraggable.position.x - objDraggable.userData.wallOffset / 1000 <
      measuresXG.min + wallWidth + objDraggable.userData.W
  ) {
    objDraggable.rotation.y = degrees_to_radians(90);
  } else if (
    objDraggable.rotation.y == degrees_to_radians(90) &&
    objDraggable.position.z + objDraggable.userData.wallOffset / 1000 >
      measuresZG.max - wallWidth - objDraggable.userData.W
  ) {
    objDraggable.rotation.y = degrees_to_radians(180);
  } else if (
    objDraggable.rotation.y == degrees_to_radians(180) &&
    objDraggable.position.x + objDraggable.userData.wallOffset / 1000 >
      measuresXG.max - wallWidth - objDraggable.userData.W
  ) {
    objDraggable.rotation.y = degrees_to_radians(-90);
  } else if (
    objDraggable.rotation.y == degrees_to_radians(-90) &&
    objDraggable.position.z - objDraggable.userData.wallOffset / 1000 <
      measuresZG.min + wallWidth + objDraggable.userData.W
  ) {
    objDraggable.rotation.y = degrees_to_radians(0);
  }
  /// End component in kitchen

  // Set the right position for all pieces of the object.
  for (var i = 0; i < objects.length; i++) {
    // if(objects[i].userData.ElType == 'opening'){
    //   if(objects[i].userData.heightable == 'no'){
    //     objects[i].position.y = wallWidth;
    //   }
    // }

    // planeBack.castShadow = true;
    // planeBack.receiveShadow = true;
    // planeBack.name = "planeBack";
    // planeBack.material.map = textureWalls;
    // scene.add(planeBack);
    // console.log("objects  " , objects);

    if (objects[i].userData.ElType == "opening") {
      if (
        objects[i].rotation.y == degrees_to_radians(0) &&
        objects[i].position.z == measuresZG.min + wallWidth
      ) {
        backOpenings.push(objects[i]);
        wallsOpen = true;
      } else if (
        objects[i].rotation.y == degrees_to_radians(90) &&
        objects[i].position.x == measuresXG.min + wallWidth
      ) {
        leftOpenings.push(objects[i]);
        wallsOpen = true;
      } else if (
        objects[i].rotation.y == degrees_to_radians(180) &&
        objects[i].position.z == measuresZG.max - wallWidth
      ) {
        frontOpenings.push(objects[i]);
        wallsOpen = true;
      } else if (
        objects[i].rotation.y == degrees_to_radians(-90) &&
        objects[i].position.x == measuresXG.max - wallWidth
      ) {
        rightOpenings.push(objects[i]);
        wallsOpen = true;
      }
    }
    // End

    scene.add(objects[i]);

    // Left Cover
    if (objects[i].userData.hasLeftCover == true) {
      let positionX, positionY, positionZ;
      if (objects[i].rotation.y == degrees_to_radians(0)) {
        positionX = objects[i].position.x + 0.018;
        positionZ = objects[i].position.z;
        positionY = objects[i].position.y + 0.1;
      } else if (objects[i].rotation.y == degrees_to_radians(90)) {
        positionX = objects[i].position.x;
        positionZ = objects[i].position.z - 0.018;
        positionY = objects[i].position.y + 0.1;
      } else if (objects[i].rotation.y == degrees_to_radians(180)) {
        positionX = objects[i].position.x - 0.018;
        positionZ = objects[i].position.z;
        positionY = objects[i].position.y + 0.1;
      } else if (objects[i].rotation.y == degrees_to_radians(-90)) {
        positionX = objects[i].position.x;
        positionZ = objects[i].position.z + 0.018;
        positionY = objects[i].position.y + 0.1;
      }

      for (let index = 0; index < leftCovers.length; index++) {
        if (leftCovers[index].uuid == objects[i].userData.uuidLeftCover) {
          leftCovers[index].position.x = positionX;
          leftCovers[index].position.z = positionZ;
          leftCovers[index].rotation.y = objects[i].rotation.y;
          if (objects[i].name != "B" && objects[i].name != "T") {
            leftCovers[index].position.y =
              objects[i].position.y -
              (objects[i].userData.hasDecoStrip == true ? 0.1 : 0);
          }
          scene.add(leftCovers[index]);
        }
      }
    }

    // Right Cover
    if (objects[i].userData.hasRightCover == true) {
      let positionX, positionY, positionZ;
      if (objects[i].rotation.y == degrees_to_radians(0)) {
        positionX = objects[i].position.x - objects[i].userData.W;
        positionZ = objects[i].position.z;
        positionY = objects[i].position.y + 0.1;
      } else if (objects[i].rotation.y == degrees_to_radians(90)) {
        positionX = objects[i].position.x;
        positionZ = objects[i].position.z + objects[i].userData.W;
        positionY = objects[i].position.y + 0.1;
      } else if (objects[i].rotation.y == degrees_to_radians(180)) {
        positionX = objects[i].position.x + objects[i].userData.W;
        positionZ = objects[i].position.z;

        positionY = objects[i].position.y + 0.1;
      } else if (objects[i].rotation.y == degrees_to_radians(-90)) {
        positionX = objects[i].position.x;
        positionZ = objects[i].position.z - objects[i].userData.W;
        positionY = objects[i].position.y + 0.1;
      }

      for (let index = 0; index < rightCovers.length; index++) {
        if (rightCovers[index].uuid == objects[i].userData.uuidRightCover) {
          rightCovers[index].position.x = positionX;
          rightCovers[index].position.z = positionZ;
          rightCovers[index].rotation.y = objects[i].rotation.y;

          if (objects[i].name != "B" && objects[i].name != "T")
            rightCovers[index].position.y =
              objects[i].position.y -
              (objects[i].userData.hasDecoStrip == true ? 0.1 : 0);

          scene.add(rightCovers[index]);
        }
      }
    }
    // console.log("objects[i]  " , objects[i]);

    // Back Cover
    if (objects[i].userData.hasBackCover == true) {
      let positionX, positionY, positionZ;

      positionX = objects[i].position.x;
      positionZ = objects[i].position.z;
      positionY = objects[i].position.y + 0.1;

      for (let index = 0; index < backCovers.length; index++) {
        if (backCovers[index].uuid == objects[i].userData.uuidBackCover) {
          backCovers[index].position.x = positionX;
          backCovers[index].position.z = positionZ;
          backCovers[index].rotation.y = objects[i].rotation.y;

          if (objects[i].name != "B" && objects[i].name != "T")
            backCovers[index].position.y = objects[i].position.y;

          scene.add(backCovers[index]);
        }
      }
    }

    //  Change coordinates of the wall panel
    if (objects[i].userData.hasWallPanel == true) {
      let positionX, positionY, positionZ;
      positionX = objects[i].position.x;
      positionZ = objects[i].position.z;
      // positionY = objects[i].userData.H + 0.15;

      for (let index = 0; index < wallPanels.length; index++) {
        if (wallPanels[index].uuid == objects[i].userData.uuidWallPanel) {
          wallPanels[index].position.x = positionX;
          wallPanels[index].position.z = positionZ;
          // wallPanels[index].position.y = positionY;
          wallPanels[index].rotation.y = objects[i].rotation.y;
          wallPanels[index].scale.x = objects[i].userData.W;

          // console.log("wallPanels[index]   " , wallPanels[index]);

          if (
            positionX == measuresXG.max - wallWidth ||
            positionX == measuresXG.min + wallWidth ||
            positionZ == measuresZG.max - wallWidth ||
            positionZ == measuresZG.min + wallWidth
          )
            wallPanels[index].visible = true;
          else wallPanels[index].visible = false;
          scene.add(wallPanels[index]);
        }
      }
    }

    //  Change coordinates of the Cornice
    if (objects[i].userData.hasCornice == true) {
      let positionX, positionY, positionZ;
      positionX = objects[i].position.x;
      positionZ = objects[i].position.z;

      var lightPosX;
      var lightPosZ;
      if (objects[i].rotation.y == degrees_to_radians(0)) {
        positionZ = objects[i].position.z + objects[i].userData.L - 0.05;
        lightPosX = objects[i].position.x - objects[i].userData.W / 2;
        lightPosZ = objects[i].position.z + objects[i].userData.L - 0.05;
        positionX += 0.018;
      } else if (objects[i].rotation.y == degrees_to_radians(180)) {
        positionZ = objects[i].position.z - objects[i].userData.L + 0.05;
        lightPosX = objects[i].position.x + objects[i].userData.W / 2;
        lightPosZ = objects[i].position.z - objects[i].userData.L + 0.05;
        positionX -= 0.018;
      } else if (objects[i].rotation.y == degrees_to_radians(90)) {
        positionX = objects[i].position.x + objects[i].userData.L - 0.05;
        lightPosZ = objects[i].position.z + objects[i].userData.W / 2;
        lightPosX = objects[i].position.x + objects[i].userData.L - 0.05;
        positionZ -= 0.018;
      } else {
        positionX = objects[i].position.x - objects[i].userData.L + 0.05;
        lightPosZ = objects[i].position.z - objects[i].userData.W / 2;
        lightPosX = objects[i].position.x - objects[i].userData.L + 0.05;
        positionZ += 0.018;
      }

      // positionY = objects[i].position.y - 0.1;

      for (let index = 0; index < Cornices.length; index++) {
        if (Cornices[index].uuid == objects[i].userData.uuidCornice) {
          Cornices[index].position.x = positionX;
          Cornices[index].position.z = positionZ;
          Cornices[index].position.y =
            objects[i].position.y + objects[i].userData.H;

          Cornices[index].rotation.y = objects[i].rotation.y;

          scene.add(Cornices[index]);
        }
      }
      for (let index = 0; index < lightObjects.length; index++) {
        if (lightObjects[index].uuid == objects[i].userData.uuidLightCornice) {
          lightObjects[index].position.x = lightPosX;
          lightObjects[index].position.z = lightPosZ;
          lightObjects[index].position.y =
            objects[i].position.y + objects[i].userData.H;
          lightObjects[index].rotation.y = objects[i].rotation.y;
          scene.add(lightObjects[index]);
        }
      }
    }
    //  Change coordinates of the Oven
    if (objects[i].userData.hasOven == true) {
      for (let index = 0; index < ovens.length; index++) {
        if (ovens[index].uuid == objects[i].userData.uuidOven) {
          let startPositionX =
            (objects[i].userData.W - ovens[index].userData.ovenWidth) / 2;
          let startPositionZ = (objects[i].userData.L - 0.55) / 2;
          if (objects[i].rotation.y == degrees_to_radians(0)) {
            ovens[index].position.x = objects[i].position.x - startPositionX;
            ovens[index].position.z = objects[i].position.z + startPositionZ;
          } else if (objects[i].rotation.y == degrees_to_radians(180)) {
            ovens[index].position.x = objects[i].position.x + startPositionX;
            ovens[index].position.z = objects[i].position.z - startPositionZ;
          } else if (objects[i].rotation.y == degrees_to_radians(90)) {
            ovens[index].position.x = objects[i].position.x + startPositionZ;
            ovens[index].position.z = objects[i].position.z + startPositionX;
          } else {
            ovens[index].position.x = objects[i].position.x - startPositionZ;
            ovens[index].position.z = objects[i].position.z - startPositionX;
          }

          ovens[index].rotation.y = objects[i].rotation.y;

          scene.add(ovens[index]);
          break;
        }
      }
    }

    //  Change coordinates of the Sink
    if (objects[i].userData.hasSink == true) {
      for (let index = 0; index < sinks.length; index++) {
        if (sinks[index].uuid == objects[i].userData.uuidSink) {
          let startPositionX =
            (objects[i].userData.W - sinks[index].userData.sinkWidth) / 2;
          let startPositionZ = (objects[i].userData.L - 0.55) / 2;
          if (objects[i].rotation.y == degrees_to_radians(0)) {
            sinks[index].position.x = objects[i].position.x - startPositionX;
            sinks[index].position.z = objects[i].position.z + startPositionZ;
          } else if (objects[i].rotation.y == degrees_to_radians(180)) {
            sinks[index].position.x = objects[i].position.x + startPositionX;
            sinks[index].position.z = objects[i].position.z - startPositionZ;
          } else if (objects[i].rotation.y == degrees_to_radians(90)) {
            sinks[index].position.x = objects[i].position.x + startPositionZ;
            sinks[index].position.z = objects[i].position.z + startPositionX;
          } else {
            sinks[index].position.x = objects[i].position.x - startPositionZ;
            sinks[index].position.z = objects[i].position.z - startPositionX;
          }

          sinks[index].rotation.y = objects[i].rotation.y;

          scene.add(sinks[index]);
          break;
        }
      }
    }

    //  Change coordinates of the Deco strip
    if (objects[i].userData.hasDecoStrip == true) {
      let positionX, positionY, positionZ;
      positionX = objects[i].position.x;
      positionZ = objects[i].position.z;

      var lightPosX;
      var lightPosZ;

      var lightRotX = 0;
      var lightRotZ = 0;
      var lightRotY = 0;

      if (objects[i].rotation.y == degrees_to_radians(0)) {
        positionZ = objects[i].position.z + objects[i].userData.L - 0.018;
        lightPosX = objects[i].position.x - objects[i].userData.W / 2;
        lightPosZ = objects[i].position.z + objects[i].userData.L - 0.118;
        lightRotX = degrees_to_radians(-90);
        lightRotZ = degrees_to_radians(0);
        lightRotY = objects[i].rotation.y;
      } else if (objects[i].rotation.y == degrees_to_radians(180)) {
        positionZ = objects[i].position.z - objects[i].userData.L + 0.018;
        lightPosX = objects[i].position.x + objects[i].userData.W / 2;
        lightPosZ = objects[i].position.z - objects[i].userData.L + 0.118;
        lightRotX = degrees_to_radians(90);
        lightRotZ = degrees_to_radians(180);
        lightRotY = objects[i].rotation.y;
      } else if (objects[i].rotation.y == degrees_to_radians(90)) {
        positionX = objects[i].position.x + objects[i].userData.L - 0.018;
        lightPosZ = objects[i].position.z + objects[i].userData.W / 2;
        lightPosX = objects[i].position.x + objects[i].userData.L - 0.118;
        lightRotZ = degrees_to_radians(180);
        lightRotY = objects[i].rotation.y;
      } else {
        positionX = objects[i].position.x - objects[i].userData.L + 0.018;
        lightPosZ = objects[i].position.z - objects[i].userData.W / 2;
        lightPosX = objects[i].position.x - objects[i].userData.L + 0.118;
        lightRotZ = degrees_to_radians(180);
        lightRotY = objects[i].rotation.y;
      }
      positionY = objects[i].position.y - 0.1;

      for (let index = 0; index < decoStrips.length; index++) {
        if (decoStrips[index].uuid == objects[i].userData.uuidDecoStrip) {
          decoStrips[index].position.x = positionX;
          decoStrips[index].position.z = positionZ;
          decoStrips[index].position.y = positionY;
          decoStrips[index].rotation.y = objects[i].rotation.y;

          scene.add(decoStrips[index]);
        }
      }
      // for (let index = 0; index < lightObjects.length; index++) {
      //   if (lightObjects[index].uuid == objects[i].userData.uuidLight) {
      //     lightObjects[index].position.x = lightPosX;
      //     lightObjects[index].position.z = lightPosZ;
      //     lightObjects[index].rotation.y = objects[i].rotation.y;
      //     scene.add(lightObjects[index]);
      //   }
      // }

      for (let index = 0; index < lightObjects.length; index++) {
        if (lightObjects[index].uuid == objects[i].userData.uuidLight) {
          lightObjects[index].position.x = lightPosX;
          lightObjects[index].position.z = lightPosZ;
          lightObjects[index].position.y = positionY + 0.1;
          if (lightRotX == 0) {
            lightObjects[index].rotation.y = lightRotZ;
            lightObjects[index].rotation.z = degrees_to_radians(-90);
            lightObjects[index].rotation.x = degrees_to_radians(90);
            // console.log("Here1 lights");
          } else {
            lightObjects[index].rotation.x = lightRotX;
            lightObjects[index].rotation.z = lightRotZ;
            lightObjects[index].rotation.y = lightRotY;
            // console.log("Here2 lights");
          }

          // lightObjects[index].rotation.y = objects[i].rotation.y;
          scene.add(lightObjects[index]);
          // console.log("lightObjects[index]  ", lightObjects[index]);
          break;
        }
      }
    }

    //  Change coordinates of the light of skirting
    if (objects[i].userData.hasLightSkirting == true) {
      var lightPosX;
      var lightPosZ;
      if (objects[i].rotation.y == degrees_to_radians(0)) {
        lightPosX = objects[i].position.x - objects[i].userData.W / 2;
        lightPosZ = objects[i].position.z + objects[i].userData.L - 0.014;
      } else if (objects[i].rotation.y == degrees_to_radians(180)) {
        lightPosX = objects[i].position.x + objects[i].userData.W / 2;
        lightPosZ = objects[i].position.z - objects[i].userData.L + 0.014;
      } else if (objects[i].rotation.y == degrees_to_radians(90)) {
        lightPosZ = objects[i].position.z + objects[i].userData.W / 2;
        lightPosX = objects[i].position.x + objects[i].userData.L - 0.014;
      } else {
        lightPosZ = objects[i].position.z - objects[i].userData.W / 2;
        lightPosX = objects[i].position.x - objects[i].userData.L + 0.014;
      }

      for (let index = 0; index < lightObjects.length; index++) {
        if (lightObjects[index].uuid == objects[i].userData.uuidLightSkirting) {
          lightObjects[index].position.x = lightPosX;
          lightObjects[index].position.z = lightPosZ;
          lightObjects[index].rotation.y = objects[i].rotation.y;
          scene.add(lightObjects[index]);
        }
      }
    }

    // Handle Direction

    if (objects[i].userData.hasHandleDirection == true) {
      let positionX, positionY, positionZ;

      for (let index = 0; index < directions.length; index++) {
        if (directions[index].uuid == objects[i].userData.uuidDirection) {
          if (objects[i].userData.ElType != "opening") {
            if (objects[i].rotation.y == degrees_to_radians(0)) {
              // if(objects[i].userData.Direction == "L"){
              positionX = objects[i].position.x;
              // }else{
              //   positionX = objects[i].position.x -  objects[i].userData.W;
              //   directions[index].rotation.z = degrees_to_radians(-180);
              // }
              positionZ =
                objects[i].position.z +
                (objects[i].userData.ElType == "opening"
                  ? 0.1
                  : objects[i].userData.L);
            } else if (objects[i].rotation.y == degrees_to_radians(90)) {
              // if(objects[i].userData.Direction == "L"){
              positionZ = objects[i].position.z;

              // }else{
              //   positionZ = objects[i].position.z +  objects[i].userData.W;
              //   directions[index].rotation.x = degrees_to_radians(0);
              // }
              positionX =
                objects[i].position.x +
                (objects[i].userData.ElType == "opening"
                  ? 0.1
                  : objects[i].userData.L);
            } else if (objects[i].rotation.y == degrees_to_radians(180)) {
              // if(objects[i].userData.Direction == "L"){
              positionX = objects[i].position.x;
              // }else{
              //   positionX = objects[i].position.x  + objects[i].userData.W;
              //   directions[index].rotation.z = degrees_to_radians(-180);
              // }

              positionZ =
                objects[i].position.z -
                (objects[i].userData.ElType == "opening"
                  ? 0.1
                  : objects[i].userData.L);
            } else if (objects[i].rotation.y == degrees_to_radians(-90)) {
              // if(objects[i].userData.Direction == "L"){
              positionZ = objects[i].position.z;
              // }else{
              //   positionZ = objects[i].position.z - objects[i].userData.W;
              //   directions[index].rotation.x = degrees_to_radians(0);
              // }
              positionX =
                objects[i].position.x -
                (objects[i].userData.ElType == "opening"
                  ? 0.1
                  : objects[i].userData.L);
            }

            directions[index].position.x = positionX;
            directions[index].position.z = positionZ;
            directions[index].rotation.y = objects[i].rotation.y;
          } else {
            if (objects[i].rotation.y == degrees_to_radians(0)) {
              positionX = objects[i].position.x;
              positionZ =
                objects[i].position.z +
                (objects[i].userData.ElType == "opening"
                  ? 0.1
                  : objects[i].userData.L);
              // console.log(
              //   "objects[i].userData.openingDir ",
              //   objects[i].userData.openingDir
              // );
              if (objects[i].userData.openingDir == "in")
                directions[index].rotation.x = degrees_to_radians(0);
              else directions[index].rotation.x = degrees_to_radians(-180);

              directions[index].rotation.z = degrees_to_radians(0);
              directions[index].rotation.y = objects[i].rotation.y;
            } else if (objects[i].rotation.y == degrees_to_radians(90)) {
              positionX =
                objects[i].position.x +
                (objects[i].userData.ElType == "opening"
                  ? 0.1
                  : objects[i].userData.L);
              positionZ = objects[i].position.z;
              if (objects[i].userData.openingDir == "in")
                directions[index].rotation.y = degrees_to_radians(90);
              else directions[index].rotation.y = degrees_to_radians(-90);

              directions[index].rotation.z = degrees_to_radians(90);
              directions[index].rotation.x = degrees_to_radians(-90);

              // directions[index].rotation.y = degrees_to_radians(-90);
            } else if (objects[i].rotation.y == degrees_to_radians(180)) {
              positionX = objects[i].position.x;
              positionZ =
                objects[i].position.z -
                (objects[i].userData.ElType == "opening"
                  ? 0.1
                  : objects[i].userData.L);

              if (objects[i].userData.openingDir == "in")
                directions[index].rotation.x = degrees_to_radians(0);
              else directions[index].rotation.x = degrees_to_radians(-180);
              directions[index].rotation.z = degrees_to_radians(0);
              directions[index].rotation.y = objects[i].rotation.y;
            } else if (objects[i].rotation.y == degrees_to_radians(-90)) {
              positionX =
                objects[i].position.x -
                (objects[i].userData.ElType == "opening"
                  ? 0.1
                  : objects[i].userData.L);
              positionZ = objects[i].position.z;
              if (objects[i].userData.openingDir == "in")
                directions[index].rotation.y = degrees_to_radians(-90);
              else directions[index].rotation.y = degrees_to_radians(90);

              directions[index].rotation.z = degrees_to_radians(-90);

              directions[index].rotation.x = degrees_to_radians(-90);
            }

            directions[index].position.x = positionX;
            directions[index].position.z = positionZ;
          }
          // directions[index].rotation.y = objects[i].rotation.y;

          scene.add(directions[index]);
        }
      }
    }
  }
  if (obj) clearMeasuresLines();

  // if (is2D) {
  //   var draw = false;
  //   var typeLine = "";
  //   if (
  //     objDraggable.rotation.y == degrees_to_radians(0) &&
  //     objDraggable.position.z - objDraggable.userData.wallOffset / 1000 ==
  //       measuresZG.min + wallWidth
  //   ) {
  //     draw = true;
  //     typeLine = "back";
  //   } else if (
  //     objDraggable.rotation.y == degrees_to_radians(180) &&
  //     objDraggable.position.z + objDraggable.userData.wallOffset / 1000 ==
  //       measuresZG.max - wallWidth
  //   ) {
  //     draw = true;
  //     typeLine = "front";
  //   } else if (
  //     objDraggable.rotation.y == degrees_to_radians(90) &&
  //     objDraggable.position.x - objDraggable.userData.wallOffset / 1000 ==
  //       measuresXG.min + wallWidth
  //   ) {
  //     draw = true;
  //     typeLine = "left";
  //   } else if (
  //     objDraggable.rotation.y == degrees_to_radians(-90) &&
  //     objDraggable.position.x + objDraggable.userData.wallOffset / 1000 ==
  //       measuresXG.max - wallWidth
  //   ) {
  //     draw = true;
  //     typeLine = "right";
  //   }
  //   if (draw) {
  //     LinesAndText2D(false, typeLine);
  //   }
  //   // to2D();
  // }
  // if (planeBottom.material != null) planeBottom.material.update();

  // requestAnimationFrame(loop);
  // loop();
  // if (planeBottom.material != null) planeBottom.material.update();

  render();
}

window.applyColorCeiling = (color) => {
  textureCeiling = textureLoader.load("./colors/" + color + ".png");
  planeTop.material.map = textureCeiling;
  postData();
};

window.applyColorWalls = (color) => {
  textureWalls = textureLoader.load("./colors/" + color + ".png");
  textureWalls.wrapS = textureWalls.wrapT = RepeatWrapping;
  // textureWalls.offset.set(0.02, 0.02);
  // textureWalls.repeat.set(0.02, 0.02);
  textureWalls.anisotropy = 4;

  planeBack.material.map = textureWalls;
  planeRight.material.map = textureWalls;
  planeLeft.material.map = textureWalls;
  // planeLeft.material.map.repeat.set(
  //   (measuresXG.max * 2) / 0.9,
  //   (measuresXG.max * 2) / 0.9
  // );
};
window.applyColorFloor = (color) => {
  textureFloor = textureLoader.load("./colors/" + color + ".png");
  textureFloor.wrapS = textureFloor.wrapT = RepeatWrapping;
  // textureFloor.offset.set(0.02, 0.02);
  // textureFloor.repeat.set(0.02, 0.02);
  // textureFloor.anisotropy = 4;

  textureFloor.mapping = EquirectangularRefractionMapping;
  textureFloor.envMap = textureFloor.envMap = textureFloor;
  textureFloor.needsUpdate = true;
  textureFloor.reflectivity = 1;
  // planeBottom.material.roughnessMap = textureFloor;
  planeBottom.material.map = null;
  planeBottom.material.map = textureFloor;
  planeBottom.material.roughnessMap = textureFloor;
  // planeBottom.material.map.repeat.set(
  //   (measuresXG.max * 2) / 0.6,
  //   (measuresXG.max * 2) / 0.6
  // );
  planeBottom.material = new MeshReflectorMaterial(
    renderer,
    camera,
    scene,
    planeBottom,
    {
      resolution: 1024,
      blur: [1024, 1024],
      mixBlur: 1.0,
      mixContrast: 1.0,
      mirror: 0,
    }
  );

  planeBottom.material.setValues({
    // roughnessMap: new TextureLoader().load("/images/roughness.jpg"),
    roughnessMap: textureFloor,
    map: textureFloor,
    // normalMap: textureFloor,
    // normalScale: new Vector2(0.3, 0.3),
  });
};

window.alterDrawerType = async (drawer) => {
  if (uuidSelected.length > 0) {
    for (let index = 0; index < scene.children.length; index++) {
      if (scene.children[index].uuid === uuidSelected[0]) {
        let j;
        if (scene.children[index].name != "Element") {
          scene.children[index].userData.drawer = drawer;
        }
        break;
      }
    }
  }
};

window.applyDoor = async (door) => {
  if (uuidSelected.length > 0) {
    // for (let i = 0; i < uuidSelected.length; i++) {
    for (let index = 0; index < scene.children.length; index++) {
      if (scene.children[index].uuid === uuidSelected[0]) {
        let j;
        let needDelete = [];
        scene.children[index].userData.door = door;
        if (scene.children[index].name != "Element") {
          for (j = 0; j < objects.length; j++) {
            if (objects[j].uuid === uuidSelected[0]) {
              objects[j] = scene.children[index];
              // var typeDoor = door;
              if (door == "OP1") {
                door = "L";
              } else {
                door = "R";
              }
              // scene.children[index].userData.door = door;
              const loaderr = new GLTFLoader();
              await loaderr.load(
                //                "/obj/newObjects/" +objects[j].userData.name +" " +door +".glb",
                "https://storage.googleapis.com/kitchendata/objects/" +
                  objects[j].userData.name +
                  " " +
                  door +
                  ".glb",
                async function (gltf) {
                  let Objobject = gltf.scene;
                  // console.log("gltf ", gltf);

                  let objectSaved = gltf;
                  Objobject.name = scene.children[index].name;

                  Objobject.position.x = scene.children[index].position.x;
                  Objobject.position.y = scene.children[index].position.y;
                  Objobject.position.z = scene.children[index].position.z;
                  Objobject.userData = scene.children[index].userData;
                  Objobject.rotation.x = scene.children[index].rotation.x;
                  Objobject.rotation.y = scene.children[index].rotation.y;
                  Objobject.rotation.z = scene.children[index].rotation.z;
                  Objobject.userData.Direction = door;
                  // Objobject.userData.door = typeDoor;

                  for (let d = 0; d < Objobject.children.length; d++) {
                    Objobject.children[d].userData.uuid = Objobject.uuid;
                    if (Objobject.children[d].type == "Mesh") {
                      Objobject.children[d].material =
                        Objobject.children[d].material.clone();
                      // Objobject.children[d].material.metalness = -2;
                      if (
                        Objobject.children[d].name.match(/carcass.*/) ||
                        Objobject.children[d].name.match(/Shelf.*/)
                      ) {
                      }

                      Objobject.children[d].castShadow = true;
                      Objobject.children[d].receiveShadow = true;
                      Objobject.children[d].material.map =
                        scene.children[index].children[d].material.map;
                      Objobject.children[d].visible =
                        scene.children[index].children[d].visible;
                    }
                  }

                  Objobject.userData.name = objects[j].userData.name;
                  Objobject.name = objects[j].name;

                  // Delete Handle direction
                  for (let m = 0; m < directions.length; m++) {
                    if (
                      directions[m].uuid == objects[j].userData.uuidDirection
                    ) {
                      directions.splice(m, 1);
                      needDelete.push(
                        scene.children[index].userData.uuidDirection
                      );
                    }
                  }
                  const loaderr = new GLTFLoader();
                  let name =
                    "handle_direction_" +
                    (Objobject.userData.ElType != "opening"
                      ? door
                      : Objobject.userData.directional == "double"
                      ? "double"
                      : door);
                  loaderr.load(
                    //                    "/obj/newObjects/" + name + ".glb",
                    "https://storage.googleapis.com/kitchendata/accessories/" +
                      name +
                      ".glb",
                    function (gltf) {
                      let object = gltf.scene;
                      Objobject.userData.hasHandleDirection = true;
                      Objobject.userData.uuidDirection = object.uuid;
                      Objobject.userData.openingDir = "in";
                      object.scale.x = Objobject.userData.W;
                      object.scale.y = 0.1;
                      object.scale.z = 0.8;

                      object.name = "Handle Direction";
                      object.position.x = Objobject.position.x;
                      object.position.z =
                        Objobject.position.z +
                        (Objobject.userData.ElType == "opening"
                          ? 0.1
                          : Objobject.userData.L);
                      object.position.y = 0.3;
                      object.visible = false;
                      directions.push(object);
                      // object.rotation.x = 180;
                      scene.add(object);
                    }
                  );

                  await dell(index, j);

                  index = index - 1;

                  render();

                  Objobject.userData.objectSaved = objectSaved;
                  objects.push(Objobject);

                  scene.add(Objobject);
                  if (is2D) {
                    for (let index = 0; index < objects.length; index++) {
                      objects[index].scale.y = 0.1;
                      scene.add(objects[index]);
                    }

                    for (let index = 0; index < leftCovers.length; index++) {
                      leftCovers[index].scale.y = 0.1;
                      leftCovers[index].position.y = wallWidth * 2;
                      scene.add(leftCovers[index]);
                    }
                    for (let index = 0; index < rightCovers.length; index++) {
                      rightCovers[index].scale.y = 0.1;
                      rightCovers[index].position.y = wallWidth * 2;
                      scene.add(rightCovers[index]);
                    }
                    for (let index = 0; index < backCovers.length; index++) {
                      backCovers[index].scale.y = 0.1;
                      backCovers[index].position.y = wallWidth * 2;
                      scene.add(backCovers[index]);
                    }
                    for (let index = 0; index < wallPanels.length; index++) {
                      wallPanels[index].scale.y = 0.1;
                      wallPanels[index].position.y = 0.1;
                      wallPanels[index].scale.z = 1;
                      scene.add(wallPanels[index]);
                    }
                    for (let index = 0; index < decoStrips.length; index++) {
                      decoStrips[index].scale.y = 0.1;
                      decoStrips[index].scale.z = 1;
                      decoStrips[index].position.y = wallWidth * 2;
                      scene.add(decoStrips[index]);
                    }
                    for (let index = 0; index < Cornices.length; index++) {
                      Cornices[index].scale.y = 0.1;
                      Cornices[index].scale.z = 1;
                      Cornices[index].position.y = wallWidth * 2;
                      scene.add(Cornices[index]);
                    }
                  }

                  dragControls = new DragControls(
                    [Objobject],
                    camera,
                    renderer.domElement
                  );

                  // Delete all content of needDelete Array.
                  for (let s = 0; s < scene.children.length; s++) {
                    for (let j = 0; j < needDelete.length; j++) {
                      if (scene.children[s].uuid == needDelete[j]) {
                        scene.remove(scene.children[s]);

                        break;
                      }
                    }
                  }

                  // Finish Tops
                  let objDraggable = Objobject;
                  if (objDraggable.name == "B") {
                    (uuidsLeft = []), (uuidsRight = []);
                    let finishTopId = objDraggable.userData.finish_uuids;
                    let Id = objDraggable.uuid;
                    await finishTop(objDraggable);

                    for await (let obj of scene.children) {
                      for (
                        let m = 0;
                        m < objDraggable.userData.finish_uuids.length;
                        m++
                      ) {
                        if (obj.uuid == objDraggable.userData.finish_uuids[m]) {
                          objDraggable.userData.finish_uuids.splice(m--, 1);
                          obj.visible = false;
                          obj.children = [];
                          scene.remove(obj);
                          // break;
                        }
                      }
                    }
                    //   for (let j = 0; j < scene.children.length; j++) {
                    //     for (let m = 0; m < event.object.userData.finish_uuids.length; m++) {
                    //     if (scene.children[j].uuid == event.object.userData.finish_uuids[m]) {
                    //       event.object.userData.finish_uuids.splice(m,1);
                    //       m--;
                    //       scene.remove(scene.children[j]);
                    //       j--;
                    //     }
                    //     // }
                    //   }
                    // }
                    let widthTop = 0;

                    let remain = 0;
                    //                    await loaderr.load(
                    //                      "/obj/newObjects/finish_top.glb",
                    //                      function (gltf) {
                    await loaderr.load(
                      //                      }
                      "https://storage.googleapis.com/kitchendata/accessories/finish_top.glb",
                      function (gltf) {
                        // console.log("4");

                        let object = gltf.scene.children[0];
                        widthTop = objDraggable.userData.W;

                        if (uuidsLeft.length == 0) {
                          object.position.x = objDraggable.position.x;
                          object.position.z = objDraggable.position.z;
                        } else {
                          object.position.x =
                            uuidsLeft[uuidsLeft.length - 1].position.x;
                          object.position.z =
                            uuidsLeft[uuidsLeft.length - 1].position.z;
                        }

                        if (uuidsRight.length > 0) {
                          widthTop =
                            uuidsRight[uuidsRight.length - 1].userData.W;
                        }

                        if (objDraggable.rotation.y == degrees_to_radians(0)) {
                          /**
                           * widthTop is the distance with the filler
                           */

                          let objCheck = null;
                          if (uuidsLeft.length == 0) {
                            objCheck = objDraggable;
                          } else {
                            objCheck = uuidsLeft[uuidsLeft.length - 1];
                          }

                          if (
                            objCheck.position.x + 0.2 >
                            measuresXG.max - wallWidth
                          ) {
                            widthTop =
                              measuresXG.max - wallWidth - objCheck.position.x;
                            let remain = 0;
                            if (uuidsRight.length > 0)
                              remain =
                                uuidsRight[uuidsRight.length - 1].userData.W;
                            else remain = objDraggable.userData.W;

                            widthTop += remain;
                            object.position.x = measuresXG.max - wallWidth;
                          }

                          if (uuidsRight.length == 0) {
                            objCheck = objDraggable;
                          } else {
                            objCheck = uuidsRight[uuidsRight.length - 1];
                          }

                          if (
                            objCheck.position.x - objCheck.userData.W - 0.2 <
                            measuresXG.min + wallWidth
                          ) {
                            widthTop =
                              -measuresXG.min - wallWidth + objCheck.position.x;
                          }

                          /**
                           * Check 4 cases about the object
                           */
                          if (uuidsLeft.length == 0) {
                            if (uuidsRight.length == 0) {
                              object.scale.x =
                                object.position.x -
                                (object.position.x - widthTop);
                            } else {
                              if (
                                Math.abs(
                                  uuidsRight[uuidsRight.length - 1].position.x -
                                    uuidsRight[uuidsRight.length - 1].userData
                                      .W -
                                    measuresXG.min -
                                    wallWidth
                                ) <= 0.2
                              ) {
                                remain =
                                  -measuresXG.min -
                                  wallWidth +
                                  (uuidsRight[uuidsRight.length - 1].position
                                    .x -
                                    uuidsRight[uuidsRight.length - 1].userData
                                      .W);
                              }

                              object.scale.x =
                                object.position.x -
                                (uuidsRight[uuidsRight.length - 1].position.x -
                                  uuidsRight[uuidsRight.length - 1].userData
                                    .W) +
                                remain;
                            }
                          } else {
                            if (uuidsRight.length == 0) {
                              object.scale.x =
                                uuidsLeft[uuidsLeft.length - 1].position.x -
                                objDraggable.position.x +
                                widthTop;

                              // console.log(
                              //   "uuidsLeft[uuidsLeft.length - 1].position.x ",
                              //   uuidsLeft[uuidsLeft.length - 1].position.x
                              // );
                              // console.log(
                              //   "objDraggable.position.x   ",
                              //   objDraggable.position.x
                              // );
                              // console.log("widthTop  ", widthTop);
                              // console.log(
                              //   "objDraggable.userData.W  ",
                              //   objDraggable.userData.W
                              // );
                              // console.log("object.scale.x   ", object.scale.x);
                            } else {
                              // console.log(
                              //   "uuidsLeft[uuidsLeft.length - 1].position.x    ",
                              //   uuidsLeft[uuidsLeft.length - 1].position.x
                              // );
                              // console.log(
                              //   "uuidsRight[uuidsRight.length - 1].position.x   ",
                              //   uuidsRight[uuidsRight.length - 1].position.x
                              // );
                              // console.log("widthTop    ", widthTop);
                              object.scale.x =
                                uuidsLeft[uuidsLeft.length - 1].position.x -
                                (uuidsRight[uuidsRight.length - 1].position.x -
                                  widthTop);
                            }
                          }

                          object.scale.z = objDraggable.userData.L;
                          object.rotation.y = objDraggable.rotation.y;
                          // console.log("DDD   "  , object.scale.x);
                        } else if (
                          objDraggable.rotation.y == degrees_to_radians(180)
                        ) {
                          let objCheck = null;
                          if (uuidsLeft.length == 0) {
                            objCheck = objDraggable;
                          } else {
                            objCheck = uuidsLeft[uuidsLeft.length - 1];
                          }

                          if (
                            objCheck.position.x - 0.2 <
                            measuresXG.min + wallWidth
                          ) {
                            widthTop =
                              objCheck.position.x - measuresXG.min - wallWidth;
                            let remain = 0;
                            if (uuidsRight.length > 0)
                              remain =
                                uuidsRight[uuidsRight.length - 1].userData.W;
                            else remain = objDraggable.userData.W;

                            widthTop += remain;

                            object.position.x = measuresXG.min + wallWidth;
                          }

                          if (uuidsRight.length == 0) {
                            objCheck = objDraggable;
                          } else {
                            objCheck = uuidsRight[uuidsRight.length - 1];
                          }

                          if (
                            objCheck.position.x + objCheck.userData.W + 0.2 >
                            measuresXG.max - wallWidth
                          ) {
                            widthTop =
                              measuresXG.max - wallWidth - objCheck.position.x;
                          }

                          if (uuidsLeft.length == 0) {
                            if (uuidsRight.length == 0) {
                              object.scale.x =
                                object.position.x -
                                (object.position.x + widthTop);
                            } else {
                              if (
                                measuresXG.max -
                                  wallWidth -
                                  (uuidsRight[uuidsRight.length - 1].position
                                    .x +
                                    uuidsRight[uuidsRight.length - 1].userData
                                      .W) <=
                                0.2
                              ) {
                                remain =
                                  measuresXG.max -
                                  wallWidth -
                                  (uuidsRight[uuidsRight.length - 1].position
                                    .x +
                                    uuidsRight[uuidsRight.length - 1].userData
                                      .W);
                              }
                              object.scale.x =
                                object.position.x -
                                (uuidsRight[uuidsRight.length - 1].position.x +
                                  uuidsRight[uuidsRight.length - 1].userData
                                    .W) -
                                remain;
                              // remain;
                            }
                          } else {
                            if (uuidsRight.length == 0) {
                              object.scale.x =
                                uuidsLeft[uuidsLeft.length - 1].position.x -
                                (objDraggable.position.x + widthTop);
                            } else {
                              object.scale.x =
                                uuidsLeft[uuidsLeft.length - 1].position.x -
                                uuidsRight[uuidsRight.length - 1].position.x -
                                widthTop;
                            }
                          }
                          object.position.z =
                            object.position.z - objDraggable.userData.L;
                          object.scale.z = objDraggable.userData.L;
                        } else if (
                          objDraggable.rotation.y == degrees_to_radians(90)
                        ) {
                          let objCheck = null;
                          if (uuidsLeft.length == 0) {
                            objCheck = objDraggable;
                          } else {
                            objCheck = uuidsLeft[uuidsLeft.length - 1];
                          }

                          if (
                            objCheck.position.z - 0.2 <
                            measuresZG.min + wallWidth
                          ) {
                            widthTop =
                              objCheck.position.z - measuresZG.min - wallWidth;
                            let remain = 0;

                            if (uuidsRight.length > 0)
                              remain =
                                uuidsRight[uuidsRight.length - 1].userData.W;
                            else remain = objDraggable.userData.W;

                            widthTop += remain;

                            object.position.z = measuresZG.min + wallWidth;
                          }

                          if (uuidsRight.length == 0) {
                            objCheck = objDraggable;
                          } else {
                            objCheck = uuidsRight[uuidsRight.length - 1];
                          }

                          if (
                            objCheck.position.z + objCheck.userData.W + 0.2 >
                            measuresZG.max - wallWidth
                          ) {
                            widthTop =
                              measuresZG.max - wallWidth - objCheck.position.z;
                          }

                          if (uuidsLeft.length == 0) {
                            if (uuidsRight.length == 0) {
                              object.scale.z =
                                object.position.z -
                                (object.position.z + widthTop);
                            } else {
                              if (
                                measuresZG.max -
                                  wallWidth -
                                  (uuidsRight[uuidsRight.length - 1].position
                                    .z +
                                    uuidsRight[uuidsRight.length - 1].userData
                                      .W) <=
                                0.2
                              ) {
                                remain =
                                  measuresZG.max -
                                  wallWidth -
                                  (uuidsRight[uuidsRight.length - 1].position
                                    .z +
                                    uuidsRight[uuidsRight.length - 1].userData
                                      .W);
                              }
                              object.scale.z =
                                object.position.z -
                                (uuidsRight[uuidsRight.length - 1].position.z +
                                  uuidsRight[uuidsRight.length - 1].userData
                                    .W) -
                                remain;
                            }
                          } else {
                            if (uuidsRight.length == 0) {
                              object.scale.z =
                                uuidsLeft[uuidsLeft.length - 1].position.z -
                                (objDraggable.position.z + widthTop);
                            } else {
                              object.scale.z =
                                uuidsLeft[uuidsLeft.length - 1].position.z -
                                (uuidsRight[uuidsRight.length - 1].position.z +
                                  widthTop);
                            }
                          }

                          object.rotation.y =
                            objDraggable.rotation.y + degrees_to_radians(90);
                          object.scale.x = objDraggable.userData.L;
                        }
                        // -90 degree
                        else {
                          let objCheck = null;
                          if (uuidsLeft.length == 0) {
                            objCheck = objDraggable;
                          } else {
                            objCheck = uuidsLeft[uuidsLeft.length - 1];
                          }
                          if (
                            objCheck.position.z + 0.2 >
                            measuresZG.max - wallWidth
                          ) {
                            widthTop =
                              measuresZG.max - wallWidth - objCheck.position.z;
                            let remain = 0;

                            if (uuidsRight.length > 0)
                              remain =
                                uuidsRight[uuidsRight.length - 1].userData.W;
                            else remain = objDraggable.userData.W;

                            widthTop += remain;

                            object.position.z = measuresZG.max - wallWidth;
                          }

                          if (uuidsRight.length == 0) {
                            objCheck = objDraggable;
                          } else {
                            objCheck = uuidsRight[uuidsRight.length - 1];
                          }

                          if (
                            objCheck.position.z - objCheck.userData.W - 0.2 <
                            measuresZG.min + wallWidth
                          ) {
                            widthTop =
                              objCheck.position.z + measuresZG.max - wallWidth;
                            // object.position.z = measures.length/2;
                          }

                          if (uuidsLeft.length == 0) {
                            if (uuidsRight.length == 0) {
                              object.scale.z =
                                object.position.z -
                                (object.position.z + widthTop);
                              object.scale.x = objDraggable.userData.L;
                              object.rotation.y =
                                objDraggable.rotation.y +
                                degrees_to_radians(90);
                            } else {
                              if (
                                uuidsRight[uuidsRight.length - 1].position.z -
                                  uuidsRight[uuidsRight.length - 1].userData.W -
                                  measuresZG.min -
                                  wallWidth <=
                                0.2
                              ) {
                                remain =
                                  uuidsRight[uuidsRight.length - 1].position.z -
                                  uuidsRight[uuidsRight.length - 1].userData.W -
                                  measuresZG.min -
                                  wallWidth;
                              }
                              object.scale.x =
                                object.position.z -
                                (uuidsRight[uuidsRight.length - 1].position.z -
                                  uuidsRight[uuidsRight.length - 1].userData
                                    .W) +
                                remain;
                              // remain;
                              object.scale.z = objDraggable.userData.L;
                              object.rotation.y = objDraggable.rotation.y;
                            }
                          } else {
                            if (uuidsRight.length == 0) {
                              object.scale.x =
                                uuidsLeft[uuidsLeft.length - 1].position.z -
                                (objDraggable.position.z - widthTop);
                              object.scale.z = objDraggable.userData.L;
                              object.rotation.y = objDraggable.rotation.y;
                            } else {
                              object.scale.x =
                                uuidsLeft[uuidsLeft.length - 1].position.z -
                                (uuidsRight[uuidsRight.length - 1].position.z -
                                  widthTop);

                              object.scale.z = objDraggable.userData.L;
                              object.rotation.y = objDraggable.rotation.y;
                            }
                          }
                        }

                        // if (
                        //   objDraggable.rotation.y == degrees_to_radians(0)
                        // ) {
                        //   if (object.position.x + 0.2 > measuresXG.max) {
                        //     // console.log("FFF");
                        //     widthTop =
                        //       measuresXG.max -
                        //       object.position.x +
                        //       objDraggable.userData.W;
                        //     object.position.x = measuresXG.max;
                        //   } else if (
                        //     object.position.x -
                        //       objDraggable.userData.W -
                        //       0.2 <
                        //     measuresXG.min
                        //   ) {
                        //     // console.log("DDD");

                        //     widthTop =
                        //       measuresXG.max - wallWidth + object.position.x;

                        //     // object.position.x = - measures.width/2;
                        //   }

                        //   if (uuidsLeft.length == 0) {
                        //     if (uuidsRight.length == 0) {
                        //       object.scale.x =
                        //         object.position.x -
                        //         (object.position.x - widthTop);
                        //     } else {
                        //       if (
                        //         Math.abs(
                        //           uuidsRight[uuidsRight.length - 1].position
                        //             .x -
                        //             uuidsRight[uuidsRight.length - 1].userData
                        //               .W -
                        //             measuresXG.min
                        //         ) <= 0.2
                        //       ) {
                        //         remain =
                        //           -measuresXG.min +
                        //           (uuidsRight[uuidsRight.length - 1].position
                        //             .x -
                        //             uuidsRight[uuidsRight.length - 1].userData
                        //               .W);
                        //       }
                        //       // console.log("WidthTop  " , widthTop);
                        //       // console.log(" object.position.x  ",  object.position.x);
                        //       // console.log(" measuresXG.max   ",  uuidsRight[uuidsRight.length - 1].position.x);
                        //       // console.log(" object.position.x   ",   uuidsRight[uuidsRight.length - 1].userData.W );
                        //       object.scale.x =
                        //         object.position.x -
                        //         (uuidsRight[uuidsRight.length - 1].position
                        //           .x -
                        //           uuidsRight[uuidsRight.length - 1].userData
                        //             .W) +
                        //         remain;

                        //       // object.scale.x = widthTop ;
                        //     }
                        //   } else {
                        //     if (uuidsRight.length == 0) {
                        //       object.scale.x =
                        //         uuidsLeft[uuidsLeft.length - 1].position.x -
                        //         objDraggable.position.x +
                        //         widthTop;
                        //       // console.log('uuidsLeft[uuidsLeft.length - 1].position.x  ' , uuidsLeft[uuidsLeft.length - 1].position.x );
                        //       // console.log('object.position.x   ' , objDraggable.position.x  );
                        //       // console.log('widthTop  ' , widthTop  );
                        //     } else {
                        //       object.scale.x =
                        //         uuidsLeft[uuidsLeft.length - 1].position.x -
                        //         (uuidsRight[uuidsRight.length - 1].position
                        //           .x -
                        //           uuidsRight[uuidsRight.length - 1].userData
                        //             .W);
                        //     }
                        //   }
                        //   object.scale.z = objDraggable.userData.L;
                        //   object.rotation.y = objDraggable.rotation.y;
                        //   // console.log("DDD   "  , object.scale.x);
                        // } else if (
                        //   objDraggable.rotation.y == degrees_to_radians(180)
                        // ) {
                        //   if (object.position.x - 0.2 < measuresXG.min) {
                        //     widthTop =
                        //       object.position.x +
                        //       measuresXG.max +
                        //       objDraggable.userData.W;
                        //     object.position.x = measuresXG.min;
                        //   } else if (
                        //     object.position.x +
                        //       objDraggable.userData.W +
                        //       0.2 >
                        //     measuresXG.max
                        //   ) {
                        //     widthTop = measuresXG.max - object.position.x;
                        //     // object.position.x = measures.width/2;
                        //   }
                        //   if (uuidsLeft.length == 0) {
                        //     if (uuidsRight.length == 0) {
                        //       object.scale.x =
                        //         object.position.x -
                        //         (object.position.x + widthTop);
                        //     } else {
                        //       if (
                        //         measuresXG.max -
                        //           (uuidsRight[uuidsRight.length - 1].position
                        //             .x +
                        //             uuidsRight[uuidsRight.length - 1].userData
                        //               .W) <=
                        //         0.2
                        //       ) {
                        //         remain =
                        //           measuresXG.max -
                        //           (uuidsRight[uuidsRight.length - 1].position
                        //             .x +
                        //             uuidsRight[uuidsRight.length - 1].userData
                        //               .W);
                        //       }
                        //       object.scale.x =
                        //         object.position.x -
                        //         (uuidsRight[uuidsRight.length - 1].position
                        //           .x +
                        //           uuidsRight[uuidsRight.length - 1].userData
                        //             .W) -
                        //         remain;
                        //     }
                        //   } else {
                        //     if (uuidsRight.length == 0) {
                        //       object.scale.x =
                        //         uuidsLeft[uuidsLeft.length - 1].position.x -
                        //         (objDraggable.position.x + widthTop);
                        //     } else {
                        //       object.scale.x =
                        //         uuidsLeft[uuidsLeft.length - 1].position.x -
                        //         (uuidsRight[uuidsRight.length - 1].position
                        //           .x +
                        //           uuidsRight[uuidsRight.length - 1].userData
                        //             .W);
                        //     }
                        //   }
                        //   object.position.z =
                        //     object.position.z - objDraggable.userData.L;
                        //   object.scale.z = objDraggable.userData.L;
                        // } else if (
                        //   objDraggable.rotation.y == degrees_to_radians(90)
                        // ) {
                        //   if (object.position.z - 0.2 < measuresZG.min) {
                        //     widthTop =
                        //       object.position.z +
                        //       measuresZG.max +
                        //       objDraggable.userData.W;
                        //     object.position.z = measuresZG.min;
                        //   } else if (
                        //     object.position.z +
                        //       objDraggable.userData.W +
                        //       0.2 >
                        //     measuresZG.max
                        //   ) {
                        //     widthTop = measuresZG.max - object.position.z;
                        //     // object.position.z = measures.length/2;
                        //   }
                        //   if (uuidsLeft.length == 0) {
                        //     if (uuidsRight.length == 0) {
                        //       object.scale.z =
                        //         object.position.z -
                        //         (object.position.z + widthTop);
                        //     } else {
                        //       if (
                        //         measuresZG.max -
                        //           (uuidsRight[uuidsRight.length - 1].position
                        //             .z +
                        //             uuidsRight[uuidsRight.length - 1].userData
                        //               .W) <=
                        //         0.2
                        //       ) {
                        //         remain =
                        //           measuresZG.max -
                        //           (uuidsRight[uuidsRight.length - 1].position
                        //             .z +
                        //             uuidsRight[uuidsRight.length - 1].userData
                        //               .W);
                        //         // console.log("Remain  ", remain);
                        //       }
                        //       object.scale.z =
                        //         object.position.z -
                        //         (uuidsRight[uuidsRight.length - 1].position
                        //           .z +
                        //           uuidsRight[uuidsRight.length - 1].userData
                        //             .W) -
                        //         remain;
                        //     }
                        //   } else {
                        //     if (uuidsRight.length == 0) {
                        //       object.scale.z =
                        //         uuidsLeft[uuidsLeft.length - 1].position.z -
                        //         (objDraggable.position.z + widthTop);
                        //     } else {
                        //       object.scale.z =
                        //         uuidsLeft[uuidsLeft.length - 1].position.z -
                        //         (uuidsRight[uuidsRight.length - 1].position
                        //           .z +
                        //           uuidsRight[uuidsRight.length - 1].userData
                        //             .W);
                        //     }
                        //   }
                        //   object.rotation.y =
                        //     objDraggable.rotation.y + degrees_to_radians(90);
                        //   object.position.x = object.position.x;
                        //   object.scale.x = objDraggable.userData.L;
                        // } else {
                        //   if (object.position.z + 0.2 > measuresZG.max) {
                        //     widthTop =
                        //       measuresZG.max -
                        //       object.position.z +
                        //       objDraggable.userData.W;
                        //     object.position.z = measuresZG.max;
                        //   } else if (
                        //     object.position.z -
                        //       objDraggable.userData.W -
                        //       0.2 <
                        //     measuresZG.min
                        //   ) {
                        //     widthTop = object.position.z + measuresZG.max;
                        //     // object.position.z = measures.length/2;
                        //   }
                        //   if (uuidsLeft.length == 0) {
                        //     if (uuidsRight.length == 0) {
                        //       object.scale.z =
                        //         object.position.z -
                        //         (object.position.z + widthTop);
                        //       object.scale.x = objDraggable.userData.L;
                        //       object.rotation.y =
                        //         objDraggable.rotation.y +
                        //         degrees_to_radians(90);
                        //     } else {
                        //       if (
                        //         uuidsRight[uuidsRight.length - 1].position.z -
                        //           uuidsRight[uuidsRight.length - 1].userData
                        //             .W -
                        //           measuresZG.min <=
                        //         0.2
                        //       ) {
                        //         remain =
                        //           uuidsRight[uuidsRight.length - 1].position
                        //             .z -
                        //           uuidsRight[uuidsRight.length - 1].userData
                        //             .W -
                        //           measuresZG.min;
                        //       }
                        //       object.scale.x =
                        //         object.position.z -
                        //         (uuidsRight[uuidsRight.length - 1].position
                        //           .z -
                        //           uuidsRight[uuidsRight.length - 1].userData
                        //             .W) +
                        //         remain;
                        //       object.scale.z = objDraggable.userData.L;
                        //       object.rotation.y = objDraggable.rotation.y;
                        //     }
                        //   } else {
                        //     if (uuidsRight.length == 0) {
                        //       object.scale.x =
                        //         uuidsLeft[uuidsLeft.length - 1].position.z -
                        //         (objDraggable.position.z - widthTop);
                        //       object.scale.z = objDraggable.userData.L;
                        //       object.rotation.y = objDraggable.rotation.y;
                        //     } else {
                        //       object.scale.x =
                        //         uuidsLeft[uuidsLeft.length - 1].position.z -
                        //         (uuidsRight[uuidsRight.length - 1].position
                        //           .z -
                        //           uuidsRight[uuidsRight.length - 1].userData
                        //             .W);
                        //       object.scale.z = objDraggable.userData.L;
                        //       object.rotation.y = objDraggable.rotation.y;
                        //     }
                        //   }
                        // }

                        object.position.y =
                          objDraggable.position.y +
                          objDraggable.userData.H +
                          0.1;

                        textureWorktops = textureLoader.load(
                          "./colors/" + worktopsColor + ".png"
                        );
                        objDraggable.userData.worktops = worktopsColor;
                        textureWorktops.wrapS = textureWorktops.wrapT =
                          RepeatWrapping;
                        textureWorktops.offset.set(0.02, 0.02);
                        textureWorktops.repeat.set(0.02, 0.02);
                        object.material.clone();
                        object.material.metalness = -0.1;
                        object.material.map = textureWorktops;

                        // object.material.map.repeat.set(8, 8);
                        // object.material.map.repeat.set(
                        //   ((object.scale.x / 2) * 2) / 0.05,
                        //   ((object.scale.z / 2) * 2) / 0.05
                        // );
                        object.castShadow = true;
                        object.receiveShadow = true;

                        // object.userData.uuidObj = objDraggable.uuid;
                        // if (is2D) object.visible = false;

                        object.name = "TOP";
                        object.scale.x = object.scale.x / 2;
                        object.scale.z = object.scale.z / 2;
                        if (emptying.length > 0) {
                          // console.log("object  ss", object);
                          // console.log("emptying[0] ", emptying[0]);
                          let meshB = new Mesh(
                            new BoxGeometry(
                              emptying[0].userData.sinkWidth - 0.03,
                              0.55,
                              0.036
                            ),
                            new MeshStandardMaterial({
                              color: new Color("#FF5512"),
                            })
                          );
                          //  console.log("position  ",meshB.position);
                          let x = 0;
                          let z = 0;
                          if (
                            objDraggable.rotation.y == degrees_to_radians(0)
                          ) {
                            x =
                              emptying[0].position.x -
                              emptying[0].userData.W / 2;
                            z = emptying[0].position.z + 0.55 / 2;
                            meshB.rotation.z = degrees_to_radians(90);
                            meshB.rotation.x = degrees_to_radians(90);
                          } else if (
                            objDraggable.rotation.y == degrees_to_radians(180)
                          ) {
                            x =
                              emptying[0].position.x +
                              emptying[0].userData.W / 2;
                            z = emptying[0].position.z - 0.55 / 2;
                            meshB.rotation.x = degrees_to_radians(-90);
                            meshB.rotation.z = degrees_to_radians(-90);
                          } else if (
                            objDraggable.rotation.y == degrees_to_radians(90)
                          ) {
                            z =
                              emptying[0].position.z +
                              emptying[0].userData.W / 2;
                            x = emptying[0].position.x + 0.55 / 2;
                            meshB.rotation.z = degrees_to_radians(-90);
                            meshB.rotation.x = degrees_to_radians(90);
                          } else if (
                            objDraggable.rotation.y == degrees_to_radians(-90)
                          ) {
                            z =
                              emptying[0].position.z -
                              emptying[0].userData.W / 2;
                            x = emptying[0].position.x - 0.55 / 2;
                            meshB.rotation.z = degrees_to_radians(90);
                            meshB.rotation.x = degrees_to_radians(-90);
                          }
                          meshB.position.add(
                            new Vector3(x, object.position.y + 0.018, z)
                          );

                          meshB.updateMatrix();
                          object.updateMatrix();

                          let bspA = CSG.default.fromMesh(object);
                          let bspB = CSG.default.fromMesh(meshB);
                          let bspResult = "";

                          if (objDraggable.rotation.y == degrees_to_radians(0))
                            bspResult = bspA.subtract(bspB);
                          else bspResult = bspA.union(bspB);

                          if (
                            objDraggable.rotation.y ==
                              degrees_to_radians(-90) &&
                            emptying.length > 1
                          )
                            bspResult = bspA.subtract(bspB);

                          for (let b = 1; b < emptying.length; b++) {
                            let meshB = new Mesh(
                              new BoxGeometry(
                                emptying[b].userData.sinkWidth - 0.03,
                                0.55,
                                0.036
                              ),
                              new MeshStandardMaterial({
                                color: new Color("#FF5512"),
                              })
                            );
                            // scene.add(meshB);

                            if (
                              objDraggable.rotation.y == degrees_to_radians(0)
                            ) {
                              x =
                                emptying[b].position.x -
                                emptying[b].userData.W / 2;
                              z = emptying[b].position.z + 0.55 / 2;
                              meshB.rotation.z = degrees_to_radians(90);
                              meshB.rotation.x = degrees_to_radians(90);
                            } else if (
                              objDraggable.rotation.y == degrees_to_radians(180)
                            ) {
                              x =
                                emptying[b].position.x +
                                emptying[b].userData.W / 2;
                              z = emptying[b].position.z - 0.55 / 2;
                              meshB.rotation.x = degrees_to_radians(-90);
                            } else if (
                              objDraggable.rotation.y == degrees_to_radians(90)
                            ) {
                              z =
                                emptying[b].position.z +
                                emptying[b].userData.W / 2;
                              x = emptying[b].position.x + 0.55 / 2;
                              meshB.rotation.x = degrees_to_radians(90);
                            } else if (
                              objDraggable.rotation.y == degrees_to_radians(-90)
                            ) {
                              z =
                                emptying[b].position.z -
                                emptying[b].userData.W / 2;
                              x = emptying[b].position.x - 0.55 / 2;
                              meshB.rotation.z = degrees_to_radians(90);
                              meshB.rotation.x = degrees_to_radians(-90);
                            }

                            meshB.position.add(
                              new Vector3(x, object.position.y + 0.018, z)
                            );

                            meshB.updateMatrix();
                            let bspB = CSG.default.fromMesh(meshB);

                            if (
                              objDraggable.rotation.y ==
                                degrees_to_radians(0) ||
                              objDraggable.rotation.y == degrees_to_radians(-90)
                            )
                              bspResult = bspResult.subtract(bspB);
                            else bspResult = bspResult.union(bspB);
                          }
                          // object.userData.uuid = object.uuid;
                          object.material.clone();
                          object.material.metalness = -0.1;
                          object.material.map = textureWorktops;

                          // object.material.map.repeat.set(8, 8);

                          object.castShadow = true;
                          object.receiveShadow = true;
                          object = CSG.default.toMesh(
                            bspResult,
                            object.matrix,
                            object.material
                          );
                          console.log("ddcobject ", object);
                        }

                        object.userData.uuid = object.uuid;

                        object.name = "Top";
                        objDraggable.userData.finish_uuids = [];
                        objDraggable.userData.finish_uuids.push(object.uuid);
                        for (let index = 0; index < uuidsLeft.length; index++) {
                          for (let j = 0; j < scene.children.length; j++) {
                            for (
                              let m = 0;
                              m < objDraggable.userData.finish_uuids.length;
                              m++
                            ) {
                              if (
                                scene.children[j].uuid ==
                                uuidsLeft[index].userData.finish_uuids[m]
                              ) {
                                uuidsLeft[index].userData.finish_uuids.splice(
                                  m--,
                                  1
                                );
                                scene.children[j].children = [];
                                scene.remove(scene.children[j--]);
                              }
                              // }
                            }
                          }
                          uuidsLeft[index].userData.finish_uuids = [];
                          uuidsLeft[index].userData.finish_uuids.push(
                            object.uuid
                          );
                        }
                        for (
                          let index = 0;
                          index < uuidsRight.length;
                          index++
                        ) {
                          for (let j = 0; j < scene.children.length; j++) {
                            for (
                              let m = 0;
                              m < objDraggable.userData.finish_uuids.length;
                              m++
                            ) {
                              if (
                                scene.children[j].uuid ==
                                uuidsRight[index].userData.finish_uuids
                              ) {
                                uuidsRight[index].userData.finish_uuids.splice(
                                  m--,
                                  1
                                );
                                scene.children[j].children = [];
                                scene.remove(scene.children[j--]);
                              }
                            }
                          }
                          uuidsRight[index].userData.finish_uuids = [];
                          uuidsRight[index].userData.finish_uuids.push(
                            object.uuid
                          );
                        }
                        object.userData.rotationY = objDraggable.rotation.y;

                        if (is2D) object.visible = false;

                        finishTops.push(object);
                        // console.log("object.scale.x   ", object.scale.x);
                        // console.log("object.scale.y   ", object.scale.y);
                        // console.log("object.scale.z   ", object.scale.z);
                        // object.uuid.type='filler';
                        scene.add(object);
                      }
                    );
                  }

                  dragControls.transformGroup = true;
                  dragControls.addEventListener("drag", (event) => {
                    drag(event.object);
                  });
                  dragControls.rotateSpeed = 2.5;
                  dragControls.addEventListener(
                    "dragstart",
                    async function (event) {
                      await dragstart(event);
                    }
                  );
                  dragControls.addEventListener(
                    "dragend",
                    async function (event) {
                      await dragend(event);
                      render();
                    }
                  );
                }
              );
              break;
            }
          }
          postData();
          render();
        }
        break;
      }
    }
  }
};

// Over operation
window.applyOven = async (ovenWidth) => {
  if (uuidSelected.length > 0) {
    for (let i = 0; i < uuidSelected.length; i++) {
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].uuid === uuidSelected[i]) {
          let idDelete = null;
          let Objobject = scene.children[index];
          if (scene.children[index].userData.W >= 0.6) {
            if (scene.children[index].userData.W == 0.6 && ovenWidth == 750) {
              alert(
                "Not allow adding oven in width 750 to cabinet in width 600"
              );
            } else {
              if (scene.children[index].userData.hasOven) {
                scene.children[index].userData.hasOven = false;
                // Delete old oven.
                for (let j = 0; j < ovens.length; j++) {
                  if (
                    ovens[j].uuid == scene.children[index].userData.uuidOven
                  ) {
                    ovens.splice(j, 1);
                    idDelete = scene.children[index].userData.uuidOven;
                    break;
                  }
                }
              }
              if (ovenWidth != 0 && !scene.children[index].userData.hasSink) {
                const loaderr = new GLTFLoader();
                //                loaderr.load("/obj/newObjects/oven.glb", function (gltf) {
                loaderr.load(
                  "https://storage.googleapis.com/kitchendata/accessories/oven.glb",
                  function (gltf) {
                    let object = gltf.scene;
                    Objobject.userData.hasOven = true;
                    Objobject.userData.uuidOven = object.uuid;
                    Objobject.userData.ovenWidth = ovenWidth / 1000;
                    object.scale.x = ovenWidth / 1000;
                    object.scale.y = 1;
                    object.scale.z = 0.55;

                    let startPositionX =
                      (Objobject.userData.W - ovenWidth / 1000) / 2;
                    let startPositionZ = (Objobject.userData.L - 0.55) / 2;

                    object.position.y =
                      Objobject.position.y + Objobject.userData.H + 0.136;
                    object.position.x = Objobject.position.x + startPositionX;
                    object.position.z = Objobject.position.z + startPositionZ;

                    object.rotation.y = Objobject.rotation.y;

                    if (Objobject.rotation.y == degrees_to_radians(0)) {
                      object.position.x = Objobject.position.x - startPositionX;
                      object.position.z = Objobject.position.z + startPositionZ;
                    } else if (
                      Objobject.rotation.y == degrees_to_radians(180)
                    ) {
                      object.position.x = Objobject.position.x + startPositionX;
                      object.position.z = Objobject.position.z - startPositionZ;
                    } else if (Objobject.rotation.y == degrees_to_radians(90)) {
                      object.position.x = Objobject.position.x + startPositionZ;
                      object.position.z = Objobject.position.z + startPositionX;
                    } else {
                      object.position.x = Objobject.position.x - startPositionZ;
                      object.position.z = Objobject.position.z - startPositionX;
                    }

                    // scene.add(new RectAreaLightHelper(Light));

                    for (
                      let t = 0;
                      t < object.children[0].children.length;
                      t++
                    ) {
                      if (object.children[0].children[t].type == "Mesh") {
                        object.children[0].children[t].userData.uuid =
                          object.uuid;
                        object.children[0].children[t].material.metalness = 0;
                        object.children[0].children[t].material.map = texture;
                        object.children[0].children[t].castShadow = true;
                        object.children[0].children[t].receiveShadow = true;
                      }
                    }
                    object.userData.ovenWidth = ovenWidth / 1000;
                    object.name = "Oven";
                    // object.userData.rotationY  = Objobject.rotation.y;
                    object.userData.positionZ = Objobject.position.z;
                    object.userData.positionX = Objobject.position.x;
                    scene.add(object);
                    ovens.push(object);
                    // decoStrips.push(object);
                    // console.log("scene ", scene);
                  }
                );
              }
            }
          } else {
            alert(
              "Not allowed adding oven to cabinet has width less than 600 mm"
            );
          }
          if (idDelete) {
            for (let d = 0; d < scene.children.length; d++) {
              if (scene.children[d].uuid === idDelete) {
                scene.remove(scene.children[d]);
                break;
              }
            }
          }
          break;
        }
      }
    }
  }
};

// Sink operation
window.applySink = async (sinkWidth) => {
  if (uuidSelected.length > 0) {
    for (let i = 0; i < uuidSelected.length; i++) {
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].uuid === uuidSelected[i]) {
          let idDelete = null;
          let Objobject = scene.children[index];
          if (scene.children[index].userData.W >= 0.6) {
            if (scene.children[index].userData.W == 0.6 && sinkWidth == 750) {
              alert(
                "Not allow adding sink in width 750 to cabinet in width 600"
              );
            } else {
              if (scene.children[index].userData.hasSink) {
                scene.children[index].userData.hasSink = false;
                // Delete old sink.
                for (let j = 0; j < sinks.length; j++) {
                  if (
                    sinks[j].uuid == scene.children[index].userData.uuidSink
                  ) {
                    sinks.splice(j, 1);
                    idDelete = scene.children[index].userData.uuidSink;
                    break;
                  }
                }
              }
              if (sinkWidth != 0 && !scene.children[index].userData.hasOven) {
                const loaderr = new GLTFLoader();
                //                loaderr.load("/obj/newObjects/sink.glb", function (gltf) {
                loaderr.load(
                  "https://storage.googleapis.com/kitchendata/accessories/sink.glb",
                  function (gltf) {
                    let object = gltf.scene;
                    // console.log("sink ", object);
                    Objobject.userData.hasSink = true;
                    Objobject.userData.uuidSink = object.uuid;
                    Objobject.userData.sinkWidth = sinkWidth / 1000;
                    object.scale.x = sinkWidth / 1000;
                    object.scale.y = 1;
                    object.scale.z = 0.55;

                    let startPositionX =
                      (Objobject.userData.W - sinkWidth / 1000) / 2;
                    let startPositionZ = (Objobject.userData.L - 0.55) / 2;

                    object.position.y =
                      Objobject.position.y + Objobject.userData.H + 0.056;
                    object.position.x = Objobject.position.x + startPositionX;
                    object.position.z = Objobject.position.z + startPositionZ;

                    object.rotation.y = Objobject.rotation.y;

                    if (Objobject.rotation.y == degrees_to_radians(0)) {
                      object.position.x = Objobject.position.x - startPositionX;
                      object.position.z = Objobject.position.z + startPositionZ;
                    } else if (
                      Objobject.rotation.y == degrees_to_radians(180)
                    ) {
                      object.position.x = Objobject.position.x + startPositionX;
                      object.position.z = Objobject.position.z - startPositionZ;
                    } else if (Objobject.rotation.y == degrees_to_radians(90)) {
                      object.position.x = Objobject.position.x + startPositionZ;
                      object.position.z = Objobject.position.z + startPositionX;
                    } else {
                      object.position.x = Objobject.position.x - startPositionZ;
                      object.position.z = Objobject.position.z - startPositionX;
                    }

                    for (let t = 0; t < object.children.length; t++) {
                      if (object.children[t].type == "Mesh") {
                        object.children[t].userData.uuid = object.uuid;
                        object.children[t].material.metalness = 0;
                        object.children[t].material.map = texture;
                        object.children[t].castShadow = true;
                        object.children[t].receiveShadow = true;
                      }
                    }
                    object.userData.sinkWidth = sinkWidth / 1000;
                    Objobject.userData.sinkWidth = sinkWidth / 1000;
                    // if (emptying.length > 0) {
                    //   emptying[emptying.length - 1].userData.sinkWidth =
                    //     sinkWidth / 1000;
                    // }
                    object.name = "Sink";
                    // object.userData.rotationY  = Objobject.rotation.y;
                    object.userData.positionZ = Objobject.position.z;
                    object.userData.positionX = Objobject.position.x;
                    scene.add(object);
                    sinks.push(object);

                    // console.log("scene ", scene);
                  }
                );
              }
            }
          } else {
            alert(
              "Not allowed adding sink to cabinet has width less than 600 mm"
            );
          }
          if (idDelete) {
            for (let d = 0; d < scene.children.length; d++) {
              if (scene.children[d].uuid === idDelete) {
                scene.remove(scene.children[d]);
                break;
              }
            }
          }
          break;
        }
      }
    }
    // uuidSelected = [];
    // for (let k = 0; k < scene.children.length; k++) {
    //   if (scene.children[k].name === "SelectedObject") {
    //     scene.remove(scene.children[k]);
    //     k -= 1;
    //   }
    // }
  }
};

async function dell(index, j) {
  let needDelete = [];
  // for (let j = 0; j < finishTops.length; j++) {
  //   for (
  //     let m = 0;
  //     m < scene.children[index].userData.finish_uuids.length;
  //     m++
  //   ) {
  //     if (
  //       finishTops[j].uuid ==
  //       scene.children[index].userData.finish_uuids[m]
  //     ) {
  //       finishTops.splice(j, 1);
  //       j--;
  //       break;
  //     }
  //   }
  // }

  // for await (let obj of scene.children) {
  //   for (
  //     let m = 0;
  //     m < scene.children[index].userData.finish_uuids.length;
  //     m++
  //   ) {
  //     if (obj.uuid == scene.children[index].userData.finish_uuids[m]) {
  //       scene.children[index].userData.finish_uuids.splice(m--, 1);
  //       scene.remove(obj);
  //       break;
  //     }
  //   }
  // }

  // scene.children[index].userData.finish_uuids = [];

  // uuids = [];

  /**
   * End delete wotktops
   */

  // // Delete deco strip and it's light.
  // if (scene.children[index].userData.hasDecoStrip == true) {
  //   scene.children[index].userData.hasDecoStrip = false;
  //   // Delete Deco strip
  //   for (let j = 0; j < decoStrips.length; j++) {
  //     if (
  //       decoStrips[j].uuid ==
  //       scene.children[index].userData.uuidDecoStrip
  //     ) {
  //       decoStrips.splice(j, 1);
  //       needDelete.push(scene.children[index].userData.uuidDecoStrip);
  //     }
  //   }
  //   // Delete Light of deco strip
  //   for (let j = 0; j < lightObjects.length; j++) {
  //     if (
  //       lightObjects[j].uuid == scene.children[index].userData.uuidLight
  //     ) {
  //       lightObjects.splice(j, 1);
  //       needDelete.push(scene.children[index].userData.uuidLight);
  //     }
  //   }
  // }

  // // Delete wall panel.
  // if (scene.children[index].userData.hasWallPanel == true) {
  //   scene.children[index].userData.hasWallPanel = false;
  //   // Delete Wall Panel
  //   for (let j = 0; j < wallPanels.length; j++) {
  //     if (
  //       wallPanels[j].uuid ==
  //       scene.children[index].userData.uuidWallPanel
  //     ) {
  //       wallPanels.splice(j, 1);
  //       needDelete.push(scene.children[index].userData.uuidWallPanel);
  //     }
  //   }
  // }

  // // Delete cornice and it's light.
  // if (scene.children[index].userData.hasCornice == true) {
  //   scene.children[index].userData.hasCornice = false;
  //   // Delete Deco strip
  //   for (let j = 0; j < Cornices.length; j++) {
  //     if (
  //       Cornices[j].uuid == scene.children[index].userData.uuidCornice
  //     ) {
  //       Cornices.splice(j, 1);
  //       needDelete.push(scene.children[index].userData.uuidCornice);
  //     }
  //   }
  //   // Delete Light of deco strip
  //   for (let j = 0; j < lightObjects.length; j++) {
  //     if (
  //       lightObjects[j].uuid ==
  //       scene.children[index].userData.uuidLightCornice
  //     ) {
  //       lightObjects.splice(j, 1);
  //       needDelete.push(
  //         scene.children[index].userData.uuidLightCornice
  //       );
  //     }
  //   }
  // }

  // // Delete right filler.
  // if (scene.children[index].userData.rightFillerId != null) {
  //   needDelete.push(scene.children[index].userData.rightFillerId);
  // }

  // // Delete left filler.
  // if (scene.children[index].userData.leftFillerId != null) {
  //   needDelete.push(scene.children[index].userData.leftFillerId);
  // }

  // // Delete  beside right and right filler of the object beside left.
  // if (scene.children[index].userData.objBesideLeft != null) {
  //   for await (let obj of scene.children) {
  //     if (
  //       obj.uuid == scene.children[index].userData.objBesideLeft.uuid
  //     ) {
  //       obj.userData.objBesideRight = null;
  //       needDelete.push(obj.userData.rightFillerId);
  //       obj.userData.rightFillerId = null;
  //       break;
  //     }
  //   }
  // }

  // // Delete  beside left and left filler of the object beside right.
  // if (scene.children[index].userData.objBesideRight != null) {
  //   for await (let obj of scene.children) {
  //     if (
  //       obj.uuid == scene.children[index].userData.objBesideRight.uuid
  //     ) {
  //       obj.userData.objBesideLeft = null;
  //       needDelete.push(obj.userData.leftFillerId);
  //       obj.userData.leftFillerId = null;
  //       break;
  //     }
  //   }
  // }

  // // Delete Worktops
  // if (scene.children[index].userData.finish_uuids.length >  0) {

  //   for (let j = 0; j < scene.children[index].userData.finish_uuids.length; j++) {
  //     for (let d = 0; d < scene.children.length; d++) {
  //       if(scene.children[d].uuid == scene.children[index].userData.finish_uuids[j]){
  //         scene.remove(scene.children[d]);
  //         break;
  //       }
  //     }

  //   }

  // }

  // scene.children[index].userData.finish_uuids = [];

  // // Delete Light of skirting
  // if (scene.children[index].userData.hasLightSkirting == true) {
  //   for (let j = 0; j < lightObjects.length; j++) {
  //     if (
  //       lightObjects[j].uuid ==
  //       scene.children[index].userData.uuidLightSkirting
  //     ) {
  //       lightObjects.splice(j, 1);
  //       needDelete.push(
  //         scene.children[index].userData.uuidLightSkirting
  //       );
  //     }
  //   }
  // }

  // // Delete Left Cover
  // for (let j = 0; j < leftCovers.length; j++) {
  //   if (
  //     leftCovers[j].uuid == scene.children[index].userData.uuidLeftCover
  //   ) {
  //     leftCovers.splice(j, 1);
  //     needDelete.push(scene.children[index].userData.uuidLeftCover);
  //   }
  // }
  // // Delete Right Cover
  // for (let j = 0; j < rightCovers.length; j++) {
  //   if (
  //     rightCovers[j].uuid ==
  //     scene.children[index].userData.uuidRightCover
  //   ) {
  //     rightCovers.splice(j, 1);
  //     needDelete.push(scene.children[index].userData.uuidRightCover);
  //   }
  // }
  // // Delete Back Cover
  // for (let j = 0; j < backCovers.length; j++) {
  //   if (
  //     backCovers[j].uuid == scene.children[index].userData.uuidBackCover
  //   ) {
  //     backCovers.splice(j, 1);
  //     needDelete.push(scene.children[index].userData.uuidBackCover);
  //   }
  // }

  // // Delete Handle direction
  // for (let j = 0; j < directions.length; j++) {
  //   if (
  //     directions[j].uuid == scene.children[index].userData.uuidDirection
  //   ) {
  //     directions.splice(j, 1);
  //     needDelete.push(scene.children[index].userData.uuidDirection);
  //   }
  // }
  // console.log("scene " , scene);
  // console.log("index " , index);
  scene.children[index].children = [];
  scene.remove(scene.children[index]);

  // console.log("Scene after  ", scene);

  objects.splice(j, 1);
  // Delete all content of needDelete Array.
  // for (let i = 0; i < scene.children.length; i++) {
  //   for (let n = 0; n < needDelete.length; n++) {
  //     if (scene.children[i].uuid == needDelete[n]) {
  //       scene.remove(scene.children[i]);
  //       i = i - 1;
  //       break;
  //     }
  //   }
  // }

  uuidSelected = [];
  for (let i = 0; i < scene.children.length; i++) {
    if (scene.children[i].name === "SelectedObject") {
      scene.remove(scene.children[i]);
      i -= 1;
    }
  }

  render();
}
window.applyDrawer = (drawer) => {
  if (uuidSelected.length > 0) {
    for (let i = 0; i < uuidSelected.length; i++) {
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].uuid === uuidSelected[i]) {
          let j;
          scene.children[index].userData.drawer = drawer;
          for (j = 0; j < objects.length; j++) {
            if (objects[j].uuid === uuidSelected[i]) {
              objects[j] = scene.children[index];
              break;
            }
          }
          render();
          break;
        }
      }
    }
  }
};
window.applyHandle = (handle) => {
  if (uuidSelected.length > 0) {
    for (let i = 0; i < uuidSelected.length; i++) {
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].uuid === uuidSelected[i]) {
          let j;

          scene.children[index].userData.handle = handle;

          for (j = 0; j < objects.length; j++) {
            if (objects[j].uuid === uuidSelected[i]) {
              var hide_all = false;
              let textureWalls = textureLoader.load("./colors/MC5.png");
              // console.log(
              //   "scene.children[index].children   ",
              //   scene.children[index].children
              // );
              for (const child of scene.children[index].children) {
                if (
                  child.isMesh &&
                  (child.name.match(/Handle1.*/) ||
                    child.name.match(/Handle2.*/))
                ) {
                  if (
                    child.name.match(/Handle1.*/) &&
                    (handle == "HB1" || handle == "HS1")
                  ) {
                    // console.log("Handle1  ");
                    child.visible = true;
                    child.material = child.material.clone();
                    child.material.metalness = 0;
                    if (handle == "HS1") {
                      child.material.map = textureWalls;
                    } else {
                      child.material.map = textureCeiling;
                    }
                    // console.log("Handle_round child.visible = true  ");

                    for (const child1 of scene.children[index].children) {
                      if (child1.isMesh) {
                        if (child1.name.match(/Handle2.*/)) {
                          // console.log("Handle  ");
                          child1.visible = false;
                          // console.log("Handle child.visible = false  ");
                        }
                      }
                    }
                    hide_all = false;
                    break;
                    // child.material = child.material.clone();
                    // child.material.metalness = 0;
                    // child.material.map = textureToekick;
                  } else if (
                    child.name.match(/Handle2.*/) &&
                    (handle == "HB2" || handle == "HS2")
                  ) {
                    // console.log("Else Handle  ");
                    child.visible = true;
                    child.material = child.material.clone();
                    child.material.metalness = 0;
                    if (handle == "HS2") {
                      child.material.map = textureWalls;
                    } else {
                      child.material.map = textureCeiling;
                    }
                    // console.log("Else Handle  child.visible = true");
                    for (const child2 of scene.children[index].children) {
                      if (child2.isMesh) {
                        if (child2.name.match(/Handle1.*/)) {
                          // console.log("Else Handle  child.visible = false");
                          child2.visible = false;
                        }
                      }
                    }
                    hide_all = false;
                    break;
                    // child.material = child.material.clone();
                    // child.material.metalness = 0;
                    // child.material.map = textureToekick;
                  } else {
                    hide_all = true;
                  }
                  // else{

                  // }
                }
              }
              if (hide_all) {
                for (const child of scene.children[index].children) {
                  if (
                    child.isMesh &&
                    (child.name.match(/Handle1.*/) ||
                      child.name.match(/Handle2.*/))
                  ) {
                    child.visible = false;
                  }
                }
              }
              objects[j] = scene.children[index];
              break;
            }
          }
          render();
          break;
        }
      }
    }
  }
};

window.applyColorCorpus = (color, typeColor) => {
  // console.log("OK");
  // console.log("scene.children   ", scene.children);
  // console.log("objects   ", objects);
  if (uuidSelected.length > 0) {
    // textureCorpus.repeat.set(0.01, 0.01);
    // textureCorpus.offset.set(0.02, 0.02);

    for (let i = 0; i < uuidSelected.length; i++) {
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].uuid === uuidSelected[i]) {
          // console.log("leftCovers   ", leftCovers);
          // console.log("rightCovers   ", rightCovers);
          // console.log("backCovers   ", backCovers);
          if (typeColor == "All") {
            // Left Cover
            for (let m = 0; m < leftCovers.length; m++) {
              // console.log("leftCovers[m]   ", leftCovers[m]);
              // console.log("Left  ", leftCovers[m]);
              if (
                leftCovers[m].uuid ==
                scene.children[index].userData.uuidLeftCover
              ) {
                leftCovers[m].children[1].material.map = textureCorpus;
                // scene.add(leftCovers[m]);
              }
            }

            // Right Cover
            for (let m = 0; m < rightCovers.length; m++) {
              if (
                rightCovers[m].uuid ==
                scene.children[index].userData.uuidRightCover
              ) {
                rightCovers[m].children[1].material.map = textureCorpus;
                // scene.add(rightCovers[m]);
              }
            }

            // Back Cover
            for (let m = 0; m < backCovers.length; m++) {
              if (
                backCovers[m].uuid ==
                scene.children[index].userData.uuidBackCover
              ) {
                backCovers[m].children[2].material.map = textureCorpus;
                // scene.add(backCovers[m]);
              }
            }
          }
          for (const child of scene.children[index].children) {
            if (child.isGroup) {
              if (
                child.name.match(/carcass.*/) ||
                child.name.match(/Shelf.*/)
              ) {
                // child.material.metalness = -0.5;
                // child.material.roughness = 1;
                for (let co = 0; co < child.children.length; co++) {
                  // child.children[co].material = child.children[co].material.clone();
                  if (typeColor == "All") {
                    textureCorpus = textureLoader.load(
                      "./colors/" + color + ".png"
                    );

                    textureCorpus.wrapS = textureCorpus.wrapT = RepeatWrapping;
                    textureCorpus.repeat.set(2, 2);
                    child.children[co].material =
                      child.children[co].userData.oldMaterial;
                    child.children[co].material.map = textureCorpus;
                    console.log("color  ", color);

                    if (color == "MC1") {
                      // console.log('ok  ' ,color);

                      child.children[co].material = new MeshLambertMaterial({
                        envMap: textureCorpus,
                        reflectivity: 0.2,
                      });

                      child.children[co].castShadow = true;
                      child.children[co].receiveShadow = true;
                    }

                    scene.children[index].userData.carcass_in = color;
                    scene.children[index].userData.carcass_out = color;
                    scene.children[index].userData.carcass_edges = color;
                    scene.children[index].userData.shelf = color;
                    scene.children[index].userData.shelf_edges = color;
                  } else if (typeColor == "Outer/Inner") {
                    if (
                      child.children[co].material.name.match(/.*.-in.*/) ||
                      child.children[co].material.name == "shelf"
                    ) {
                      var c = color.charAt(6);
                      textureCorpus = textureLoader.load(
                        "./colors/MC" + c + ".png"
                      );

                      textureCorpus.wrapS = textureCorpus.wrapT =
                        RepeatWrapping;
                      // textureCorpus.offset.set(0.05, 0.01);
                      textureCorpus.repeat.set(2, 2);
                      child.children[co].material.map = textureCorpus;

                      scene.children[index].userData.shelf = color;
                      scene.children[index].userData.carcass_in = "MC" + c;
                    }
                    if (child.children[co].material.name.match(/.*.-out.*/)) {
                      var c = color.charAt(2);
                      textureCorpus = textureLoader.load(
                        "./colors/MC" + c + ".png"
                      );

                      textureCorpus.wrapS = textureCorpus.wrapT =
                        RepeatWrapping;
                      // textureCorpus.offset.set(0.05, 0.01);
                      textureCorpus.repeat.set(2, 2);
                      child.children[co].material.map = textureCorpus;

                      scene.children[index].userData.carcass_out = "MC" + c;
                    }
                  } else if (typeColor == "Edge Bounding") {
                    if (child.children[co].material.name.match(/.*.edges.*/)) {
                      textureCorpus = textureLoader.load(
                        "./colors/" + color + ".png"
                      );

                      textureCorpus.wrapS = textureCorpus.wrapT =
                        RepeatWrapping;
                      // textureCorpus.offset.set(0.05, 0.01);
                      textureCorpus.repeat.set(2, 2);

                      child.children[co].material =
                        child.children[co].userData.oldMaterial;
                      child.children[co].material.map = textureCorpus;

                      if (color == "MC1") {
                        child.children[co].material = new MeshLambertMaterial({
                          envMap: textureCorpus,
                          reflectivity: 0.2,
                        });
                      }
                      scene.children[index].userData.shelf_edges = color;
                      scene.children[index].userData.carcass_edges = color;
                    }
                  }
                }
              }
            }
          }
          // scene.children[index].userData.corpus = color;
          // const objectName = scene.children[index].userData.name.split("-");
          // if(index > 4 && index < 9)
          // scene.children[index].children[4].material.metalness = 0;
          // scene.children[index].children[4].material.map = textureCorpus;
          // scene.children[index].children[10].material.metalness = 0;
          // scene.children[index].children[10].material.map = textureCorpus;
          // scene.children[index].children[11].material.metalness = 0;
          // scene.children[index].children[11].material.map = textureCorpus;
          // scene.children[index].children[12].material.metalness = 0;
          // scene.children[index].children[12].material.map = textureCorpus;
          // scene.children[index].children[13].material.metalness = 0;
          // scene.children[index].children[13].material.map = textureCorpus;
          // scene.children[index].children[5].material.map = textureCorpus;
          // scene.children[index].children[6].material.map = textureCorpus;
          // scene.children[index].children[7].material.map = textureCorpus;
          // scene.children[index].children[8].material.map = textureCorpus;
          // // if(scene.children[index].name == "B" &&  (objectName[1] <25)){
          // if (
          //   scene.children[index].name == "W" &&
          //   scene.children[index].children.length == 5 &&
          //   objectName[1] < 16
          // ) {
          //   scene.children[index].children[0].material.map = textureCorpus;
          //   scene.children[index].children[1].material.map = textureCorpus;
          //   scene.children[index].children[4].material.map = textureCorpus;
          // } else if (
          //   scene.children[index].name == "W" &&
          //   scene.children[index].children.length == 5 &&
          //   objectName[1] >= 16
          // ) {
          //   scene.children[index].children[0].material.map = textureCorpus;
          //   scene.children[index].children[1].material.map = textureCorpus;
          //   scene.children[index].children[2].material.map = textureCorpus;
          // } else if (
          //   scene.children[index].name == "W" &&
          //   scene.children[index].children.length == 6
          // ) {
          //   scene.children[index].children[0].material.map = textureCorpus;
          //   scene.children[index].children[1].material.map = textureCorpus;
          //   scene.children[index].children[5].material.map = textureCorpus;
          // } else if (
          //   scene.children[index].name == "T" &&
          //   scene.children[index].children.length > 13
          // ) {
          //   scene.children[index].children[0].material.map = textureCorpus;
          //   scene.children[index].children[1].material.map = textureCorpus;
          //   scene.children[index].children[2].material.map = textureCorpus;
          //   // scene.children[index].children[3].material.map = textureCorpus;
          //   // scene.children[index].children[4].material.map = textureCorpus;
          //   // scene.children[index].children[5].material.map = textureCorpus;
          //   // scene.children[index].children[6].material.map = textureCorpus;
          // } else {
          //   scene.children[index].children[0].material.map = textureCorpus;
          //   scene.children[index].children[1].material.map = textureCorpus;
          //   scene.children[index].children[2].material.map = textureCorpus;
          // }
          // }
          // else
          // if(scene.children[index].name == "B" &&  (objectName[1] >=25 && objectName[1] <=32)){

          // }

          let j;
          for (j = 0; j < objects.length; j++) {
            if (objects[j].uuid === uuidSelected[i]) {
              // objects.splice(j, 1);
              // objects.splice(j, 1, scene.children[index]);
              objects[j] = scene.children[index];

              break;
            }
          }
          postData();
          render();
          break;
        }
      }
    }
  }
};

window.applyColorFront = (color, typeColor) => {
  if (uuidSelected.length > 0) {
    // textureFront.rotation = 4;
    // textureFront.wrapS = textureFront.wrapT = MirroredRepeatWrapping;
    // textureFront.repeat.set(0.02, 0.01);
    // textureFront.repeat.set(0.018, 0.01);
    // // textureFront.center.set(new Vector2(0.018, 0.01));
    // // textureFront.offset.set(0.03, 0.01);
    // // textureFront.offset.set(0.3, 0.1);
    // textureFront.offset.set(0.52, 0.32);
    // textureFront.offset.set(0.12, 0.12);
    // textureFront.mapping = CubeUVReflectionMapping;
    // textureFront.encoding = sRGBEncoding;

    // UVMapping
    // CubeReflectionMapping
    // CubeRefractionMapping
    // EquirectangularReflectionMapping
    // EquirectangularRefractionMapping
    // CubeUVReflectionMapping

    for (let i = 0; i < uuidSelected.length; i++) {
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].uuid === uuidSelected[i]) {
          for (const child of scene.children[index].children) {
            if (child.isGroup) {
              // child.material = child.material.clone();
              if (child.name.match(/Shutter.*/)) {
                // child.material.metalness = -2;
                // child.material.roughness = 1;
                for (let co = 0; co < child.children.length; co++) {
                  if (typeColor == "All") {
                    textureFront = textureLoader.load(
                      "./colors/" + color + ".png"
                    );

                    textureFront.generateMipmaps = true;
                    // textureFront.needsUpdate = true;
                    textureFront.minFilter = LinearMipmapLinearFilter;
                    textureFront.magFilter = LinearFilter;
                    textureFront.wrapS = textureFront.wrapT = RepeatWrapping;
                    // textureFront.encoding = sRGBEncoding;
                    textureFront.anisotropy = 16;
                    // child.children[co].material.map = objects[0].children[9].material.map;
                    child.children[co].material =
                      child.children[co].userData.oldMaterial;
                    child.children[co].material.map = textureFront;
                    // const diffuseColor = new Color().setHSL( 1,1, 1 );

                    // child.children[co].material =  new MeshLambertMaterial( { envMap: textureFront  ,color: diffuseColor, reflectivity: 0.2} );
                    // child.children[co].material =   new MeshStandardMaterial( {
                    //   map: textureFront,
                    //   roughness: 0,
                    //   reflectivity:0.5
                    // textureFront.type = HalfFloatType;

                    // cubeCamera = new CubeCamera( 1, 1000, cubeRenderTarget );

                    //

                    // child.children[co].material = new MeshStandardMaterial( {
                    //   envMap: textureFront,
                    //   roughness: 0.05,
                    //   reflectivity: 1
                    // } );

                    //   // metalness: 1
                    // } );
                    // child.children[co].material =  new MeshLambertMaterial({color: 0xFFFFFF , refractionRatio:0.9});
                    // child.children[co].material =  new MeshPhongMaterial( { emissive: 0x111111, envMap: textureFront } );

                    if (color == "MC1") {
                      child.children[co].material = new MeshLambertMaterial({
                        envMap: textureFront,
                        reflectivity: 0.2,
                      });

                      //   console.log('ok  ' ,color);

                      //   child.children[co].material = new MeshReflectorMaterial(
                      //     renderer,
                      //     camera,
                      //     scene,
                      //     child.children[co],
                      //     {
                      //       resolution: 1024,
                      //       blur: [512, 512],
                      //       mixBlur: 3.0,
                      //       mixContrast: 2.0,
                      //       mirror: 0,
                      //     }
                      //   );

                      //   child.children[co].material.setValues({
                      //     roughnessMap: textureFront,
                      //     map:textureFront,
                      //   });
                      //   child.children[co].castShadow = true;
                      //   child.children[co].receiveShadow = true;
                      //   co = 100;
                    }
                    // child.material.map = textureFront;
                    scene.children[index].userData.shutter_in = color;
                    scene.children[index].userData.shutter_out = color;
                  } else {
                    // textureFront = textureLoader.load("/colors/" + color + ".png");

                    // textureFront.generateMipmaps = true;
                    // textureFront.needsUpdate = true;
                    // textureFront.minFilter = LinearMipmapLinearFilter;
                    // textureFront.magFilter = LinearFilter;

                    // child.material.map = textureFront;
                    // scene.children[index].userData.shutter_in = color;
                    // scene.children[index].userData.shutter_out = color;

                    if (child.children[co].material.name.match(/.*.-in.*/)) {
                      var c = color.charAt(6);
                      textureFront = textureLoader.load(
                        "./colors/MC" + c + ".png"
                      );

                      textureFront.generateMipmaps = true;
                      textureFront.needsUpdate = true;
                      textureFront.minFilter = LinearMipmapLinearFilter;
                      textureFront.magFilter = LinearFilter;

                      // textureCorpus = textureLoader.load("/colors/MC" + c + ".png");

                      // textureCorpus.wrapS = textureCorpus.wrapT = RepeatWrapping;
                      // textureCorpus.offset.set(0.05, 0.01);
                      // textureCorpus.repeat.set(2, 2);
                      // child.children[co].material.map = objects[0].children[9].material.map;
                      child.children[co].material.map = textureFront;

                      scene.children[index].userData.shutter_in = "MC" + c;
                    }
                    if (child.children[co].material.name.match(/.*.-out.*/)) {
                      var c = color.charAt(2);
                      textureFront = textureLoader.load(
                        "./colors/MC" + c + ".png"
                      );

                      textureFront.generateMipmaps = true;
                      textureFront.needsUpdate = true;
                      textureFront.minFilter = LinearMipmapLinearFilter;
                      textureFront.magFilter = LinearFilter;
                      // child.children[co].material.map = objects[0].children[9].material.map;
                      child.children[co].material.map = textureFront;

                      scene.children[index].userData.shutter_out = "MC" + c;
                    }
                  }
                }
              }
            }
          }
          // scene.children[index].userData.front = color;
          // // textureFront.center.set(new Vector2(1, 0));
          // const objectName = scene.children[index].userData.name.split("-");
          // scene.children[index].children[14].material.metalness = 0;
          // scene.children[index].children[14].material.map = textureFront;
          // scene.children[index].children[15].material.metalness = 0;
          // scene.children[index].children[15].material.map = textureFront;
          // scene.children[index].children[16].material.metalness = 0;
          // scene.children[index].children[16].material.map = textureFront;
          // scene.children[index].children[17].material.metalness = 0;
          // scene.children[index].children[17].material.map = textureFront;

          // scene.children[index].children[1].material.map = textureFront;
          // scene.children[index].children[4].material.map = textureFront;
          // scene.children[index].children[5].material.map = textureFront;
          // scene.children[index].children[6].material.map = textureFront;
          // scene.children[index].children[7].material.map = textureFront;
          // scene.children[index].children[8].material.map = textureFront;
          // scene.children[index].children[1].material.envMap  = textureFront;
          // scene.children[index].children[1].material.mapping = 500;
          // scene.children[index].children[1].material.needsUpdate = true;
          // Table.material. = true;
          // textureFront.uvsNeedUpdate = true;
          // console.log('children ' ,  scene.children[index].children[1]);
          // if (
          //   scene.children[index].name == "B" &&
          //   scene.children[index].children.length == 8
          // ) {
          //   scene.children[index].children[4].material.map = textureFront;
          //   scene.children[index].children[5].material.map = textureFront;
          // } else if (
          //   scene.children[index].name == "B" &&
          //   scene.children[index].children.length == 9
          // ) {
          //   scene.children[index].children[4].material.map = textureFront;
          //   scene.children[index].children[5].material.map = textureFront;
          //   scene.children[index].children[6].material.map = textureFront;
          // } else if (
          //   scene.children[index].name == "B" &&
          //   scene.children[index].children.length == 10
          // ) {
          //   scene.children[index].children[4].material.map = textureFront;
          //   scene.children[index].children[5].material.map = textureFront;
          //   scene.children[index].children[6].material.map = textureFront;
          //   scene.children[index].children[7].material.map = textureFront;
          // } else if (
          //   scene.children[index].name == "T" &&
          //   scene.children[index].children.length == 9
          // ) {
          //   scene.children[index].children[5].material.map = textureFront;
          //   scene.children[index].children[6].material.map = textureFront;
          //   scene.children[index].children[8].material.map = textureFront;
          // } else if (
          //   scene.children[index].name == "T" &&
          //   scene.children[index].children.length == 10
          // ) {
          //   scene.children[index].children[5].material.map = textureFront;
          //   scene.children[index].children[6].material.map = textureFront;
          //   scene.children[index].children[7].material.map = textureFront;
          //   scene.children[index].children[9].material.map = textureFront;
          // } else if (
          //   scene.children[index].name == "T" &&
          //   scene.children[index].children.length == 11
          // ) {
          //   scene.children[index].children[5].material.map = textureFront;
          //   scene.children[index].children[6].material.map = textureFront;
          //   scene.children[index].children[7].material.map = textureFront;
          //   scene.children[index].children[8].material.map = textureFront;
          //   scene.children[index].children[10].material.map = textureFront;
          // } else if (
          //   scene.children[index].name == "W" &&
          //   scene.children[index].children.length == 5 &&
          //   objectName[1] < 16
          // ) {
          //   scene.children[index].children[3].material.map = textureFront;
          // } else if (
          //   scene.children[index].name == "W" &&
          //   scene.children[index].children.length == 5 &&
          //   objectName[1] >= 16
          // ) {
          //   scene.children[index].children[4].material.map = textureFront;
          // } else if (
          //   scene.children[index].name == "W" &&
          //   scene.children[index].children.length == 6
          // ) {
          //   scene.children[index].children[3].material.map = textureFront;
          //   scene.children[index].children[4].material.map = textureFront;
          // }

          let j;
          for (j = 0; j < objects.length; j++) {
            if (objects[j].uuid === uuidSelected[i]) {
              // objects.splice(j, 1);
              // objects.splice(j, 1, scene.children[index]);
              objects[j] = scene.children[index];

              break;
            }
          }
          postData();
          render();
          break;
        }
      }
    }
  }
};
window.applyColorToekick = (color) => {
  if (uuidSelected.length > 0) {
    textureToekick = textureLoader.load("./colors/" + color + ".png");

    // textureToekick.repeat.set(0.01, 0.01);
    // textureToekick.offset.set(0.3, 0.3);
    // textureToekick.wrapS = textureToekick.wrapT = RepeatWrapping;
    for (let i = 0; i < uuidSelected.length; i++) {
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].uuid === uuidSelected[i]) {
          for (const child of scene.children[index].children) {
            if (child.isMesh) {
              child.material = child.material.clone();
              if (child.name.match(/Skirting.*/)) {
                // child.material.metalness = -2;
                // child.material.roughness = 1;
                child.material = child.userData.oldMaterial;
                child.material.map = textureToekick;
                // child.material = new MeshLambertMaterial( {  map: textureToekick, combine: MixOperation, reflectivity: 1 } );
                if (color == "MC1") {
                  const diffuseColor = new Color().setHSL(1, 1, 1);

                  child.material = new MeshLambertMaterial({
                    envMap: textureToekick,
                    color: diffuseColor,
                    reflectivity: 0.2,
                  });
                  //   console.log('ok  ' ,color);
                  //   child.material = new MeshReflectorMaterial(
                  //     renderer,
                  //     camera,
                  //     scene,
                  //     child,
                  //     {
                  //       resolution: 1024,
                  //       blur: [1024, 1024],
                  //       mixBlur: 5.0,
                  //       mixContrast: 1.0,
                  //       mirror: 0,
                  //     }
                  //   );

                  //   child.material.setValues({
                  //     roughnessMap: textureToekick,
                  //     map:textureToekick,
                  //   });
                  //   child.castShadow = true;
                  //   child.receiveShadow = true;
                }
                console.log(scene);
                scene.children[index].userData.toekick = color;
              }
            }
          }
          // scene.children[index].userData.toekick = color;

          // const objectName = scene.children[index].userData.name.split("-");
          // if (
          //   scene.children[index].name == "B" &&
          //   scene.children[index].children.length == 8
          // ) {
          //   scene.children[index].children[7].material.map = textureToekick;
          // } else if (
          //   scene.children[index].name == "B" &&
          //   scene.children[index].children.length == 9
          // ) {
          //   scene.children[index].children[8].material.map = textureToekick;
          // } else if (
          //   scene.children[index].name == "B" &&
          //   scene.children[index].children.length == 10
          // ) {
          //   scene.children[index].children[9].material.map = textureToekick;
          // } else if (
          //   scene.children[index].name == "T" &&
          //   scene.children[index].children.length == 9
          // ) {
          //   scene.children[index].children[7].material.map = textureToekick;
          // } else if (
          //   scene.children[index].name == "T" &&
          //   scene.children[index].children.length == 10
          // ) {
          //   scene.children[index].children[8].material.map = textureToekick;
          // } else if (
          //   scene.children[index].name == "T" &&
          //   scene.children[index].children.length == 11
          // ) {
          //   scene.children[index].children[9].material.map = textureToekick;
          // }
          // scene.children[index].children[3].material.map = textureToekick;
          // scene.children[index].children[5].material.metalness = 0;
          // scene.children[index].children[5].material.map = textureToekick;
          let j;
          for (j = 0; j < objects.length; j++) {
            if (objects[j].uuid === uuidSelected[i]) {
              // objects.splice(j, 1);
              // objects.splice(j, 1, scene.children[index]);
              objects[j] = scene.children[index];

              break;
            }
          }
          postData();
          render();
          break;
        }
      }
    }
  }
};
window.applyColorWorktops = (color) => {
  if (uuidSelected.length > 0) {
    worktopsColor = color;
    textureWorktops = textureLoader.load("./colors/" + color + ".png");
    textureWorktops.wrapS = textureWorktops.wrapT = RepeatWrapping;
    textureWorktops.offset.set(0.02, 0.02);
    textureWorktops.repeat.set(0.02, 0.02);
    // textureWorktops.repeat.set(0.01, 0.01);
    // textureWorktops.offset.set(0.4, 0.4);
    for (let i = 0; i < uuidSelected.length; i++) {
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].uuid === uuidSelected[i]) {
          for (
            let j = 0;
            j < scene.children[index].userData.finish_uuids.length;
            j++
          ) {
            for (let k = 0; k < finishTops.length; k++) {
              if (
                scene.children[index].userData.finish_uuids[j] ==
                finishTops[k].uuid
              ) {
                for (const child of finishTops[k].children) {
                  if (child.isMesh) {
                    child.material = child.material.clone();
                    // if (child.name.match(/counter_top.*/)) {
                    // child.material.metalness = -2;
                    // child.material.roughness = 1;
                    child.material.map = textureWorktops;
                    // child.material.map.repeat.set(8, 8);
                    scene.children[index].userData.worktops = color;

                    // object.children[t].material.map = textureCeiling;
                    // object.children[t].material.map.repeat.set(8, 8);

                    // }
                  }
                }
              }
            }
            // const element = array[j];
          }
          // const objectName = scene.children[index].userData.name.split("-");
          // scene.children[index].userData.worktops = color;

          // if (
          //   scene.children[index].name == "B" &&
          //   scene.children[index].children.length == 8
          // ) {
          //   scene.children[index].children[3].material.map = textureWorktops;
          //   scene.children[index].children[6].material.map = textureWorktops;
          // } else if (
          //   scene.children[index].name == "B" &&
          //   scene.children[index].children.length == 9
          // ) {
          //   scene.children[index].children[3].material.map = textureWorktops;
          //   scene.children[index].children[7].material.map = textureWorktops;
          // } else if (
          //   scene.children[index].name == "B" &&
          //   scene.children[index].children.length == 10
          // ) {
          //   scene.children[index].children[3].material.map = textureWorktops;
          //   scene.children[index].children[8].material.map = textureWorktops;
          // } else if (
          //   scene.children[index].name == "T" &&
          //   scene.children[index].children.length == 9
          // ) {
          //   scene.children[index].children[4].material.map = textureWorktops;
          //   scene.children[index].children[3].material.map = textureWorktops;
          // } else if (
          //   scene.children[index].name == "T" &&
          //   scene.children[index].children.length == 10
          // ) {
          //   scene.children[index].children[4].material.map = textureWorktops;
          //   scene.children[index].children[3].material.map = textureWorktops;
          // } else if (
          //   scene.children[index].name == "T" &&
          //   scene.children[index].children.length == 11
          // ) {
          //   scene.children[index].children[4].material.map = textureWorktops;
          //   scene.children[index].children[3].material.map = textureWorktops;
          // } else if (
          //   scene.children[index].name == "W" &&
          //   scene.children[index].children.length == 5 &&
          //   objectName[1] < 16
          // ) {
          //   scene.children[index].children[2].material.map = textureWorktops;
          // } else if (
          //   scene.children[index].name == "W" &&
          //   scene.children[index].children.length == 5 &&
          //   objectName[1] >= 16
          // ) {
          //   scene.children[index].children[3].material.map = textureFront;
          // } else if (
          //   scene.children[index].name == "W" &&
          //   scene.children[index].children.length == 6
          // ) {
          //   scene.children[index].children[2].material.map = textureWorktops;
          // }
          // scene.children[index].children[2].material.map = textureWorktops;
          // scene.children[index].children[18].material.metalness = 0;
          // scene.children[index].children[18].material.map = textureWorktops;
          let j;
          for (j = 0; j < objects.length; j++) {
            if (objects[j].uuid === uuidSelected[i]) {
              objects[j] = scene.children[index];

              break;
            }
          }
          postData();
          render();
          break;
        }
      }
    }
  }
};

window.applySkirtingLight = (operation) => {
  if (uuidSelected.length > 0) {
    for (let i = 0; i < uuidSelected.length; i++) {
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].uuid === uuidSelected[i]) {
          let Objobject = scene.children[index];
          if (Objobject.name != "W") {
            // Apply
            if (operation == "A") {
              // Skirting Light
              var lightPosX;
              var lightPosZ;
              if (Objobject.rotation.y == degrees_to_radians(0)) {
                lightPosX = Objobject.position.x - Objobject.userData.W / 2;
                lightPosZ = Objobject.position.z + Objobject.userData.L - 0.014;
              } else if (Objobject.rotation.y == degrees_to_radians(180)) {
                lightPosX = Objobject.position.x + Objobject.userData.W / 2;
                lightPosZ = Objobject.position.z - Objobject.userData.L + 0.014;
              } else if (Objobject.rotation.y == degrees_to_radians(90)) {
                lightPosZ = Objobject.position.z + Objobject.userData.W / 2;
                lightPosX = Objobject.position.x + Objobject.userData.L - 0.014;
              } else {
                lightPosZ = Objobject.position.z - Objobject.userData.W / 2;
                lightPosX = Objobject.position.x - Objobject.userData.L + 0.014;
              }

              RectAreaLightUniformsLib.init();
              const Light = new RectAreaLight(
                0xf5f5f5,
                10,
                Objobject.userData.W,
                0.018
              );
              Light.position.set(
                lightPosX,
                Objobject.position.y + 0.1,
                lightPosZ
              );
              Light.rotation.y = Objobject.rotation.y;
              Objobject.userData.uuidLightSkirting = Light.uuid;
              Objobject.userData.hasLightSkirting = true;
              scene.add(Light);
              lightObjects.push(Light);
              //  scene.add( new RectAreaLightHelper( Light ) );

              render();
              break;
            } else if (operation == "D") {
              for (let index = 0; index < lightObjects.length; index++) {
                if (
                  lightObjects[index].uuid ==
                  Objobject.userData.uuidLightSkirting
                ) {
                  lightObjects.splice(index, 1);
                  for (let j = 0; j < scene.children.length; j++) {
                    if (
                      scene.children[j].uuid ==
                      Objobject.userData.uuidLightSkirting
                    ) {
                      scene.remove(scene.children[j]);
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};

window.applyDecoLight = (operation) => {
  if (uuidSelected.length > 0) {
    for (let i = 0; i < uuidSelected.length; i++) {
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].uuid === uuidSelected[i]) {
          let Objobject = scene.children[index];
          if (Objobject.name == "W") {
            // Apply
            if (operation == "A") {
              if (Objobject.userData.hasDecoStrip == true) {
                // // Deco strip
                // const loaderr = new GLTFLoader();
                // loaderr.load("/obj/newObjects/deco-strip.glb", function (gltf) {
                // let object = gltf.scene;
                Objobject.userData.decoStripLight = true;
                var lightPosX;
                var lightPosZ;
                var lightRotX = 0;
                var lightRotZ = 0;
                var lightRotY = 0;

                if (Objobject.rotation.y == degrees_to_radians(0)) {
                  lightPosX = Objobject.position.x - Objobject.userData.W / 2;
                  lightPosZ =
                    Objobject.position.z + Objobject.userData.L - 0.118;
                  lightRotX = degrees_to_radians(-90);
                  lightRotZ = degrees_to_radians(0);
                  lightRotY = Objobject.rotation.y;
                } else if (Objobject.rotation.y == degrees_to_radians(180)) {
                  lightPosX = Objobject.position.x + Objobject.userData.W / 2;
                  lightPosZ =
                    Objobject.position.z - Objobject.userData.L + 0.118;
                  lightRotX = degrees_to_radians(90);
                  lightRotZ = degrees_to_radians(180);
                  lightRotY = Objobject.rotation.y;
                } else if (Objobject.rotation.y == degrees_to_radians(90)) {
                  lightPosZ = Objobject.position.z + Objobject.userData.W / 2;
                  lightPosX =
                    Objobject.position.x + Objobject.userData.L - 0.118;
                  lightRotZ = degrees_to_radians(180);
                  lightRotY = Objobject.rotation.y;
                } else {
                  lightPosZ = Objobject.position.z - Objobject.userData.W / 2;
                  lightPosX =
                    Objobject.position.x - Objobject.userData.L + 0.118;
                  lightRotZ = degrees_to_radians(180);
                  lightRotY = Objobject.rotation.y;
                }

                // var lightPosX = Objobject.position.x;
                // var lightPosZ = Objobject.position.z;

                // if (Objobject.rotation.y == degrees_to_radians(0)) {
                //   // Objobject.position.z =
                //   //   Objobject.position.z + Objobject.userData.L - 0.018;
                //   lightPosX = Objobject.position.x - Objobject.userData.W / 2;
                //   lightPosZ =
                //     Objobject.position.z + Objobject.userData.L - 0.03;
                // } else if (Objobject.rotation.y == degrees_to_radians(180)) {

                //   lightPosX = Objobject.position.x + Objobject.userData.W / 2;
                //   lightPosZ =
                //     Objobject.position.z - Objobject.userData.L + 0.03;
                // } else if (Objobject.rotation.y == degrees_to_radians(90)) {

                //   lightPosZ = Objobject.position.z + Objobject.userData.W / 2;
                //   lightPosX =
                //     Objobject.position.x + Objobject.userData.L - 0.03;
                // } else {

                //   lightPosZ = Objobject.position.z - Objobject.userData.W / 2;
                //   lightPosX = Objobject.position.x - Objobject.userData.L + 0.03;
                // }

                RectAreaLightUniformsLib.init();
                const Light = new RectAreaLight(
                  0xf5f5f5,
                  9,
                  Objobject.userData.W,
                  0.2
                );
                if (lightRotX == 0) {
                  Light.rotation.y = lightRotZ;
                  Light.rotation.z = degrees_to_radians(-90);
                  Light.rotation.x = degrees_to_radians(90);
                } else {
                  Light.rotation.x = lightRotX;
                  Light.rotation.z = lightRotZ;
                  Light.rotation.y = lightRotY;
                }

                Light.position.set(lightPosX, Objobject.position.y, lightPosZ);
                //  Light.lookAt( object.position.x, object.position.y, object.position.z );
                Light.rotation.y = Objobject.rotation.y;
                Objobject.userData.uuidLight = Light.uuid;
                scene.add(Light);
                //  scene.add( new RectAreaLightHelper( Light ) );

                lightObjects.push(Light);

                render();
                break;
              }
            } else if (operation == "D") {
              if (Objobject.userData.hasDecoStrip == true) {
                for (let index = 0; index < lightObjects.length; index++) {
                  if (
                    lightObjects[index].uuid == Objobject.userData.uuidLight
                  ) {
                    lightObjects.splice(index, 1);
                    for (let j = 0; j < scene.children.length; j++) {
                      if (
                        scene.children[j].uuid == Objobject.userData.uuidLight
                      ) {
                        scene.remove(scene.children[j]);
                        Objobject.userData.decoStripLight = false;

                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};

window.applyDecoStrip = (color, operation) => {
  if (uuidSelected.length > 0) {
    let texture = textureLoader.load("./colors/" + color + ".png");
    for (let i = 0; i < uuidSelected.length; i++) {
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].uuid === uuidSelected[i]) {
          let Objobject = scene.children[index];
          if (Objobject.name == "W") {
            // Apply
            if (operation == "A") {
              if (Objobject.userData.hasDecoStrip != true) {
                // Deco strip
                const loaderr = new GLTFLoader();
                //                loaderr.load("/obj/newObjects/deco-strip.glb", function (gltf) {
                loaderr.load(
                  "https://storage.googleapis.com/kitchendata/accessories/deco-strip.glb",
                  function (gltf) {
                    let object = gltf.scene;
                    Objobject.userData.hasDecoStrip = true;
                    Objobject.userData.uuidDecoStrip = object.uuid;

                    object.scale.x = Objobject.userData.W;
                    object.position.y = Objobject.position.y - 0.1;
                    object.position.x = Objobject.position.x;
                    object.position.z = Objobject.position.z;
                    object.rotation.y = Objobject.rotation.y;
                    var lightPosX = object.position.x;
                    var lightPosZ = object.position.z;
                    if (Objobject.rotation.y == degrees_to_radians(0)) {
                      object.position.z =
                        Objobject.position.z + Objobject.userData.L - 0.018;
                      lightPosX = object.position.x - Objobject.userData.W / 2;
                      lightPosZ =
                        Objobject.position.z + Objobject.userData.L - 0.03;
                    } else if (
                      Objobject.rotation.y == degrees_to_radians(180)
                    ) {
                      object.position.z =
                        Objobject.position.z - Objobject.userData.L + 0.018;
                      lightPosX = object.position.x + Objobject.userData.W / 2;
                      lightPosZ =
                        Objobject.position.z - Objobject.userData.L + 0.03;
                    } else if (Objobject.rotation.y == degrees_to_radians(90)) {
                      object.position.x =
                        Objobject.position.x + Objobject.userData.L - 0.018;
                      lightPosZ = object.position.z + Objobject.userData.W / 2;
                      lightPosX =
                        Objobject.position.x + Objobject.userData.L - 0.03;
                    } else {
                      object.position.x =
                        Objobject.position.x - Objobject.userData.L + 0.018;
                      lightPosZ = object.position.z - Objobject.userData.W / 2;
                      lightPosX =
                        Objobject.position.x - Objobject.userData.L + 0.03;
                    }

                    // scene.add(new RectAreaLightHelper(Light));

                    for (let t = 0; t < object.children.length; t++) {
                      if (object.children[t].type == "Mesh") {
                        object.children[t].userData.uuid = object.uuid;
                        object.children[t].material.metalness = 0;
                        object.children[t].material.map = texture;
                        object.children[t].castShadow = true;
                        object.children[t].receiveShadow = true;
                      }
                    }
                    Objobject.userData.decoStripColor = color;
                    object.name = "Deco strip";

                    scene.add(object);
                    // object.userData.rotationY  = Objobject.rotation.y;
                    object.userData.positionZ = Objobject.position.z;
                    object.userData.positionX = Objobject.position.x;
                    decoStrips.push(object);
                    // console.log("scene ", scene);

                    // console.log("objects[i].userData.hasLeftCover ");
                    for (let index = 0; index < leftCovers.length; index++) {
                      if (
                        leftCovers[index].uuid ==
                        Objobject.userData.uuidLeftCover
                      ) {
                        // leftCovers[index].visible = false;

                        leftCovers[index].position.y =
                          Objobject.position.y - 0.1;
                        leftCovers[index].scale.y =
                          leftCovers[index].scale.y + 0.1;

                        scene.add(leftCovers[index]);
                        // objects[i].userData.hasLeftCover = false
                        // scene.add(objects[i]);
                      }
                    }

                    for (let index = 0; index < rightCovers.length; index++) {
                      if (
                        rightCovers[index].uuid ==
                        Objobject.userData.uuidRightCover
                      ) {
                        // rightCovers[index].visible = false;

                        rightCovers[index].position.y =
                          Objobject.position.y - 0.1;
                        rightCovers[index].scale.y =
                          rightCovers[index].scale.y + 0.1;

                        scene.add(rightCovers[index]);
                        // objects[i].userData.hasRightCover = false
                        // scene.add(objects[i]);
                      }
                    }
                  }
                );

                // for (const child of scene.children[index].children) {
                //   if (child.isMesh) {
                //     child.material = child.material.clone();
                //     if (child.name.match(/counter_top.*/)) {
                //       child.material.map = textureWorktops;
                //     }
                //   }
                // }

                // let j;
                // for (j = 0; j < objects.length; j++) {
                //   if (objects[j].uuid === uuidSelected[i]) {
                //     objects[j] = scene.children[index];

                //     break;
                //   }
                // }

                render();
                break;
              }
            } else if (operation == "D") {
              if (Objobject.userData.hasDecoStrip == true) {
                Objobject.userData.hasDecoStrip = false;
                for (let index = 0; index < decoStrips.length; index++) {
                  if (
                    decoStrips[index].uuid == Objobject.userData.uuidDecoStrip
                  ) {
                    decoStrips.splice(index, 1);
                    for (let j = 0; j < scene.children.length; j++) {
                      if (
                        scene.children[j].uuid ==
                        Objobject.userData.uuidDecoStrip
                      ) {
                        scene.remove(scene.children[j]);
                        Objobject.userData.decoStripColor = "Not found";
                        break;
                      }
                    }
                  }
                }
                for (let index = 0; index < lightObjects.length; index++) {
                  if (
                    lightObjects[index].uuid == Objobject.userData.uuidLight
                  ) {
                    lightObjects.splice(index, 1);
                    for (let j = 0; j < scene.children.length; j++) {
                      if (
                        scene.children[j].uuid == Objobject.userData.uuidLight
                      ) {
                        scene.remove(scene.children[j]);
                        break;
                      }
                    }
                  }
                }
                for (let index = 0; index < leftCovers.length; index++) {
                  if (
                    leftCovers[index].uuid == Objobject.userData.uuidLeftCover
                  ) {
                    leftCovers[index].position.y = Objobject.position.y;
                    leftCovers[index].scale.y = leftCovers[index].scale.y - 0.1;
                    scene.add(leftCovers[index]);
                  }
                }

                for (let index = 0; index < rightCovers.length; index++) {
                  if (
                    rightCovers[index].uuid == Objobject.userData.uuidRightCover
                  ) {
                    rightCovers[index].position.y = Objobject.position.y;
                    rightCovers[index].scale.y =
                      rightCovers[index].scale.y - 0.1;
                    scene.add(rightCovers[index]);
                  }
                }
              }
            } else {
              for (let index = 0; index < decoStrips.length; index++) {
                if (
                  decoStrips[index].uuid == Objobject.userData.uuidDecoStrip
                ) {
                  for (let t = 0; t < decoStrips[index].children.length; t++) {
                    if (decoStrips[index].children[t].type == "Mesh") {
                      decoStrips[index].children[t].material.map = texture;
                      Objobject.userData.decoStripColor = color;
                      break;
                    }
                  }
                  scene.add(decoStrips[index]);
                }
              }
            }
          }
        }
      }
    }
  }
};

window.applyWallPanel = (color, operation) => {
  if (uuidSelected.length > 0) {
    let texture = textureLoader.load("./colors/" + color + ".png");
    // texture.offset.set(0.05, 0.002);
    // texture.repeat.set(0.02, 0.002);
    texture.magFilter = NearestFilter;
    texture.mapping = UVMapping;
    texture.wrapS = RepeatWrapping;
    texture.wrapT = RepeatWrapping;
    texture.side = DoubleSide;
    texture.flipY = true;

    for (let i = 0; i < uuidSelected.length; i++) {
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].uuid === uuidSelected[i]) {
          let Objobject = scene.children[index];

          if (Objobject.name == "B") {
            // Apply
            if (operation == "A") {
              const loaderr = new GLTFLoader();
              // Wall panel
              //              loaderr.load("/obj/newObjects/wall-panel.glb", function (gltf) {
              loaderr.load(
                "https://storage.googleapis.com/kitchendata/accessories/wall-panel.glb",
                function (gltf) {
                  let object = gltf.scene;
                  Objobject.userData.hasWallPanel = true;
                  Objobject.userData.uuidWallPanel = object.uuid;

                  // object.scale.x = Objobject.userData.W;
                  object.scale.x = Objobject.userData.W;
                  object.position.y = Objobject.userData.H + 0.2;
                  object.position.x = Objobject.position.x;
                  object.position.z = Objobject.position.z;

                  // object.position.y = Objobject.position.y + 0.1;
                  // heightObj -= 0.189;
                  // console.log(Objobject.scale);
                  // console.log(Objobject.position.y);
                  // object.rotation.x = Math.PI * 2;

                  // console.log("Handler   ", Type);
                  // object.name = Objobject.children[j].name+objName + j;
                  // object.userData.name = objName;

                  // objectsAdd.push(Objobject);

                  // var newMesh = new Mesh( object.children[0].geometry, cylBleu );

                  // newMesh.add(object);

                  // scene.add(Objobject);

                  for (let t = 0; t < object.children.length; t++) {
                    if (object.children[t].type == "Mesh") {
                      object.children[t].userData.uuid = object.uuid;
                      object.children[t].material.metalness = 0;

                      object.children[t].material.map = texture;
                      object.children[t].material.map.repeat.set(10, 4);

                      object.children[t].castShadow = true;
                      object.children[t].receiveShadow = true;
                    }
                    // Objobject.children.push(object.children[index]);
                  }
                  object.userData.color = color;
                  // console.log("object.scale.y  ", object.scale.y);
                  Objobject.userData.wallPanelColor = color;
                  Objobject.userData.wallPanelHeight = object.scale.y * 100;
                  // console.log("wall  ", object);
                  object.name = "Wall panel";

                  scene.add(object);
                  // Objobject.children.push(object.children);
                  // Objobject.children[6].children[0] = object;
                  // console.log("ooo ", object);
                  wallPanels.push(object);
                  // console.log("backCovers ", backCovers);
                }
              );

              render();
              break;
            } else if (operation == "D") {
              if (Objobject.userData.hasWallPanel == true) {
                Objobject.userData.hasWallPanel = false;
                for (let index = 0; index < wallPanels.length; index++) {
                  if (
                    wallPanels[index].uuid == Objobject.userData.uuidWallPanel
                  ) {
                    wallPanels.splice(index, 1);
                    for (let j = 0; j < scene.children.length; j++) {
                      if (
                        scene.children[j].uuid ==
                        Objobject.userData.uuidWallPanel
                      ) {
                        Objobject.userData.wallPanelColor = "Not found";
                        Objobject.userData.wallPanelHeight = 0;
                        scene.remove(scene.children[j]);
                        break;
                      }
                    }
                  }
                }
              }
            } else {
              for (let index = 0; index < wallPanels.length; index++) {
                if (
                  wallPanels[index].uuid == Objobject.userData.uuidWallPanel
                ) {
                  for (let t = 0; t < wallPanels[index].children.length; t++) {
                    if (wallPanels[index].children[t].type == "Mesh") {
                      wallPanels[index].userData.color = color;
                      wallPanels[index].children[t].material.map = texture;
                      wallPanels[index].children[t].material.map.repeat.set(
                        10,
                        4
                      );
                      Objobject.userData.wallPanelColor = color;

                      break;
                    }
                  }
                  scene.add(wallPanels[index]);
                }
              }
            }
          }
        }
      }
    }
  }
};

window.changeWallOffset = (wallOffset) => {
  if (uuidSelected.length > 0) {
    for (let i = 0; i < uuidSelected.length; i++) {
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].uuid === uuidSelected[i]) {
          if (scene.children[index].name != "Element") {
            scene.children[index].userData.wallOffset = wallOffset;
            return;
          }
        }
      }
    }
  }
};

window.changeWallPanelHeight = async (heightWall) => {
  //console.log('heightWall   ',heightWall);
  if (uuidSelected.length > 0) {
    for (let i = 0; i < uuidSelected.length; i++) {
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].uuid === uuidSelected[i]) {
          //        console.log('okay   ',heightWall);

          let Objobject = scene.children[index];
          if (Objobject.name == "B") {
            if (Objobject.userData.hasWallPanel == true) {
              // console.log("changeWallPanelHeight  Ok ");
              for (let index = 0; index < wallPanels.length; index++) {
                if (
                  wallPanels[index].uuid == Objobject.userData.uuidWallPanel
                ) {
                  // console.log("changeWallPanelHeight  Enter ");
                  wallPanels[index].scale.y = heightWall / 100;
                  // console.log("object.scale.y  " , heightWall / 100);

                  Objobject.userData.wallPanelHeight = heightWall;
                  // console.log("wallPanels[index].userData.wallPanelHeight  " , Objobject.userData.wallPanelHeight);

                  scene.add(wallPanels[index]);
                  let event = {
                    object: Objobject,
                  };
                  await dragstart(event);
                  await dragend(event);
                  // console.log("scene.children[index]   " , Objobject);
                  // for (let f = 0; f < scene.children.length; f++) {
                  //   console.log("scene.children[index].rightFillerId  " ,Objobject.userData.rightFillerId);
                  //   console.log("scene.children[index].leftFillerId  " ,Objobject.userData.leftFillerId);
                  //   if(Objobject.userData.rightFillerId != null){
                  //     if(Objobject.userData.rightFillerId == scene.children[f].uuid){
                  //       console.log("Okkkkkk  1");
                  //       scene.children[f].scale.y = heightWall / 1000;
                  //     }

                  //   }
                  //   if(Objobject.userData.leftFillerId != null){
                  //     if(Objobject.userData.leftFillerId == scene.children[f].uuid){
                  //       console.log("Okkkkkk  2");

                  //       scene.children[f].scale.y = heightWall / 1000;

                  //     }

                  //   }
                  // }
                  // object.children[t].scale.y = wallScale;
                  // console.log("changeWallPanelHeight  After dragend");
                  break;
                }
              }
              render();
              break;
            }
          }
        }
      }
    }
  }
};

window.applyCorniceLight = (operation) => {
  if (uuidSelected.length > 0) {
    for (let i = 0; i < uuidSelected.length; i++) {
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].uuid === uuidSelected[i]) {
          let Objobject = scene.children[index];
          if (Objobject.name == "W") {
            // Apply
            if (operation == "A") {
              if (Objobject.userData.hasCornice == true) {
                Objobject.userData.corniceLight = true;
                var lightPosX = Objobject.position.x;
                var lightPosZ = Objobject.position.z;
                if (Objobject.rotation.y == degrees_to_radians(0)) {
                  lightPosX = Objobject.position.x - Objobject.userData.W / 2;
                  lightPosZ =
                    Objobject.position.z + Objobject.userData.L - 0.05;
                } else if (Objobject.rotation.y == degrees_to_radians(180)) {
                  lightPosX = Objobject.position.x + Objobject.userData.W / 2;
                  lightPosZ =
                    Objobject.position.z - Objobject.userData.L + 0.05;
                } else if (Objobject.rotation.y == degrees_to_radians(90)) {
                  lightPosZ = Objobject.position.z + Objobject.userData.W / 2;
                  lightPosX =
                    Objobject.position.x + Objobject.userData.L - 0.05;
                } else {
                  lightPosZ = Objobject.position.z - Objobject.userData.W / 2;
                  lightPosX =
                    Objobject.position.x - Objobject.userData.L + 0.05;
                }

                RectAreaLightUniformsLib.init();

                const Light = new RectAreaLight(
                  0xf5f5f5,
                  10,
                  Objobject.userData.W + 0.018,
                  0.036
                );
                Light.position.set(
                  lightPosX,
                  Objobject.position.y + Objobject.userData.H,
                  lightPosZ
                );

                Light.rotation.y = Objobject.rotation.y;
                Objobject.userData.uuidLightCornice = Light.uuid;
                scene.add(Light);
                lightObjects.push(Light);
                //  scene.add( new RectAreaLightHelper( Light ) );

                render();
                break;
              }
            } else if (operation == "D") {
              if (Objobject.userData.hasCornice == true) {
                for (let index = 0; index < lightObjects.length; index++) {
                  if (
                    lightObjects[index].uuid ==
                    Objobject.userData.uuidLightCornice
                  ) {
                    lightObjects.splice(index, 1);
                    for (let j = 0; j < scene.children.length; j++) {
                      if (
                        scene.children[j].uuid ==
                        Objobject.userData.uuidLightCornice
                      ) {
                        Objobject.userData.corniceLight = false;
                        scene.remove(scene.children[j]);
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};

window.applyCornice = (color, operation) => {
  if (uuidSelected.length > 0) {
    let texture = textureLoader.load("./colors/" + color + ".png");
    for (let i = 0; i < uuidSelected.length; i++) {
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].uuid === uuidSelected[i]) {
          let Objobject = scene.children[index];
          if (Objobject.name == "W") {
            // Apply
            if (operation == "A") {
              if (Objobject.userData.hasCornice != true) {
                const loaderr = new GLTFLoader();
                //                loaderr.load("/obj/newObjects/cornice.glb", function (gltf) {
                loaderr.load(
                  "https://storage.googleapis.com/kitchendata/accessories/cornice.glb",
                  function (gltf) {
                    let object = gltf.scene;
                    Objobject.userData.hasCornice = true;
                    Objobject.userData.uuidCornice = object.uuid;

                    Objobject.userData.corniceColor = color;

                    object.scale.x = Objobject.userData.W + 0.036;
                    object.position.y =
                      Objobject.position.y + Objobject.userData.H;
                    object.position.x = Objobject.position.x;
                    object.position.z = Objobject.position.z;
                    object.rotation.y = Objobject.rotation.y;
                    // var lightPosX = object.position.x;
                    // var lightPosZ = object.position.z;
                    if (Objobject.rotation.y == degrees_to_radians(0)) {
                      object.position.z =
                        Objobject.position.z + Objobject.userData.L - 0.05;
                      // lightPosX = object.position.x - Objobject.userData.W / 2;
                      // lightPosZ =
                      //   Objobject.position.z + Objobject.userData.L - 0.05;
                      object.position.x += 0.018;
                    } else if (
                      Objobject.rotation.y == degrees_to_radians(180)
                    ) {
                      object.position.z =
                        Objobject.position.z - Objobject.userData.L + 0.05;
                      // lightPosX = object.position.x + Objobject.userData.W / 2;
                      // lightPosZ =
                      //   Objobject.position.z - Objobject.userData.L + 0.05;
                      object.position.x -= 0.018;
                    } else if (Objobject.rotation.y == degrees_to_radians(90)) {
                      object.position.x =
                        Objobject.position.x + Objobject.userData.L - 0.05;
                      // lightPosZ = object.position.z + Objobject.userData.W / 2;
                      // lightPosX =
                      //   Objobject.position.x + Objobject.userData.L - 0.05;
                      object.position.z -= 0.018;
                    } else {
                      object.position.x =
                        Objobject.position.x - Objobject.userData.L + 0.05;
                      // lightPosZ = object.position.z - Objobject.userData.W / 2;
                      // lightPosX =
                      //   Objobject.position.x - Objobject.userData.L + 0.05;
                      object.position.z += 0.018;
                    }

                    // RectAreaLightUniformsLib.init();
                    // //  console.log("object.userData.W   ",Objobject.userData.W);
                    // //  console.log("object.userData.W/   ",Objobject.userData.W/10);
                    // //  console.log("object.userData.L   ",Objobject.userData.L);
                    // //  console.log("object.userData.L/   ",Objobject.userData.L/10);
                    // const Light = new RectAreaLight(
                    //   0xf5f5f5,
                    //   10,
                    //   Objobject.userData.W + 0.018,
                    //   0.036
                    // );
                    // Light.position.set(lightPosX, object.position.y, lightPosZ);
                    // //  Light.lookAt( object.position.x, object.position.y, object.position.z );

                    // Light.rotation.y = Objobject.rotation.y;
                    // Objobject.userData.uuidLightCornice = Light.uuid;
                    // scene.add(Light);
                    // lightObjects.push(Light);
                    //  scene.add( new RectAreaLightHelper( Light ) );

                    for (let t = 0; t < object.children.length; t++) {
                      if (object.children[t].type == "Mesh") {
                        object.children[t].userData.uuid = object.uuid;
                        object.children[t].material.metalness = 0;
                        object.children[t].material.map = texture;
                        object.children[t].castShadow = true;
                        object.children[t].receiveShadow = true;
                      }
                    }
                    object.name = "Cornice";

                    scene.add(object);
                    // object.userData.rotationY  = Objobject.rotation.y;
                    object.userData.positionZ = Objobject.position.z;
                    object.userData.positionX = Objobject.position.x;
                    Cornices.push(object);
                    // console.log("scene ", scene);
                  }
                );

                render();
                break;
              }
            } else if (operation == "D") {
              if (Objobject.userData.hasCornice == true) {
                Objobject.userData.hasCornice = false;
                for (let index = 0; index < Cornices.length; index++) {
                  if (Cornices[index].uuid == Objobject.userData.uuidCornice) {
                    Cornices.splice(index, 1);
                    for (let j = 0; j < scene.children.length; j++) {
                      if (
                        scene.children[j].uuid == Objobject.userData.uuidCornice
                      ) {
                        scene.remove(scene.children[j]);

                        Objobject.userData.corniceColor = "Not found";

                        break;
                      }
                    }
                  }
                }
                for (let index = 0; index < lightObjects.length; index++) {
                  if (
                    lightObjects[index].uuid ==
                    Objobject.userData.uuidLightCornice
                  ) {
                    lightObjects.splice(index, 1);
                    for (let j = 0; j < scene.children.length; j++) {
                      if (
                        scene.children[j].uuid ==
                        Objobject.userData.uuidLightCornice
                      ) {
                        scene.remove(scene.children[j]);
                        Objobject.userData.corniceLight = false;
                        break;
                      }
                    }
                  }
                }
              }
            } else {
              for (let index = 0; index < Cornices.length; index++) {
                if (Cornices[index].uuid == Objobject.userData.uuidCornice) {
                  for (let t = 0; t < Cornices[index].children.length; t++) {
                    if (Cornices[index].children[t].type == "Mesh") {
                      Cornices[index].children[t].material.map = texture;
                      Objobject.userData.corniceColor = color;
                      break;
                    }
                  }
                  scene.add(Cornices[index]);
                }
              }
            }
          }
        }
      }
    }
  }
};
var mouse = { x: 0, y: 0 };

function degrees_to_radians(degrees) {
  var pi = Math.PI;
  return degrees * (pi / 180);
}
function onDocumentMouseDown(event) {
  // if(obj)
  // showText()

  event.preventDefault();
  // console.log("onDocumentMouseDown");
  // var vector = new Vector3( ( event.clientX / window.innerWidth ) * 2 - 1, 0.5 , - ( event.clientY / window.innerHeight ) * 2 + 1 );
  const rect = renderer.domElement.getBoundingClientRect();
  mouse = new Vector2();
  mouse.x = ((event.clientX - rect.left) / (rect.right - rect.left)) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / (rect.bottom - rect.top)) * 2 + 1;

  // projector = new Projector();
  // projector.unprojectVector( vector, camera );
  var intersectsWall = raycaster.intersectObjects(scene.children, true);
  if (intersectsWall.length > 0) {
    if (intersectsWall[0].object.userData.wall == "length") {
      window.L = measuresZG.max - measuresZG.min;
      window.wallLength = true;
    } else if (intersectsWall[0].object.userData.wall == "width") {
      // console.log("Width ", measures.width);
      window.W = measuresXG.max - measuresXG.min;

      window.wallWidth = true;
    }
  }
  // var raycaster = new Raycaster( camera.position, mouse.sub( camera.position ).normalize() );
  raycaster.setFromCamera(mouse, camera);
  // console.log("objects  ", objects);
  // var intersectsPlanes = raycaster.intersectObjects(objects, true);
  var intersects = raycaster.intersectObjects(objects, true);
  // console.log("intersects  " ,intersects);

  // console.log("intersects ", intersects);
  var selectedBefore = false;
  var uuidObjDetermine = 0;
  if (intersects.length > 0) {
    // console.log("intersected");
    //     let vector = new Vector2();
    //   vector.x = ( intersects[0].object.position.x + 1) * renderer.domElement.width / 2;
    // vector.y = - ( intersects[0].object.position.z - 1) * renderer.domElement.height / 2;
    // // vector.z = 0;
    // console.log("intersects[0].object.name     ", intersects[0].object.name);
    // console.log("intersects uuid  ", intersects[0].object.uuid);

    if (intersects[0].object.parent.name == "Element") {
      let data = {
        update_dimensions_element: {
          width_dimension: intersects[0].object.parent.userData.W * 1000,
          height_dimension: intersects[0].object.parent.userData.H * 1000,
          depth_dimension: intersects[0].object.parent.userData.L * 1000,
        },
      };
      window.parent.postMessage(JSON.stringify(data), "*");
      //      document.getElementById("menu_options").style.display = "none";
      //      document.getElementById("menu_search").style.display = "none";
      //      document.getElementById("menu_furniture").style.display = "none";
      //      document.getElementById("update_dimensions").style.display = "flex";
      //      document.getElementById("update_attributes").style.display = "none";
      //      document.getElementById("menu_elements").style.display = "none";
      //
      //      document.getElementById("width_dimension").value =
      //        intersects[0].object.parent.userData.W * 1000;

      //      document.getElementById("height_dimension").value =
      //        intersects[0].object.parent.userData.H * 1000;

      //      document.getElementById("depth_dimension").value =
      //        intersects[0].object.parent.userData.L * 1000;

      savedElement = intersects[0].object.parent;
    } else {
      let data = {
        update_dimensions_object: {
          userData: intersects[0].object.userData.name,
        },
      };
      window.parent.postMessage(JSON.stringify(data), "*");
    }
    // console.log('mouse.x  ',vector.x);
    //   console.log('mouse.y    ',vector.y);
    // console.log("uuidSelected ", uuidSelected.length);
    for (let i = 0; i < uuidSelected.length; i++) {
      if (uuidSelected[i] === intersects[0].object.userData.uuid) {
        uuidObjDetermine = i;
        selectedBefore = true;
        break;
      }
    }
    if (!selectedBefore) {
      uuidSelected.push(intersects[0].object.userData.uuid);
      // console.log("uuidSelected ", uuidSelected.length);

      let selectedIndex = -1;
      for (let index = 0; index < scene.children.length; index++) {
        // if (scene.children[index].name === "SelectedObject") {
        //   scene.remove(scene.children[index]);
        //   index -= 1;
        // }
        if (
          scene.children[index].uuid === uuidSelected[uuidSelected.length - 1]
        ) {
          selectedIndex = index;
        }
      }
      if (
        selectedIndex != -1 &&
        scene.children[selectedIndex].name != "Win" &&
        scene.children[selectedIndex].name != "Do"
      ) {
        // camera.position.z = measuresXG.max;
        // camera.position.y = 1.3;
        // camera.position.x = 0;

        //////

        // console.log("position.z  ", scene.children[selectedIndex].position.z);

        let positionX, positionZ;
        if (
          scene.children[selectedIndex].rotation.y == degrees_to_radians(90)
        ) {
          // console.log("Here");
          positionX =
            scene.children[selectedIndex].userData.ElType == "opening"
              ? scene.children[selectedIndex].position.x
              : scene.children[selectedIndex].position.x +
                scene.children[selectedIndex].userData.L / 2;

          positionZ =
            scene.children[selectedIndex].position.z +
            scene.children[selectedIndex].userData.W / 2;
        } else if (
          scene.children[selectedIndex].rotation.y == degrees_to_radians(-90)
        ) {
          positionX =
            scene.children[selectedIndex].userData.ElType == "opening"
              ? scene.children[selectedIndex].position.x
              : scene.children[selectedIndex].position.x -
                scene.children[selectedIndex].userData.L / 2;
          positionZ =
            scene.children[selectedIndex].position.z -
            scene.children[selectedIndex].userData.W / 2;
        } else if (scene.children[selectedIndex].rotation.y == 0) {
          positionX =
            scene.children[selectedIndex].position.x -
            scene.children[selectedIndex].userData.W / 2;
          positionZ =
            scene.children[selectedIndex].userData.ElType == "opening"
              ? scene.children[selectedIndex].position.z
              : scene.children[selectedIndex].position.z +
                scene.children[selectedIndex].userData.L / 2;
        } else if (
          scene.children[selectedIndex].rotation.y == degrees_to_radians(180)
        ) {
          positionX =
            scene.children[selectedIndex].position.x +
            scene.children[selectedIndex].userData.W / 2;
          positionZ =
            scene.children[selectedIndex].userData.ElType == "opening"
              ? scene.children[selectedIndex].position.z
              : scene.children[selectedIndex].position.z -
                scene.children[selectedIndex].userData.L / 2;
        }

        //////
        //////
        console.log('userData.W  ' , scene.children[selectedIndex].userData.W);
        console.log('userData.H  ' , scene.children[selectedIndex].userData.H);
        console.log('userData.L  ' , scene.children[selectedIndex].userData.L);
        
        const geometry = new BoxGeometry(
          scene.children[selectedIndex].userData.W,
          scene.children[selectedIndex].userData.H,
          scene.children[selectedIndex].userData.L
        );

        const material = new MeshBasicMaterial({ color: 0x00ff00 });
        const cube = new Mesh(geometry, material);
        cube.position.x = positionX;
        // console.log("position y", scene.children[selectedIndex].rotation.y);
        if (scene.children[selectedIndex].name == "W")
          cube.position.y =
            scene.children[selectedIndex].position.y +
            scene.children[selectedIndex].userData.H / 2;
        else if (scene.children[selectedIndex].name == "Element")
          cube.position.y =
            scene.children[selectedIndex].position.y +
            scene.children[selectedIndex].userData.H / 2;
        else
          cube.position.y =
            scene.children[selectedIndex].userData.H / 2 + wallWidth + 0.1;

        cube.position.z = positionZ;
        cube.rotation.y = scene.children[selectedIndex].rotation.y;
        cube.visible = false;
        if (is2D) {
          cube.scale.y = 0;
          cube.position.y = 0.12;
        }
        const box = new BoxHelper(cube);

        box.name = "SelectedObject";
        // console.log("Box  ", box);
        scene.add(box);

        var position = new Vector3();
        position.getPositionFromMatrix(
          scene.children[selectedIndex].matrixWorld
        );
        // console.log(
        //   "Coordinates  ",
        //   position.x + "," + position.y + "," + position.z
        // );
        // const pointLight = new PointLight(0xffff00, 0.5, 0.5, 0.5);
        // pointLight.position.set(
        //   positionX,
        //   scene.children[selectedIndex].userData.H + 0.1,
        //   positionZ
        // );
        // pointLight.name = "SelectedObject";
        // pointLight.castShadow = false;
        // scene.add(pointLight);

        // camera.lookAt(scene.children[selectedIndex].position);
        //  console.log("Enter");
        //   if(scene.children[selectedIndex].userData.hasHandle == true){
        //     positionX = scene.children[selectedIndex].position.x -  scene.children[selectedIndex].userData.W / 2 ;
        //     let positionY =  scene.children[selectedIndex].userData.H + 0.118;
        //      positionZ = scene.children[selectedIndex].position.z + scene.children[selectedIndex].userData.L - 0.018;
        //  console.log("Set Coordinates");

        //     for (let index = 0; index < handles.length; index++) {
        //         if(handles[index].uuid ==scene.children[selectedIndex].userData.uuidHandle){
        //            console.log("The handle is exist ", handles[index]);

        //           handles[index].position.x = positionX ;
        //           handles[index].position.z = positionZ;
        //           handles[index].position.y = positionY;
        //           handles[index].rotation.y = scene.children[selectedIndex].rotation.y;
        //           scene.add(handles[index]);
        //           break;
        //         }

        //     }
        //    }
        // Objobject.userData.hasHandle = true;
        // Objobject.userData.uuidHandle = object.uuid;
        // console.log('positionX  ' ,positionX);
        // console.log('positionZ  ' ,positionZ);
        // console.log('positionY  ' ,positionY);
        // object.position.x = positionX ;
        // object.position.z = positionZ;
        // object.position.y= positionY;
      }
    } else {
      if (!is2D) {
        // console.log(uuidSelected);
        // for (let j = 0; j < scene.length; j++) {
        //   const element = array[j];

        // }

        for (let index = 0; index < scene.children.length; index++) {
          if (scene.children[index].uuid === uuidSelected[uuidObjDetermine]) {
            animation(index);
          }
          if (scene.children[index].name === "SelectedObject") {
            scene.remove(scene.children[index]);
            index -= 1;
          }
        }
        uuidSelected = [];
      }
    }
    // intersects[ 0 ].object.material.color.setHex( Math.random() * 0xffffff );

    // var particle = new Sprite( particleMaterial );
    // particle.position = intersects[ 0 ].point;
    // particle.scale.x = particle.scale.y = 16;
    // scene.add( particle );
  } else {
    console.log("not intersected");

    let data = { hide_update_dialog: true };
    window.parent.postMessage(JSON.stringify(data), "*");
    for (let index = 0; index < scene.children.length; index++) {
      if (scene.children[index].name === "SelectedObject") {
        scene.remove(scene.children[index]);
        index -= 1;
      }
    }

    uuidSelected = [];
  }
}

window.updateDimensionsElements = (width, height, depth, wallSide) => {
  //  let width = document.getElementById("width_dimension").value / 1000;
  //  let height = document.getElementById("height_dimension").value / 1000;
  //  let depth = document.getElementById("depth_dimension").value / 1000;
  //  let wallSide = document.getElementById("wall_side").value;

  for (let index = 0; index < objects.length; index++) {
    if (objects[index].uuid == savedElement.uuid) {
      objects[index].scale.set(width, height, depth);
      // objects[index].children[1].scale.set(width, height, depth);
      // objects[index].children[1].scale.x = width;
      // objects[index].children[3].scale.x = width;
      // objects[index].children[2].position.x = objects[index].children[3].position.x - (objects[index].children[3].scale.x*4/2)
      // objects[index].children[4].position.x = objects[index].children[3].position.x + (objects[index].children[3].scale.x*4/2)

      // console.log('p 2    ',objects[index].children[2].position.x);
      // console.log('p 4    ',objects[index].children[4].position.x);
      // console.log('1   ',objects[index].children[1].scale.x);
      // console.log('3   ',objects[index].children[3].scale.x);
      // console.log('pp   ',objects[index].children[3].position.x);

      // objects[index].children[2].scale.set(width, height, depth);
      // objects[index].children[4].scale.set(width, height, depth);
      // objects[index].children[2].scale.x = width;
      // objects[index].children[4].scale.x = width;
      objects[index].userData.W = width;
      objects[index].userData.H = height;
      objects[index].userData.L = depth;
      if (is2D) objects[index].scale.y = 0.1;

      objects[index].userData.openingDir = objects[index].userData.openingDir
        ? wallSide
        : "";
      // // Handle Direction

      if (objects[index].userData.hasHandleDirection == true) {
        for (let d = 0; d < directions.length; d++) {
          if (directions[d].uuid == objects[index].userData.uuidDirection) {
            if (objects[index].rotation.y == degrees_to_radians(0)) {
              directions[d].scale.x = objects[index].userData.W;
            } else if (objects[index].rotation.y == degrees_to_radians(90)) {
              directions[d].scale.z = objects[index].userData.W;
            } else if (objects[index].rotation.y == degrees_to_radians(180)) {
              directions[d].scale.x = objects[index].userData.W;
            } else if (objects[index].rotation.y == degrees_to_radians(-90)) {
              directions[d].scale.z = objects[index].userData.W;
            }

            scene.add(directions[d]);
          }
        }
      }
      scene.add(objects[index]);
      uuidSelected = [];
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].name === "SelectedObject") {
          scene.remove(scene.children[index]);
          index -= 1;
        }
      }
      break;
    }
  }
  // $.ajax({
  //   type: "POST",
  //   url: "https://storage.googleapis.com/kitchendata/alter.py",
  //   data: { len: 10}
  // }).done(function( o ) {
  //    // do something
  // });
  // loadXMLDoc();
  // postData('HHH');

};

async function onKeyPress(event) {
  // console.log("event  ", event);
  // console.log("event.key  ", event.key);
  // console.log("event.keyCode  ", event.keyCode);
  if (event.keyCode == 46 || event.key === "Delete") {
    await deleteObject();
  }
}

window.deleteObject = async () => {
  let data = { hide_update_dialog: true };
  window.parent.postMessage(JSON.stringify(data), "*");
  for (let i = 0; i < uuidSelected.length; i++) {
    let needDelete = [];

    for (let index = 0; index < scene.children.length; index++) {
      if (scene.children[index].uuid === uuidSelected[i]) {
        /**
         * Delete the finish top (worktops) of the determined object.
         */
        let leftObj = scene.children[index].userData.objBesideLeft;
        let rightObj = scene.children[index].userData.objBesideRight;
        for (let j = 0; j < finishTops.length; j++) {
          for (
            let m = 0;
            m < scene.children[index].userData.finish_uuids.length;
            m++
          ) {
            if (
              finishTops[j].uuid ==
              scene.children[index].userData.finish_uuids[m]
            ) {
              finishTops.splice(j, 1);
              j--;
              break;
            }
          }
        }

        for await (let obj of scene.children) {
          for (
            let m = 0;
            m < scene.children[index].userData.finish_uuids.length;
            m++
          ) {
            if (obj.uuid == scene.children[index].userData.finish_uuids[m]) {
              scene.children[index].userData.finish_uuids.splice(m--, 1);
              needDelete.push(obj.uuid);
              // scene.remove(obj);
              // index--;
              break;
            }
          }
        }

        scene.children[index].userData.finish_uuids = [];

        uuids = [];

        /**
         * End delete wotktops
         */

        // Delete deco strip and it's light.
        if (scene.children[index].userData.hasDecoStrip == true) {
          scene.children[index].userData.hasDecoStrip = false;
          // Delete Deco strip
          for (let j = 0; j < decoStrips.length; j++) {
            if (
              decoStrips[j].uuid == scene.children[index].userData.uuidDecoStrip
            ) {
              scene.children[index].userData.decoStripColor = "Not found";
              decoStrips.splice(j, 1);
              needDelete.push(scene.children[index].userData.uuidDecoStrip);
            }
          }
          // Delete Light of deco strip
          for (let j = 0; j < lightObjects.length; j++) {
            if (
              lightObjects[j].uuid == scene.children[index].userData.uuidLight
            ) {
              lightObjects.splice(j, 1);
              scene.children[index].userData.decoStripLight = false;
              needDelete.push(scene.children[index].userData.uuidLight);
            }
          }
        }

        // Delete wall panel.
        if (scene.children[index].userData.hasWallPanel == true) {
          scene.children[index].userData.hasWallPanel = false;
          // Delete Wall Panel
          for (let j = 0; j < wallPanels.length; j++) {
            if (
              wallPanels[j].uuid == scene.children[index].userData.uuidWallPanel
            ) {
              scene.children[index].userData.wallPanelColor = "Not found";
              scene.children[index].userData.wallPanelHeight = 0;

              wallPanels.splice(j, 1);
              needDelete.push(scene.children[index].userData.uuidWallPanel);
            }
          }
        }

        // Delete cornice and it's light.
        if (scene.children[index].userData.hasCornice == true) {
          scene.children[index].userData.hasCornice = false;
          // Delete Deco strip
          for (let j = 0; j < Cornices.length; j++) {
            if (
              Cornices[j].uuid == scene.children[index].userData.uuidCornice
            ) {
              Cornices.splice(j, 1);
              needDelete.push(scene.children[index].userData.uuidCornice);
            }
          }
          // Delete Light of cornice
          for (let j = 0; j < lightObjects.length; j++) {
            if (
              lightObjects[j].uuid ==
              scene.children[index].userData.uuidLightCornice
            ) {
              lightObjects.splice(j, 1);
              needDelete.push(scene.children[index].userData.uuidLightCornice);
            }
          }
        }

        // Delete right filler.
        if (scene.children[index].userData.rightFillerId != null) {
          needDelete.push(scene.children[index].userData.rightFillerId);
        }

        // Delete left filler.
        if (scene.children[index].userData.leftFillerId != null) {
          needDelete.push(scene.children[index].userData.leftFillerId);
        }

        // Delete  beside right and right filler of the object beside left.
        if (scene.children[index].userData.objBesideLeft != null) {
          for await (let obj of scene.children) {
            if (obj.uuid == scene.children[index].userData.objBesideLeft.uuid) {
              obj.userData.objBesideRight = null;
              needDelete.push(obj.userData.rightFillerId);
              obj.userData.rightFillerId = null;
              break;
            }
          }
        }

        // Delete  beside left and left filler of the object beside right.
        if (scene.children[index].userData.objBesideRight != null) {
          for await (let obj of scene.children) {
            if (
              obj.uuid == scene.children[index].userData.objBesideRight.uuid
            ) {
              obj.userData.objBesideLeft = null;
              needDelete.push(obj.userData.leftFillerId);
              obj.userData.leftFillerId = null;
              break;
            }
          }
        }

        scene.children[index].userData.finish_uuids = [];

        // Delete Light of skirting
        if (scene.children[index].userData.hasLightSkirting == true) {
          for (let j = 0; j < lightObjects.length; j++) {
            if (
              lightObjects[j].uuid ==
              scene.children[index].userData.uuidLightSkirting
            ) {
              scene.children[index].userData.hasLightSkirting = false;
              lightObjects.splice(j, 1);
              needDelete.push(scene.children[index].userData.uuidLightSkirting);
            }
          }
        }

        // Delete Left Cover
        for (let j = 0; j < leftCovers.length; j++) {
          if (
            leftCovers[j].uuid == scene.children[index].userData.uuidLeftCover
          ) {
            scene.children[index].userData.hasLeftCover = false;

            scene.children[index].userData.visibleLeftCover = false;

            leftCovers.splice(j, 1);
            needDelete.push(scene.children[index].userData.uuidLeftCover);
          }
        }
        // Delete Right Cover
        for (let j = 0; j < rightCovers.length; j++) {
          if (
            rightCovers[j].uuid == scene.children[index].userData.uuidRightCover
          ) {
            scene.children[index].userData.hasRightCover = false;

            scene.children[index].userData.visibleRightCover = false;

            rightCovers.splice(j, 1);
            needDelete.push(scene.children[index].userData.uuidRightCover);
          }
        }
        // Delete Back Cover
        for (let j = 0; j < backCovers.length; j++) {
          if (
            backCovers[j].uuid == scene.children[index].userData.uuidBackCover
          ) {
            scene.children[index].userData.hasBackCover = false;
            scene.children[index].userData.visibleBackCover = false;
            backCovers.splice(j, 1);
            needDelete.push(scene.children[index].userData.uuidBackCover);
          }
        }

        // Delete Handle direction
        for (let j = 0; j < directions.length; j++) {
          if (
            directions[j].uuid == scene.children[index].userData.uuidDirection
          ) {
            directions.splice(j, 1);
            needDelete.push(scene.children[index].userData.uuidDirection);
          }
        }

        // Delete Sink
        if (scene.children[index].userData.hasSink == true) {
          for (let j = 0; j < sinks.length; j++) {
            if (sinks[j].uuid == scene.children[index].userData.uuidSink) {
              sinks.splice(j, 1);
              needDelete.push(scene.children[index].userData.uuidSink);
            }
          }
        }

        // Delete Oven
        if (scene.children[index].userData.hasOven == true) {
          for (let j = 0; j < ovens.length; j++) {
            if (ovens[j].uuid == scene.children[index].userData.uuidOven) {
              ovens.splice(j, 1);
              needDelete.push(scene.children[index].userData.uuidOven);
            }
          }
        }

        // let elType

        scene.children[index].children = [];

        scene.remove(scene.children[index]);
        index--;

        let j;
        for (j = 0; j < objects.length; j++) {
          if (objects[j].uuid === uuidSelected[i]) break;
        }
        let elType = objects[j].userData.ElType;
        objects.splice(j, 1);
        setTimeout(async () => {
          if (leftObj != null) await drawFinishTop(leftObj);
          if (rightObj != null) await drawFinishTop(rightObj);
        }, 500);
        if (elType == "opening") {
          backOpenings = [];
          leftOpenings = [];
          frontOpenings = [];
          rightOpenings = [];

          for (let i = 0; i < objects.length; i++) {
            if (
              objects[i].rotation.y == degrees_to_radians(0) &&
              objects[i].position.z == measuresZG.min + wallWidth
            ) {
              backOpenings.push(objects[i]);
              wallsOpen = true;
            } else if (
              objects[i].rotation.y == degrees_to_radians(90) &&
              objects[i].position.x == measuresXG.min + wallWidth
            ) {
              leftOpenings.push(objects[i]);
              wallsOpen = true;
            } else if (
              objects[i].rotation.y == degrees_to_radians(180) &&
              objects[i].position.z == measuresZG.max - wallWidth
            ) {
              frontOpenings.push(objects[i]);
              wallsOpen = true;
            } else if (
              objects[i].rotation.y == degrees_to_radians(-90) &&
              objects[i].position.x == measuresXG.max - wallWidth
            ) {
              rightOpenings.push(objects[i]);
              wallsOpen = true;
            }
          }

          if (
            backOpenings.length > 0 ||
            frontOpenings.length > 0 ||
            leftOpenings.length > 0 ||
            rightOpenings.length > 0 ||
            wallsOpen
          ) {
            walls("Any thing");
            wallsOpen =
              wallsOpen == false
                ? true
                : backOpenings.length > 0 ||
                  frontOpenings.length > 0 ||
                  leftOpenings.length > 0 ||
                  rightOpenings.length > 0
                ? true
                : false;
          }
        }

        // console.log("scene.children[index].ElType" , scene.children[index]);
        // console.log("scene.children[index].ElType" , scene.children[index].userData.ElType);

        render();
        break;
      }
    }

    // Delete all content of needDelete Array.
    for (let index = 0; index < scene.children.length; index++) {
      for (let j = 0; j < needDelete.length; j++) {
        if (scene.children[index].uuid == needDelete[j]) {
          scene.remove(scene.children[index]);
          index = index - 1;
          break;
        }
      }
    }
  }
  uuidSelected = [];
  for (let index = 0; index < scene.children.length; index++) {
    if (scene.children[index].name === "SelectedObject") {
      scene.remove(scene.children[index]);
      index -= 1;
    }
  }

  clearMeasuresLines();
};

async function to2D(type = false, drag = false) {
  //Delete Lines,Points,Text, SelectedObjects
  console.log(" to2D ");
  await deleteLines();
  document.getElementById("es-Left").style.display = "none";
  document.getElementById("es-Right").style.display = "none";
  document.getElementById("es-Front").style.display = "none";
  document.getElementById("es-Back").style.display = "none";

  for (let index = 0; index < scene.children.length; index++) {
    if (scene.children[index].name == "filler") {
      if (is2D) scene.children[index].scale.y = 1;
      else scene.children[index].scale.y = 0.1;
    }
    if (
      scene.children[index].userData.type == "Es-line" ||
      scene.children[index].type == "Line"
    ) {
      scene.remove(scene.children[index]);
      index = index - 1;
    }
  }

  clearMeasuresLines();
  // await calcMeasuresFunc();
  if (is2D && !type) {
    is2D = false;
    // scene.background = textureBackground;
    // dragLeftWall.dispose();
    // dragRightWall.dispose();
    // dragBackWall.dispose();
    // dragFrontWall.dispose();

    // console.log("deactivate   ");
    // measures.height = height2d;
    window.is2d = false;

    camera.position.set(3, 1, 9);
    controls.target.set(0, 1, 0);
    controls.enabled = true;
    controls.update();
    // console.log(planeTop.visible);
    planeTop.visible = true;
    // planeLeft.scale.y = planeLeftCoordinates.scale;
    // planeLeft.position.y = planeLeftCoordinates.position;
    // scene.add(planeLeft);

    // planeRight.scale.y = planeRightCoordinates.scale;
    // planeRight.position.y = planeRightCoordinates.position;
    // scene.add(planeRight);

    // planeBack.scale.y = planeBackCoordinates.scale;
    // planeBack.position.y = planeBackCoordinates.position;
    // scene.add(planeBack);

    // planeFront.visible = false;
    // planeLeft.visible = true;
    // planeRight.visible = true;
    // planeBottom.visible = true;
    // scene.add(planeFront);
    // scene.add(planeTop);

    //    document.getElementById("2d").innerHTML = "2D";
    for (let s = 0; s < objects.length; s++) {
      // console.log("objects[s]  " , objects[s]);
      objects[s].scale.y = 1;
      if (objects[s].name == "Element") {
        objects[s].scale.y = objects[s].userData.H;
      }
      // console.log("objects[index].userData.ElType  " ,objects[index].userData.ElType);
      objects[s].visible = true;
      const name = objects[s].name;
      if (
        name == "W" ||
        name == "WC" ||
        name == "Win" ||
        objects[s].userData.ElType == "opening"
        // objects[index].name == "Element"
      ) {
        objects[s].position.y = objects[s].userData.oldPositionY;
      }
      scene.add(objects[s]);
      // }
      for (let index = 0; index < leftCovers.length; index++) {
        if (leftCovers[index].uuid == objects[s].userData.uuidLeftCover) {
          leftCovers[index].scale.y = objects[s].userData.H;
          // leftCovers[index].scale.z = 1;
          // console.log("objects[s].name   " , objects[s].name);
          if (objects[s].name == "B") {
            leftCovers[index].position.y = wallWidth * 2;
            // console.log("leftCovers[index].position.y   " , leftCovers[index].position.y);
          } else {
            leftCovers[index].position.y = objects[s].position.y;
            leftCovers[index].scale.y = objects[s].userData.H;
            if (objects[s].userData.hasDecoStrip) {
              leftCovers[index].scale.y = objects[s].userData.H + 0.1;
              leftCovers[index].position.y = objects[s].position.y - 0.1;
            }
          }
          // leftCovers[index].visible = true;

          scene.add(leftCovers[index]);
          break;
        }
      }
      for (let index = 0; index < rightCovers.length; index++) {
        if (rightCovers[index].uuid == objects[s].userData.uuidRightCover) {
          rightCovers[index].scale.y = objects[s].userData.H;
          // rightCovers[index].scale.z = 1;
          if (objects[s].name == "B")
            rightCovers[index].position.y = wallWidth * 2;
          else {
            rightCovers[index].position.y = objects[s].position.y;
            leftCovers[index].scale.y = objects[s].userData.H;

            if (objects[s].userData.hasDecoStrip) {
              rightCovers[index].scale.y = objects[s].userData.H + 0.1;
              rightCovers[index].position.y = objects[s].position.y - 0.1;
            }
          }
          // rightCovers[index].visible = true;

          scene.add(rightCovers[index]);
          break;
        }
      }

      for (let index = 0; index < backCovers.length; index++) {
        if (backCovers[index].uuid == objects[s].userData.uuidBackCover) {
          backCovers[index].scale.y = objects[s].userData.H;
          // backCovers[index].scale.z = 1;
          if (objects[s].name == "B")
            backCovers[index].position.y = wallWidth * 2;
          else {
            backCovers[index].position.y = objects[s].position.y;
            leftCovers[index].scale.y = objects[s].userData.H;

            if (objects[s].userData.hasDecoStrip) {
              backCovers[index].scale.y = objects[s].userData.H + 0.1;
              backCovers[index].position.y = objects[s].position.y - 0.1;
            }
          }
          // backCovers[index].visible = true;

          scene.add(backCovers[index]);
          break;
        }
      }

      for (let index = 0; index < decoStrips.length; index++) {
        if (decoStrips[index].uuid == objects[s].userData.uuidDecoStrip) {
          decoStrips[index].scale.y = 1;
          // decoStrips[index].scale.z = 1;
          // decoStrips[index].position.y = wallWidth * 2;
          if (objects[s].name == "B")
            decoStrips[index].position.y = wallWidth * 2;
          else decoStrips[index].position.y = objects[s].position.y - 0.1;
          // wallPanels[index].visible = true;

          scene.add(decoStrips[index]);
          break;
        }
      }

      for (let index = 0; index < wallPanels.length; index++) {
        if (objects[s].userData.hasWallPanel == true) {
          if (wallPanels[index].uuid == objects[s].userData.uuidWallPanel) {
            wallPanels[index].scale.y =
              objects[s].userData.wallPanelHeight / 100;
            wallPanels[index].position.y = objects[s].userData.H + 0.2;
            wallPanels[index].scale.z = 1;
            scene.add(wallPanels[index]);
            break;
          }
        } else {
          break;
        }
        // wallPanels[index].visible = true;
      }
    }
    // for (let index = 0; index < wallPanels.length; index++) {
    //   wallPanels[index].scale.y = 1;
    //   wallPanels[index].position.y = 0.1;
    //   wallPanels[index].scale.z = 1;
    //   // wallPanels[index].visible = true;

    //   scene.add(wallPanels[index]);
    // }
    for (let index = 0; index < Cornices.length; index++) {
      Cornices[index].scale.y = 1;
      Cornices[index].scale.z = 1;
      Cornices[index].position.y = wallWidth * 2;
      // wallPanels[index].visible = true;

      scene.add(Cornices[index]);
    }

    for (let index = 0; index < sinks.length; index++) {
      sinks[index].scale.y = sinks[index].userData.oldScaleY;
      sinks[index].position.y = sinks[index].userData.oldPositionY;
      scene.add(sinks[index]);
    }

    for (let index = 0; index < ovens.length; index++) {
      ovens[index].scale.y = ovens[index].userData.oldScaleY;
      ovens[index].position.y = ovens[index].userData.oldPositionY;
      scene.add(ovens[index]);
    }

    for (let k = 0; k < finishTops.length; k++) {
      finishTops[k].visible = true;
      // scene.add(finishTops[k]);
    }

    await walls("Any Thing");
  } else {
    is2D = true;

    if (drag) await dragWall();

    // height2d = measures.height;
    // measures.height = 6;
    window.is2d = true;

    //Update  Text value of control buttons
    // document.getElementById("front").innerHTML = "Front View";
    // document.getElementById("right").innerHTML = "Right View";
    // document.getElementById("left").innerHTML = "Left View";
    document.getElementById("myCanvas").style.cursor = "auto";
    document.getElementById("myCanvas").style.pointerEvents = "all";

    // Show planes
    planeLeft.visible = true;
    planeRight.visible = true;
    planeBottom.visible = true;

    // Change scale of objects to appear as 2D
    for (let index = 0; index < objects.length; index++) {
      // console.log("objects[index].name " , objects[index].name);
      objects[index].scale.y = 0.005;
      // objects[index].scale.z = 1;
      objects[index].userData.oldPositionY = objects[index].position.y;
      if (objects[index].name == "Element") {
        objects[index].position.y = 0.12;
        // if(objects[index].position.x > measuresXG.max)objects[index].position.x = measuresXG.max;
        // if(objects[index].position.x < measuresXG.min)objects[index].position.x = measuresXG.min;
        // if(objects[index].position.z > measuresZG.max)objects[index].position.z = measuresZG.max;
        // if(objects[index].position.z < measuresZG.min)objects[index].position.z = measuresZG.min;
      }
      objects[index].visible = true;
      const name = objects[index].name;
      if (
        name == "W" ||
        name == "WC" ||
        name == "Win" ||
        objects[index].userData.ElType == "opening"
      ) {
        objects[index].position.y = wallWidth * 2;
      }

      // objects[index].position.y = wallWidth * 2;

      scene.add(objects[index]);
    }

    for (let index = 0; index < leftCovers.length; index++) {
      leftCovers[index].scale.y = 0.00005;
      // leftCovers[index].scale.z = 1;
      leftCovers[index].position.y = wallWidth * 2;
      // leftCovers[index].visible = true;

      scene.add(leftCovers[index]);
    }
    for (let index = 0; index < rightCovers.length; index++) {
      rightCovers[index].scale.y = 0.00005;
      // rightCovers[index].scale.z = 1;
      rightCovers[index].position.y = wallWidth * 2;
      // rightCovers[index].visible = true;

      scene.add(rightCovers[index]);
    }
    for (let index = 0; index < backCovers.length; index++) {
      backCovers[index].scale.y = 0.00005;
      // backCovers[index].scale.z = 1;
      backCovers[index].position.y = wallWidth * 2;
      // backCovers[index].visible = true;

      scene.add(backCovers[index]);
    }
    for (let index = 0; index < wallPanels.length; index++) {
      // console.log("wallPanelHeight   ",wallPanels[index].userData.wallPanelHeight);
      // console.log("scale.y   ",wallPanels[index].scale.y);
      wallPanels[index].scale.y = 0.00005;
      wallPanels[index].position.y = 0.1;
      wallPanels[index].scale.z = 1;
      // wallPanels[index].visible = true;

      scene.add(wallPanels[index]);
    }
    for (let index = 0; index < decoStrips.length; index++) {
      decoStrips[index].scale.y = 0.00005;
      decoStrips[index].scale.z = 1;
      decoStrips[index].position.y = wallWidth * 2;
      // wallPanels[index].visible = true;

      scene.add(decoStrips[index]);
    }
    for (let index = 0; index < Cornices.length; index++) {
      Cornices[index].scale.y = 0.00005;
      Cornices[index].scale.z = 1;
      Cornices[index].position.y = wallWidth * 2;
      // wallPanels[index].visible = true;

      scene.add(Cornices[index]);
    }

    for (let index = 0; index < sinks.length; index++) {
      sinks[index].userData.oldScaleY = sinks[index].scale.y;
      sinks[index].userData.oldPositionY = sinks[index].position.y;
      sinks[index].scale.y = 0.00005;
      sinks[index].position.y = wallWidth * 2;
      scene.add(sinks[index]);
    }

    for (let index = 0; index < ovens.length; index++) {
      ovens[index].userData.oldScaleY = ovens[index].scale.y;
      ovens[index].userData.oldPositionY = ovens[index].position.y;
      ovens[index].scale.y = 0.00005;
      ovens[index].position.y = wallWidth * 2;
      scene.add(ovens[index]);
    }

    //finishTops
    for (let k = 0; k < finishTops.length; k++) {
      finishTops[k].visible = false;
      // scene.add(finishTops[k]);
    }

    // Set planes as 2D

    camera.position.set(0, 5, 0.8);
    controls.target.set(0, 0, 0.8);
    controls.enabled = false;
    // window.camera = camera
    // window.controls = controls
    // controls.enablePan = false;
    // controls.enableRotate = false;

    planeFront.visible = true;
    planeFront.scale.y = 0.00001;
    planeFront.position.y = 0.12;

    scene.add(planeFront);
    planeLeftCoordinates.scale = planeLeft.scale.y;
    planeLeft.scale.y = 0.00001;
    planeLeftCoordinates.position = planeLeft.position.y;
    planeLeft.position.y = 0.12;

    // planeLeft.material.color = new Color('#FFFFFF');
    // planeRight.material.color = new Color('#FFFFFF');
    // planeBack.material.color = new Color('#FFFFFF');
    // planeFront.material.color = new Color('#FFFFFF');
    // planeBottom.material.color = new Color('#FFFFFF');

    scene.add(planeLeft);

    planeRightCoordinates.scale = planeRight.scale.y;
    planeRight.scale.y = 0.00001;
    planeRightCoordinates.position = planeRight.position.y;
    planeRight.position.y = 0.12;
    scene.add(planeRight);

    planeBackCoordinates.scale = planeBack.scale.y;
    planeBack.scale.y = 0.00001;
    planeBackCoordinates.position = planeBack.position.y;
    planeBack.position.y = 0.12;
    scene.add(planeRight);
    // scene.add(planeTop);
    // console.log("planeBackCoordinates   ", planeBackCoordinates);
    // console.log("planeRightCoordinates   ", planeRightCoordinates);
    // console.log("planeLeftCoordinates   ", planeLeftCoordinates);
    controls.update();

    //    document.getElementById("2d").innerHTML = "3D";  ////

    await LinesAndText2D(type);

    await essentialText();
    // console.log("Scene ", scene);
    // for (let sc = 0; sc < scene.children.length; sc++) {
    //   console.log("sc ",sc);
    //   if(scene.children[sc].name != ''
    //   && scene.children[sc].name != 'Left cover'
    //   && scene.children[sc].name != 'Right cover'
    //   && scene.children[sc].name != 'Back cover'
    //    && scene.children[sc].name != 'Handle Direction'){

    //     if(scene.children[sc].length == 0){
    //       scene.children[sc].material.wireframe = true;
    //     }else
    //   // if(!scene.children[sc].material.wireframe??''){
    //     for (let index = 0; index < scene.children[sc].children.length; index++) {
    //       // const element = array[index];
    //       scene.children[sc].children[index].material.wireframe = true;

    //     }

    //   // }else{
    //   // scene.children[sc].material.wireframe = true;

    //   // }
    //   }
    // }
    planeTop.visible = false;
  }
  for (let index = 0; index < directions.length; index++) {
    if (is2D) {
      directions[index].visible = true;
    } else {
      directions[index].visible = false;
    }
    directions[index].scale.y = 0.05;
    directions[index].position.y = wallWidth * 2;
  }

  // backLight.visible = true;
  // await deleteLines("SelectedObject");
  // for (let index = 0; index < scene.children.length; index++) {
  //   if (scene.children[index].name === "SelectedObject") {
  //     scene.remove(scene.children[index]);
  //     index--;
  //     continue;
  //   }
  // }
  // document.getElementById("config-popup").style.display = "none";
  // updateChangeDimensions(false);
}

async function dragWall() {
  /// planeLeft
  dragLeftWall = new DragControls([planeLeft], camera, renderer.domElement);

  dragLeftWall.enabled = true;
  dragLeftWall.addEventListener("drag", dragLeft);

  dragLeftWall.addEventListener("dragstart", async function () {
    // console.log("dragstart");
    // console.log("Left");
    if (!is2D) {
      dragLeftWall = false;
      return;
    }
    controls.enabled = false;
    planeLeft.visible = false;
    planeRight.visible = false;
    planeFront.visible = false;
    planeBack.visible = false;
    for await (const object of scene.children) {
      if (
        object.name == "planeFront" ||
        object.name == "planeBack" ||
        object.name == "planeRight"
      ) {
        scene.remove(object);
      }
    }
    // await deleteLines();

    await deleteLines(null, "Es-line");
  });
  dragLeftWall.addEventListener("dragend", async function () {
    if (!is2D) {
      dragLeftWall = false;
      return;
    }
    for await (let object of scene.children) {
      if (object.userData.type == "Es-line" || object.type == "Line") {
        scene.remove(object);
        // index = index - 1;
      }
    }
    // await setChanges("planeLeft");
    window.W = measuresXG.max - measuresXG.min;
    window.L = measuresZG.max - measuresZG.min;
    await walls("wallLeft");

    planeLeft.visible = true;
    // dragLeftWall = new DragControls([planeLeft], camera, renderer.domElement);
    // dragRightWall = new DragControls([planeRight], camera, renderer.domElement);
    // dragBackWall = new DragControls([planeBack], camera, renderer.domElement);
    // dragFrontWall = new DragControls([planeFront], camera, renderer.domElement);

    await dragWall();
    controls.update();
  });
  /// planeRight
  dragRightWall = new DragControls([planeRight], camera, renderer.domElement);

  dragRightWall.addEventListener("drag", dragRight);

  dragRightWall.addEventListener("dragstart", async function () {
    if (!is2D) {
      dragRightWall = false;
      return;
    }

    controls.enabled = false;

    // console.log("Right");

    planeLeft.visible = false;
    planeRight.visible = false;
    planeFront.visible = false;
    planeBack.visible = false;
    for await (const object of scene.children) {
      if (
        object.name == "planeFront" ||
        object.name == "planeBack" ||
        object.name == "planeLeft"
      ) {
        scene.remove(object);
      }
    }
    // await deleteLines();

    await deleteLines(null, "Es-line");
  });
  dragRightWall.addEventListener("dragend", async function () {
    //   controls.enabled = true;
    //   planeRight.visible = true;

    // await setChanges("planeRight");
    // await walls("wallRight");
    if (!is2D) {
      dragRightWall = false;
      return;
    }
    for await (let object of scene.children) {
      if (object.userData.type == "Es-line" || object.type == "Line") {
        scene.remove(object);
        // index = index - 1;
      }
    }
    // await setChanges("planeRight");

    window.W = measuresXG.max - measuresXG.min;
    window.L = measuresZG.max - measuresZG.min;

    await walls("wallRight");
    planeRight.visible = true;
    // dragLeftWall = new DragControls([planeLeft], camera, renderer.domElement);
    // dragRightWall = new DragControls([planeRight], camera, renderer.domElement);
    // dragBackWall = new DragControls([planeBack], camera, renderer.domElement);
    // dragFrontWall = new DragControls([planeFront], camera, renderer.domElement);
    await dragWall();
    // controls.enabled = false;
    controls.update();
  });

  /// planeBack
  dragBackWall = new DragControls([planeBack], camera, renderer.domElement);
  dragBackWall.addEventListener("drag", dragBack);

  dragBackWall.addEventListener("dragstart", async function () {
    if (!is2D) {
      dragBackWall = false;
      return;
    }

    controls.enabled = false;
    planeLeft.visible = false;
    planeRight.visible = false;
    planeFront.visible = false;
    planeBack.visible = false;
    // console.log("Back");
    for await (const object of scene.children) {
      if (
        object.name == "planeFront" ||
        object.name == "planeLeft" ||
        object.name == "planeRight"
      ) {
        scene.remove(object);
      }
    }
    // await deleteLines();

    await deleteLines(null, "Es-line");
  });
  dragBackWall.addEventListener("dragend", async function () {
    if (!is2D) {
      dragBackWall = false;
      return;
    }
    for await (let object of scene.children) {
      if (object.userData.type == "Es-line" || object.type == "Line") {
        scene.remove(object);
        // index = index - 1;
      }
    }
    // await setChanges("planeBack");
    // await walls("wallBack");
    window.W = measuresXG.max - measuresXG.min;
    window.L = measuresZG.max - measuresZG.min;
    await walls("wallBack");

    planeBack.visible = true;
    // dragLeftWall = new DragControls([planeLeft], camera, renderer.domElement);
    // dragRightWall = new DragControls([planeRight], camera, renderer.domElement);
    // dragBackWall = new DragControls([planeBack], camera, renderer.domElement);
    // dragFrontWall = new DragControls([planeFront], camera, renderer.domElement);
    await dragWall();
    // controls.enabled = false;
    controls.update();
  });

  /// planeFront
  dragFrontWall = new DragControls([planeFront], camera, renderer.domElement);
  dragFrontWall.addEventListener("drag", dragFront);

  dragFrontWall.addEventListener("dragstart", async function () {
    if (!is2D) {
      dragFrontWall = false;
      return;
    }

    controls.enabled = false;
    planeLeft.visible = false;
    planeRight.visible = false;
    planeFront.visible = false;
    planeBack.visible = false;
    // console.log("Front");
    for await (const object of scene.children) {
      if (
        object.name == "planeBack" ||
        object.name == "planeLeft" ||
        object.name == "planeRight"
      ) {
        scene.remove(object);
      }
    }
    await deleteLines(null, "Es-line");

    // await deleteLines();
  });
  dragFrontWall.addEventListener("dragend", async function () {
    if (!is2D) {
      dragFrontWall = false;
      return;
    }
    for await (let object of scene.children) {
      if (object.userData.type == "Es-line" || object.type == "Line") {
        scene.remove(object);
        // index = index - 1;
      }
    }
    // await setChanges("planeFront");
    // await walls("wallFront");
    window.W = measuresXG.max - measuresXG.min;
    window.L = measuresZG.max - measuresZG.min;

    planeFront.visible = true;
    await walls("wallFront");

    // dragLeftWall = new DragControls([planeLeft], camera, renderer.domElement);
    // dragRightWall = new DragControls([planeRight], camera, renderer.domElement);
    // dragBackWall = new DragControls([planeBack], camera, renderer.domElement);
    // dragFrontWall = new DragControls([planeFront], camera, renderer.domElement);
    await dragWall();
    // controls.enabled = false;
    controls.update();
  });
}

async function LinesAndText2D(update = false, typeLine = "") {
  if (update == false) {
    // console.log("deleteLines");
    await deleteLines(null, "Es-line");
  }

  // // Draw essential lines
  // const material = new LineBasicMaterial({ color: 0x0000ff });
  // const points = [];
  // // Top Line
  // points.push(new Vector3(measuresXG.min, 0, measuresZG.min - 0.6));
  // points.push(new Vector3(+measuresXG.max, 0, measuresZG.min - 0.6));
  // const geometryTop = new BufferGeometry().setFromPoints(points);
  // // console.log('geometryTop  ' ,geometryTop);
  // if (update == true) {
  //   lineTop.geometry = geometryTop;
  //   lineTop.geometry.attributes.position.needsUpdate = true;
  //   // console.log("geometryTop  ", lineTop.geometry);
  // } else {
  //   lineTop = new Line(geometryTop, material);
  //   lineTop.userData.type = "Es-line";
  //   lineTop.userData.wall = "width";
  //   // lineTop.geometry.setDrawRange()S
  //   // console.log("lineTop  ", lineTop);
  // }
  // scene.add(lineTop);

  // // Left Line
  // while (points.length > 0) {
  //   points.pop();
  // }

  // points.push(new Vector3(measuresXG.min - 0.6, 0, measuresZG.max));

  // points.push(new Vector3(measuresXG.min - 0.6, 0, measuresZG.min));

  // const geometryLeft = new BufferGeometry().setFromPoints(points);
  // if (update == true) {
  //   lineLeft.geometry = geometryLeft;
  //   lineLeft.geometry.attributes.position.needsUpdate = true;
  //   // console.log("geometryLeft  ", lineLeft.geometry);
  //   scene.add(lineLeft);
  // } else {
  //   lineLeft = new Line(geometryLeft, material);
  //   lineLeft.userData.type = "Es-line";
  //   lineLeft.userData.wall = "length";
  //   // lineTop.geometry.setDrawRange()S
  //   // console.log("lineLeft  ", lineLeft);
  //   scene.add(lineLeft);
  // }

  // // Right Line
  // while (points.length > 0) {
  //   points.pop();
  // }

  // points.push(new Vector3(measuresXG.max + 0.6, 0, measuresZG.max));

  // points.push(new Vector3(measuresXG.max + 0.6, 0, measuresZG.min));

  // const geometryRight = new BufferGeometry().setFromPoints(points);

  // if (update == true) {
  //   lineRight.geometry = geometryRight;
  //   lineRight.geometry.attributes.position.needsUpdate = true;
  //   // console.log("geometryTop  ", lineRight.geometry);
  // } else {
  //   lineRight = new Line(geometryRight, material);
  //   lineRight.userData.type = "Es-line";
  //   lineRight.userData.wall = "length";
  //   // lineTop.geometry.setDrawRange()S
  //   // console.log("lineRight  ", lineRight);
  // }

  // // lineRight = new Line(geometryRight, material);
  // // lineRight.userData.type = "Line";
  // // lineRight.userData.wall = "length";

  // scene.add(lineRight);

  // // Bottom Line
  // while (points.length > 0) {
  //   points.pop();
  // }

  // points.push(new Vector3(measuresXG.min, 0, measuresZG.max + 0.6));

  // points.push(new Vector3(+measuresXG.max, 0, measuresZG.max + 0.6));

  // const geometryBottom = new BufferGeometry().setFromPoints(points);

  // if (update == true) {
  //   lineBottom.geometry = geometryBottom;
  //   lineBottom.geometry.attributes.position.needsUpdate = true;
  //   // console.log("geometryTop  ", lineBottom.geometry);
  // } else {
  //   lineBottom = new Line(geometryBottom, material);
  //   lineBottom.userData.type = "Es-line";
  //   lineBottom.userData.wall = "width";
  //   // lineTop.geometry.setDrawRange()S
  //   // console.log("lineRight  ", lineBottom);
  // }

  // // lineRight = new Line(geometryRight, material);
  // // lineRight.userData.type = "Line";
  // // lineRight.userData.wall = "length";

  // scene.add(lineBottom);

  // /// End essential lines

  if (!update) {
    // const materialLine = new LineBasicMaterial({ color: 0x000000 });
    // const materialObjects = new LineBasicMaterial({ color: 0xff0000 });
    // const materialRight = new LineBasicMaterial({ color: 0x000000 });
    let distanceTop = 0.2;
    // let distanceBottom = 0.4;
    // let distanceLeft = 0.4;
    // let distanceRight = 0.4;
    let positionsZTopLines = [];
    let positionsZBottomLines = [];
    let positionsXLeftLines = [];
    let positionsXRightLines = [];

    // Draw lines of objects
    for (let index = 0; index < objects.length; index++) {
      if (
        objects[index].rotation.y == degrees_to_radians(0) &&
        objects[index].position.z === measuresZG.min + wallWidth &&
        objects[index].name !== "W"
      ) {
        const from = objects[index].position.x - objects[index].userData.W;
        drawLine(
          from,
          measuresZG.min - distanceTop,
          objects[index].position.x,
          measuresZG.min - distanceTop,
          null,
          materialObjects,
          0.2
        );

        positionsZTopLines.push({
          begin: from,
          width: objects[index].userData.W,
        });

        writeText(
          objects[index].userData.W,
          from + objects[index].userData.W / 2,
          measuresZG.min - 0.15 - distanceTop,
          null,
          0.2
        );
      } else if (
        objects[index].rotation.y == degrees_to_radians(180) &&
        objects[index].position.z === measuresZG.max - wallWidth &&
        objects[index].name !== "W"
      ) {
        // Draw lines of objects
        const from = objects[index].position.x;
        drawLine(
          from,
          measuresZG.max + distanceTop,
          objects[index].position.x + objects[index].userData.W,
          measuresZG.max + distanceTop,
          null,
          materialObjects,
          0.2
        );

        positionsZBottomLines.push({
          begin: from,
          width: objects[index].userData.W,
        });

        writeText(
          objects[index].userData.W,
          from + objects[index].userData.W / 2,
          measuresZG.max + distanceTop + 0.15,
          null,
          0.2
        );
      } else if (
        objects[index].rotation.y == degrees_to_radians(-90) &&
        objects[index].position.x === measuresXG.max - wallWidth &&
        objects[index].name !== "W"
      ) {
        // Draw lines of objects
        const from = objects[index].position.z - objects[index].userData.W;
        drawLine(
          +measuresXG.max + distanceTop,
          from,
          +measuresXG.max + distanceTop,
          objects[index].position.z,
          null,
          materialObjects,
          0.2
        );

        positionsXRightLines.push({
          begin: from,
          width: objects[index].userData.W,
        });

        writeText(
          objects[index].userData.W,
          +measuresXG.max + distanceTop + 0.15,
          from + objects[index].userData.W / 2,
          "x+",
          0.2
        );
      } else if (
        objects[index].rotation.y == degrees_to_radians(90) &&
        objects[index].position.x === measuresXG.min + wallWidth &&
        objects[index].name !== "W"
      ) {
        // Draw lines of objects
        const from = objects[index].position.z;
        drawLine(
          measuresXG.min - distanceTop,
          from,
          measuresXG.min - distanceTop,
          objects[index].position.z + objects[index].userData.W,
          null,
          materialObjects,
          0.2
        );

        positionsXLeftLines.push({
          begin: from,
          width: objects[index].userData.W,
        });

        writeText(
          objects[index].userData.W,
          measuresXG.min - distanceTop - 0.15,
          from + objects[index].userData.W / 2,
          "x-",
          0.2
        );
      }
    }
    // console.log("typeLine    ", typeLine);
    // if(typeLine == '' || typeLine == 'back'){
    positionsZTopLines?.sort((a, b) => (a.begin > b.begin ? 1 : -1));
    for (let index = 0; index < positionsZTopLines.length; index++) {
      var positions = [];

      if (
        index === 0 &&
        -(measuresXG.min + wallWidth) + positionsZTopLines[index].begin > 0
      ) {
        drawLine(
          measuresXG.min + wallWidth,
          measuresZG.min - distanceTop,
          positionsZTopLines[index].begin,
          measuresZG.min - distanceTop,
          positions,
          materialRight,
          0.2
        );

        writeText(
          -(measuresXG.min + wallWidth) + positionsZTopLines[index].begin,
          (measuresXG.min + positionsZTopLines[index].begin) / 2,
          measuresZG.min - 0.15 - distanceTop,
          null,
          0.2
        );
      } else {
        positions.push(
          measuresXG.min + wallWidth,
          0.2,
          measuresZG.min - distanceTop
        );
        positions.push(
          positionsZTopLines[index].begin,
          0.2,
          measuresZG.min - distanceTop
        );
      }
      let finishPoint = 0;
      if (index < positionsZTopLines.length - 1) {
        finishPoint = positionsZTopLines[index + 1].begin;
      } else {
        finishPoint = measuresXG.max - wallWidth;
      }

      /// x1,z1,x2,z2,positions,material
      const text =
        finishPoint -
        (positionsZTopLines[index].begin + positionsZTopLines[index].width);

      if (text > 0) {
        drawLine(
          positionsZTopLines[index].begin + positionsZTopLines[index].width,
          measuresZG.min - distanceTop,
          finishPoint,
          measuresZG.min - distanceTop,
          positions,
          materialRight,
          0.2
        );

        const x =
          positionsZTopLines[index].begin +
          positionsZTopLines[index].width +
          (finishPoint -
            (positionsZTopLines[index].begin +
              positionsZTopLines[index].width)) /
            2;
        const z = measuresZG.min - 0.15 - distanceTop;
        writeText(text, x, z, null, 0.2);
      } else {
        positions.push(
          positionsZTopLines[index].begin + positionsZTopLines[index].width,
          0.2,
          measuresZG.min - distanceTop
        );
        positions.push(finishPoint, 0.2, measuresZG.min - distanceTop);
      }

      // positions

      var geometry = new BufferGeometry();
      geometry.setAttribute(
        "position",
        new Float32BufferAttribute(positions, 3)
      );

      geometry.computeBoundingSphere();

      var materialPoints = new PointsMaterial({
        size: 0.04,
        vertexColors: new MeshPhongMaterial({ color: 0xff0000 }),
      });

      let points = new Points(geometry, materialPoints);
      points.name = "points";
      scene.add(points);
    }
    // }

    // if(typeLine == '' || typeLine == 'front'){
    positionsZBottomLines?.sort((a, b) => (a.begin > b.begin ? 1 : -1));
    for (let index = 0; index < positionsZBottomLines.length; index++) {
      var positions = [];

      if (
        index === 0 &&
        -(measuresXG.min + wallWidth) + positionsZBottomLines[index].begin > 0
      ) {
        drawLine(
          measuresXG.min + wallWidth,
          measuresZG.max + distanceTop,
          positionsZBottomLines[index].begin,
          measuresZG.max + distanceTop,
          positions,
          materialRight,
          0.2
        );
        // console.log("positionsZBottomLines[index].begin + measuresXG.max  " ,positionsZBottomLines[index].begin + measuresXG.max);
        // console.log("measuresXG.max  " , measuresXG.max);
        // console.log("positionsZBottomLines[index].begin  " ,positionsZBottomLines[index].begin);
        writeText(
          -(measuresXG.min + wallWidth) + positionsZBottomLines[index].begin,
          (measuresXG.min + wallWidth + positionsZBottomLines[index].begin) / 2,
          measuresZG.max + 0.15 + distanceTop,
          null,
          0.2
        );
      } else {
        positions.push(
          measuresXG.min + wallWidth,
          0.2,
          measuresZG.max + distanceTop
        );
        positions.push(
          positionsZBottomLines[index].begin,
          0.2,
          measuresZG.max + distanceTop
        );
      }
      let finishPoint = 0;
      if (index < positionsZBottomLines.length - 1) {
        finishPoint = positionsZBottomLines[index + 1].begin;
      } else {
        finishPoint = measuresXG.max - wallWidth;
      }

      /// x1,z1,x2,z2,positions,material
      const text =
        finishPoint -
        (positionsZBottomLines[index].begin +
          positionsZBottomLines[index].width);

      if (text > 0) {
        drawLine(
          positionsZBottomLines[index].begin +
            positionsZBottomLines[index].width,
          measuresZG.max + distanceTop,
          finishPoint,
          measuresZG.max + distanceTop,
          positions,
          materialRight,
          0.2
        );

        const x =
          positionsZBottomLines[index].begin +
          positionsZBottomLines[index].width +
          (finishPoint -
            (positionsZBottomLines[index].begin +
              positionsZBottomLines[index].width)) /
            2;
        const z = measuresZG.max + 0.15 + distanceTop;
        writeText(text, x, z, null, 0.2);
      } else {
        positions.push(
          positionsZBottomLines[index].begin +
            positionsZBottomLines[index].width,
          0.2,
          measuresZG.max + distanceTop
        );
        positions.push(finishPoint, 0.2, measuresZG.max + distanceTop);
      }

      // positions

      var geometry = new BufferGeometry();
      geometry.setAttribute(
        "position",
        new Float32BufferAttribute(positions, 3)
      );

      geometry.computeBoundingSphere();

      var materialPoints = new PointsMaterial({
        size: 0.04,
        vertexColors: new MeshPhongMaterial({ color: 0xff0000 }),
      });

      let points = new Points(geometry, materialPoints);
      points.name = "points";
      scene.add(points);
    }
    // }

    // if(typeLine == '' || typeLine == 'left'){
    positionsXLeftLines?.sort((a, b) => (a.begin > b.begin ? 1 : -1));
    for (let index = 0; index < positionsXLeftLines.length; index++) {
      var positions = [];

      if (
        index === 0 &&
        -(measuresZG.min + wallWidth) + positionsXLeftLines[index].begin > 0
      ) {
        drawLine(
          measuresXG.min - distanceTop,
          measuresZG.min + wallWidth,
          measuresXG.min - distanceTop,
          positionsXLeftLines[index].begin,
          positions,
          materialRight,
          0.2
        );
        // positionsXLeftLines[index].begin + measuresZG.max,

        writeText(
          -(measuresZG.min + wallWidth) + positionsXLeftLines[index].begin,
          // positionsXLeftLines[index].begin + measuresZG.max,

          measuresXG.min - 0.15 - distanceTop,
          (measuresZG.min + positionsXLeftLines[index].begin) / 2,
          "x-",
          0.2
        );
      } else {
        positions.push(
          measuresXG.min - distanceTop,
          0.2,
          measuresZG.min + wallWidth
        );
        positions.push(
          measuresXG.min - distanceTop,
          0.2,
          positionsXLeftLines[index].begin
        );
      }
      let finishPoint = 0;
      if (index < positionsXLeftLines.length - 1) {
        finishPoint = positionsXLeftLines[index + 1].begin;
      } else {
        finishPoint = measuresZG.max - wallWidth;
      }

      /// x1,z1,x2,z2,positions,material
      const text =
        finishPoint -
        (positionsXLeftLines[index].begin + positionsXLeftLines[index].width);

      if (text > 0) {
        drawLine(
          measuresXG.min - distanceTop,
          positionsXLeftLines[index].begin + positionsXLeftLines[index].width,
          measuresXG.min - distanceTop,
          finishPoint,
          positions,
          materialRight,
          0.2
        );

        const z =
          positionsXLeftLines[index].begin +
          positionsXLeftLines[index].width +
          (finishPoint -
            (positionsXLeftLines[index].begin +
              positionsXLeftLines[index].width)) /
            2;

        const x = measuresXG.min - 0.15 - distanceTop;
        writeText(text, x, z, "x-", 0.2);
      } else {
        positions.push(
          measuresXG.min - distanceTop,
          0.2,
          positionsXLeftLines[index].begin + positionsXLeftLines[index].width
        );
        positions.push(measuresXG.min - distanceTop, 0.2, finishPoint);
      }

      // positions

      var geometry = new BufferGeometry();
      geometry.setAttribute(
        "position",
        new Float32BufferAttribute(positions, 3)
      );

      geometry.computeBoundingSphere();

      var materialPoints = new PointsMaterial({
        size: 0.04,
        vertexColors: new MeshPhongMaterial({ color: 0xff0000 }),
      });

      let points = new Points(geometry, materialPoints);
      points.name = "points";
      scene.add(points);
    }
    // }

    // if(typeLine == '' || typeLine == 'right'){
    positionsXRightLines?.sort((a, b) => (a.begin > b.begin ? 1 : -1));
    for (let index = 0; index < positionsXRightLines.length; index++) {
      var positions = [];

      if (
        index === 0 &&
        -(measuresZG.min + wallWidth) + positionsXRightLines[index].begin > 0
      ) {
        drawLine(
          measuresXG.max + distanceTop,
          measuresZG.min + wallWidth,
          measuresXG.max + distanceTop,
          positionsXRightLines[index].begin,
          positions,
          materialRight,
          0.2
        );
        // positionsXRightLines[index].begin + measuresZG.max,
        writeText(
          -(measuresZG.min + wallWidth) + positionsXRightLines[index].begin,
          // positionsXRightLines[index].begin + measuresZG.max,

          +measuresXG.max + 0.15 + distanceTop,
          (measuresZG.min + positionsXRightLines[index].begin) / 2,
          "x+"
        );
      } else {
        positions.push(
          measuresXG.max + distanceTop,
          0.2,
          measuresZG.min + wallWidth
        );
        positions.push(
          measuresXG.max + distanceTop,
          0.2,
          positionsXRightLines[index].begin
        );
      }
      let finishPoint = 0;
      if (index < positionsXRightLines.length - 1) {
        finishPoint = positionsXRightLines[index + 1].begin;
      } else {
        finishPoint = measuresZG.max - wallWidth;
      }

      /// x1,z1,x2,z2,positions,material
      const text =
        finishPoint -
        (positionsXRightLines[index].begin + positionsXRightLines[index].width);

      if (text > 0) {
        drawLine(
          measuresXG.max + distanceTop,
          positionsXRightLines[index].begin + positionsXRightLines[index].width,
          measuresXG.max + distanceTop,
          finishPoint,
          positions,
          materialRight,
          0.2
        );

        const z =
          positionsXRightLines[index].begin +
          positionsXRightLines[index].width +
          (finishPoint -
            (positionsXRightLines[index].begin +
              positionsXRightLines[index].width)) /
            2;
        const x = +measuresXG.max + 0.15 + distanceTop;
        writeText(text, x, z, "x+", 0.2);
      } else {
        positions.push(
          measuresXG.max + distanceTop,
          0.2,
          positionsXRightLines[index].begin + positionsXRightLines[index].width
        );
        positions.push(measuresXG.max + distanceTop, 0.2, finishPoint);
      }

      // positions

      var geometry = new BufferGeometry();
      geometry.setAttribute(
        "position",
        new Float32BufferAttribute(positions, 3)
      );

      geometry.computeBoundingSphere();

      var materialPoints = new PointsMaterial({
        size: 0.04,
        vertexColors: new MeshPhongMaterial({ color: 0xff0000 }),
      });

      let points = new Points(geometry, materialPoints);
      points.name = "points";
      scene.add(points);
    }
    // }
  }
  render();
}

function drawLine(x1, z1, x2, z2, positions, material, y = 0) {
  let points = [];
  points.push(new Vector3(x1, y, z1));
  points.push(new Vector3(x2, y, z2));
  if (positions) {
    positions.push(x1, y, z1);
    positions.push(x2, y, z2);
  }

  const geometryFirst = new BufferGeometry().setFromPoints(points);
  const lineFirst = new Line(geometryFirst, material);
  lineFirst.userData.type = "Line";
  scene.add(lineFirst);
  return lineFirst;
}

function writeText(text, x, z, type = null, y = 0) {
  const loaderr = new FontLoader();
  loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
    const color = new Color(0x00000);

    const matLite = new MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 0.6,
      side: DoubleSide,
    });

    const shapes = font.generateShapes("" + Math.ceil(text * 1000), 150);
    const geometry = new ShapeGeometry(shapes);
    geometry.computeBoundingBox();
    geometry.translate(
      -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x),
      0,
      0
    );

    const textContent = new Mesh(geometry, matLite);
    textContent.position.set(x, y, z);
    textContent.scale.set(0.0006, 0.0006, 0.0006);
    if (type == "x+") {
      textContent.rotation.x = degrees_to_radians(270);
      textContent.rotation.z = degrees_to_radians(-90);
    } else if (type == "x-") {
      textContent.rotation.x = degrees_to_radians(270);
      textContent.rotation.z = degrees_to_radians(90);
    } else if (type == "y+") {
      textContent.rotation.x = degrees_to_radians(0);
      textContent.rotation.z = degrees_to_radians(90);
    } else {
      textContent.rotation.x = degrees_to_radians(-90);
    }
    textContent.userData.type = "Text";

    scene.add(textContent);

    render();
  }); //end load function
}

// Delete Lines,Points,Text, SelectedObjects and Es-lines
async function deleteLines(type = null, line = "Line") {
  // type for selection object
  // line for Es-line lines
  if (type == null) {
    for (let index = 0; index < scene.children.length; index++) {
      if (
        scene.children[index].userData.type === "Line" ||
        scene.children[index].userData.type === line ||
        scene.children[index].name === "points" ||
        scene.children[index].userData.type === "Text" ||
        scene.children[index].name === "SelectedObject"
      ) {
        scene.remove(scene.children[index]);
        index--;
        continue;
      }
    }
  } else {
    for (let index = 0; index < scene.children.length; index++) {
      if (scene.children[index].name === type) {
        scene.remove(scene.children[index]);
        index--;
        continue;
      }
    }
  }
}

let drawR = false,
  drawL = false,
  drawF = false,
  drawB = false,
  drawT = false,
  drawBO = false;

window.calcMeasuresFunc = async () => {
  RightLine = new Measures();
  RightWallLine = new Measures();
  LeftLine = new Measures();
  LeftWallLine = new Measures();
  FrontLine = new Measures();
  BackLine = new Measures();
  TopLine = new Measures();
  BottomLine = new Measures();
  WallRightLine = new Measures();
  WallLeftLine = new Measures();
  // console.log("calcMeasuresFunc enter ");
  // console.log("uuidSelected.length    " , uuidSelected.length);

  if (uuidSelected.length > 0) {
    // for (let i = 0; i < 1; i++) {
    // console.log("i  = ", i);
    for (let index = 0; index < objects.length; index++) {
      if (objects[index].uuid === uuidSelected[0]) {
        let j;
        // console.log("Here 111222");
        (drawR = false), (drawL = false), (drawF = false), (drawB = false);
        obj = objects[index];
        uuidOfMeasures = uuidSelected[0];
        let maxRight = 0;
        let maxTop = 0;
        let maxBottom = 0;
        let maxLeft = 0;
        let maxFront = 0;
        let maxBack = 0;
        let centerX = 0;
        let centerZ = 0;
        let hasChangedRight = false;
        let hasChangedLeft = false;
        var component = new Box3().setFromObject(objects[index]);
        var center = component.getCenter(new Vector3());
        centerX = center.x;
        centerZ = center.z;
        if (objects[index].rotation.y == degrees_to_radians(0)) {
          centerZ = center.z + 3;
          // Right Line
          if (
            objects[index].position.x - objects[index].userData.W >
            measuresXG.min + wallWidth
          ) {
            maxRight = measuresXG.min;
            RightLine.line1X = maxRight;
            RightLine.line2X =
              objects[index].position.x - objects[index].userData.W;
            RightLine.line1Z =
              objects[index].position.z + objects[index].userData.L / 2;
            RightLine.line2Z =
              objects[index].position.z + objects[index].userData.L / 2;
            drawR = true;
          }
          // Left Line
          if (objects[index].position.x < +measuresXG.max - wallWidth) {
            maxLeft = +measuresXG.max;
            LeftLine.line1X = maxLeft;
            LeftLine.line2X = objects[index].position.x;
            LeftLine.line1Z =
              objects[index].position.z + objects[index].userData.L / 2;
            LeftLine.line2Z =
              objects[index].position.z + objects[index].userData.L / 2;
            drawL = true;
          }
          // Front Line
          if (
            objects[index].position.z + objects[index].userData.L <
            measuresZG.max - wallWidth
          ) {
            maxFront = measuresZG.max;
            FrontLine.line1X =
              objects[index].position.x - objects[index].userData.W / 2;
            FrontLine.line2X =
              objects[index].position.x - objects[index].userData.W / 2;
            FrontLine.line1Z = maxFront;
            FrontLine.line2Z =
              objects[index].position.z + objects[index].userData.L;
            drawF = true;
          }
          // Back Line
          if (objects[index].position.z > measuresZG.min + wallWidth) {
            maxBack = measuresZG.min;
            BackLine.line1X =
              objects[index].position.x - objects[index].userData.W / 2;
            BackLine.line2X =
              objects[index].position.x - objects[index].userData.W / 2;
            BackLine.line1Z = maxBack;
            BackLine.line2Z = objects[index].position.z;
            drawB = true;
          }

          // Top Line and Bottom Line for wall unit
          // console.log("objects[index].position.y   " ,objects[index].position.y );
          if (objects[index].position.y > 0.1) {
            // Top Line
            maxTop = objects[index].position.x - objects[index].userData.W / 2;
            TopLine.line1X = maxTop;
            TopLine.line2X = maxTop;
            TopLine.line1Z =
              objects[index].position.z + objects[index].userData.L / 2;
            TopLine.line2Z =
              objects[index].position.z + objects[index].userData.L / 2;
            drawT = true;

            // Bottom Line
            maxBottom =
              objects[index].position.x - objects[index].userData.W / 2;
            BottomLine.line1X = maxBottom;
            BottomLine.line2X = maxBottom;
            BottomLine.line1Z =
              objects[index].position.z + objects[index].userData.L / 2;
            BottomLine.line2Z =
              objects[index].position.z + objects[index].userData.L / 2;
            drawBO = true;
          }
        } else if (objects[index].rotation.y == degrees_to_radians(180)) {
          centerZ = center.z - 3;
          // Right Line
          if (
            objects[index].position.x + objects[index].userData.W <
            measuresXG.max - wallWidth
          ) {
            maxRight = measuresXG.max;
            RightLine.line1X = maxRight;
            RightLine.line2X =
              objects[index].position.x + objects[index].userData.W;
            RightLine.line1Z =
              objects[index].position.z - objects[index].userData.L / 2;
            RightLine.line2Z =
              objects[index].position.z - objects[index].userData.L / 2;
            drawR = true;
          }
          // Left Line
          if (objects[index].position.x > measuresXG.min + wallWidth) {
            maxLeft = measuresXG.min;
            LeftLine.line1X = maxLeft;
            LeftLine.line2X = objects[index].position.x;
            LeftLine.line1Z =
              objects[index].position.z - objects[index].userData.L / 2;
            LeftLine.line2Z =
              objects[index].position.z - objects[index].userData.L / 2;
            drawL = true;
          }
          // Front Line
          if (
            objects[index].position.z - objects[index].userData.L >
            measuresZG.min + wallWidth
          ) {
            maxFront = measuresZG.min;
            FrontLine.line1X =
              objects[index].position.x + objects[index].userData.W / 2;
            FrontLine.line2X =
              objects[index].position.x + objects[index].userData.W / 2;
            FrontLine.line1Z = maxFront;
            FrontLine.line2Z =
              objects[index].position.z - objects[index].userData.L;
            drawF = true;
          }
          // Back Line
          if (objects[index].position.z < measuresZG.max - wallWidth) {
            maxBack = measuresZG.max;
            BackLine.line1X =
              objects[index].position.x + objects[index].userData.W / 2;
            BackLine.line2X =
              objects[index].position.x + objects[index].userData.W / 2;
            BackLine.line1Z = maxBack;
            BackLine.line2Z = objects[index].position.z;
            drawB = true;
          }
          // Top Line and Bottom Line for wall unit
          if (objects[index].position.y > 0.1) {
            // Top Line
            maxTop = objects[index].position.x + objects[index].userData.W / 2;
            TopLine.line1X = maxTop;
            TopLine.line2X = maxTop;
            TopLine.line1Z =
              objects[index].position.z - objects[index].userData.L / 2;
            TopLine.line2Z =
              objects[index].position.z - objects[index].userData.L / 2;
            drawT = true;

            // Bottom Line
            maxBottom =
              objects[index].position.x + objects[index].userData.W / 2;
            BottomLine.line1X = maxBottom;
            BottomLine.line2X = maxBottom;
            BottomLine.line1Z =
              objects[index].position.z - objects[index].userData.L / 2;
            BottomLine.line2Z =
              objects[index].position.z - objects[index].userData.L / 2;
            drawBO = true;
          }
        } else if (objects[index].rotation.y == degrees_to_radians(-90)) {
          centerX = center.x - 3;

          // Right Line
          if (
            objects[index].position.z - objects[index].userData.W >
            measuresZG.min + wallWidth
          ) {
            maxRight = measuresZG.min;
            RightLine.line1X =
              +objects[index].position.x - objects[index].userData.L / 2;
            RightLine.line2X =
              +objects[index].position.x - objects[index].userData.L / 2;
            RightLine.line1Z = maxRight;
            RightLine.line2Z =
              objects[index].position.z - objects[index].userData.W;
            drawR = true;
          }
          // Left Line
          if (objects[index].position.z < measuresZG.max - wallWidth) {
            maxLeft = measuresZG.max;
            LeftLine.line1X =
              +objects[index].position.x - objects[index].userData.L / 2;
            LeftLine.line2X =
              +objects[index].position.x - objects[index].userData.L / 2;
            LeftLine.line1Z = maxLeft;
            LeftLine.line2Z = objects[index].position.z;
            drawL = true;
          }
          // Front Line
          if (
            objects[index].position.x - objects[index].userData.L >
            measuresXG.min + wallWidth
          ) {
            maxFront = measuresXG.min;
            FrontLine.line1X = maxFront;
            FrontLine.line2X =
              objects[index].position.x - objects[index].userData.L;
            FrontLine.line1Z =
              objects[index].position.z - objects[index].userData.W / 2;
            FrontLine.line2Z =
              objects[index].position.z - objects[index].userData.W / 2;
            drawF = true;
          }
          // Back Line
          if (objects[index].position.x < measuresXG.max - wallWidth) {
            maxBack = measuresXG.max;
            BackLine.line1X = maxBack;
            BackLine.line2X = objects[index].position.x;
            BackLine.line1Z =
              objects[index].position.z - objects[index].userData.W / 2;
            BackLine.line2Z =
              objects[index].position.z - objects[index].userData.W / 2;
            drawB = true;
          }

          // Top Line and Bottom Line for wall unit
          if (objects[index].position.y > 0.1) {
            // Top Line
            maxTop = objects[index].position.z - objects[index].userData.W / 2;
            TopLine.line1X =
              objects[index].position.x - objects[index].userData.L / 2;
            TopLine.line2X =
              objects[index].position.x - objects[index].userData.L / 2;
            TopLine.line1Z = maxTop;
            TopLine.line2Z = maxTop;
            drawT = true;

            // Bottom Line
            maxBottom =
              objects[index].position.z - objects[index].userData.W / 2;
            BottomLine.line1X =
              objects[index].position.x - objects[index].userData.L / 2;
            BottomLine.line2X =
              objects[index].position.x - objects[index].userData.L / 2;
            BottomLine.line1Z = maxBottom;
            BottomLine.line2Z = maxBottom;
            drawBO = true;
          }
        } else {
          centerX = center.x + 3;

          // Right Line
          if (
            objects[index].position.z + objects[index].userData.W <
            measuresZG.max - wallWidth
          ) {
            maxRight = measuresZG.max;
            RightLine.line1X =
              +objects[index].position.x + objects[index].userData.L / 2;
            RightLine.line2X =
              +objects[index].position.x + objects[index].userData.L / 2;
            RightLine.line1Z = maxRight;
            RightLine.line2Z =
              objects[index].position.z + objects[index].userData.W;
            drawR = true;
          }
          // Left Line
          if (objects[index].position.z > measuresZG.min + wallWidth) {
            maxLeft = measuresZG.min;
            LeftLine.line1X =
              +objects[index].position.x + objects[index].userData.L / 2;
            LeftLine.line2X =
              +objects[index].position.x + objects[index].userData.L / 2;
            LeftLine.line1Z = maxLeft;
            LeftLine.line2Z = objects[index].position.z;
            drawL = true;
          }
          // Front Line
          if (
            objects[index].position.x + objects[index].userData.L <
            measuresXG.max - wallWidth
          ) {
            maxFront = +measuresXG.max;
            FrontLine.line1X = maxFront;
            FrontLine.line2X =
              objects[index].position.x + objects[index].userData.L;
            FrontLine.line1Z =
              objects[index].position.z + objects[index].userData.W / 2;
            FrontLine.line2Z =
              objects[index].position.z + objects[index].userData.W / 2;
            drawF = true;
          }
          // Back Line
          if (objects[index].position.x > measuresXG.min + wallWidth) {
            maxBack = measuresXG.min;
            BackLine.line1X = maxBack;
            BackLine.line2X = objects[index].position.x;
            BackLine.line1Z =
              objects[index].position.z + objects[index].userData.W / 2;
            BackLine.line2Z =
              objects[index].position.z + objects[index].userData.W / 2;
            drawB = true;
          }
          // Top Line and Bottom Line for wall unit
          if (objects[index].position.y > 0.1) {
            // Top Line
            maxTop = objects[index].position.z + objects[index].userData.W / 2;
            TopLine.line1X =
              objects[index].position.x + objects[index].userData.L / 2;
            TopLine.line2X =
              objects[index].position.x + objects[index].userData.L / 2;
            TopLine.line1Z = maxTop;
            TopLine.line2Z = maxTop;
            drawT = true;

            // Bottom Line
            maxBottom =
              objects[index].position.z + objects[index].userData.W / 2;
            BottomLine.line1X =
              objects[index].position.x + objects[index].userData.L / 2;
            BottomLine.line2X =
              objects[index].position.x + objects[index].userData.L / 2;
            BottomLine.line1Z = maxBottom;
            BottomLine.line2Z = maxBottom;
            drawBO = true;
          }
        }

        for await (const object of objects) {
          if (
            objects.length > 1 &&
            object.uuid != objects[index].uuid &&
            object.name == objects[index].name
          ) {
            if (
              object.rotation.y == degrees_to_radians(0) &&
              objects[index].rotation.y == degrees_to_radians(0)
            ) {
              if (
                maxRight < object.position.x &&
                ((object.position.z >= objects[index].position.z &&
                  object.position.z <=
                    objects[index].position.z + objects[index].userData.L) ||
                  (object.position.z + objects[index].userData.L >=
                    objects[index].position.z &&
                    object.position.z + objects[index].userData.L <=
                      objects[index].position.z + objects[index].userData.L)) &&
                object.position.x <=
                  objects[index].position.x - objects[index].userData.W
              ) {
                maxRight = object.position.x;
                RightLine.line1X = object.position.x;
                drawR = true;
                hasChangedRight = true;
              }

              if (
                maxLeft > object.position.x &&
                ((object.position.z >= objects[index].position.z &&
                  object.position.z <=
                    objects[index].position.z + objects[index].userData.L) ||
                  (object.position.z + objects[index].userData.L >=
                    objects[index].position.z &&
                    object.position.z + objects[index].userData.L <=
                      objects[index].position.z + objects[index].userData.L)) &&
                object.position.x > objects[index].position.x
              ) {
                maxLeft = object.position.x - object.userData.W;
                LeftLine.line1X = object.position.x - object.userData.W;
                drawL = true;
                hasChangedLeft = true;
              }

              if (
                maxFront > object.position.z &&
                ((object.position.x <= objects[index].position.x &&
                  object.position.x >=
                    objects[index].position.x - objects[index].userData.W) ||
                  (object.position.x - objects[index].userData.W <=
                    objects[index].position.x &&
                    object.position.x - objects[index].userData.W >=
                      objects[index].position.x - objects[index].userData.W)) &&
                object.position.z > objects[index].position.z
              ) {
                maxFront = object.position.z;
                FrontLine.line1Z = object.position.z;
                drawF = true;
              }

              if (
                maxBack < object.position.z &&
                ((object.position.x <= objects[index].position.x &&
                  object.position.x >=
                    objects[index].position.x - objects[index].userData.W) ||
                  (object.position.x - objects[index].userData.W <=
                    objects[index].position.x &&
                    object.position.x - objects[index].userData.W >=
                      objects[index].position.x - objects[index].userData.W)) &&
                object.position.z < objects[index].position.z
              ) {
                maxFront = object.position.z + object.userData.L;
                BackLine.line1Z = object.position.z + object.userData.L;
                drawB = true;
              }
            } else if (
              object.rotation.y == degrees_to_radians(90) &&
              objects[index].rotation.y == degrees_to_radians(90)
            ) {
              // console.log("HERE");
              if (
                maxRight > object.position.z &&
                ((object.position.x >= objects[index].position.x &&
                  object.position.x <=
                    objects[index].position.x + objects[index].userData.L) ||
                  (object.position.x + objects[index].userData.L >=
                    objects[index].position.x &&
                    object.position.x + objects[index].userData.L <=
                      objects[index].position.x + objects[index].userData.L)) &&
                object.position.z >=
                  objects[index].position.z + objects[index].userData.W
              ) {
                maxRight = object.position.z;
                RightLine.line1Z = object.position.z;
                drawR = true;
                hasChangedRight = true;
                // await drawLines(objects[index].userData.L/2);
              }

              if (
                maxLeft < object.position.z &&
                ((object.position.x >= objects[index].position.x &&
                  object.position.x <=
                    objects[index].position.x + objects[index].userData.L) ||
                  (object.position.x + objects[index].userData.L >=
                    objects[index].position.x &&
                    object.position.x + objects[index].userData.L <=
                      objects[index].position.x + objects[index].userData.L)) &&
                object.position.z < objects[index].position.z
              ) {
                maxLeft = object.position.z + object.userData.W;
                LeftLine.line1Z = object.position.z + object.userData.W;
                drawL = true;
                hasChangedLeft = true;
              }

              if (
                maxFront > object.position.x &&
                ((object.position.z >= objects[index].position.z &&
                  object.position.z <=
                    objects[index].position.z + objects[index].userData.W) ||
                  (object.position.z + objects[index].userData.W >=
                    objects[index].position.z &&
                    object.position.z + objects[index].userData.W <=
                      objects[index].position.z + objects[index].userData.W)) &&
                object.position.x > objects[index].position.x
              ) {
                maxFront = object.position.x;
                FrontLine.line1X = object.position.x;
                drawF = true;
                // console.log("object.position.x  ", object.position.x);
                // console.log(
                //   "objects[index].position.x  ",
                //   objects[index].position.x
                // );
                // console.log(
                //   "objects[index].position.x  ",
                //   objects[index].position.x
                // );
                // console.log("FrontLine  ", FrontLine);
              }
              if (
                maxBack < object.position.x &&
                ((object.position.z >= objects[index].position.z &&
                  object.position.z <=
                    objects[index].position.z + objects[index].userData.W) ||
                  (object.position.z + objects[index].userData.W >=
                    objects[index].position.z &&
                    object.position.z + objects[index].userData.W <=
                      objects[index].position.z + objects[index].userData.W)) &&
                object.position.x < objects[index].position.x
              ) {
                maxBack = object.position.x + object.userData.L;
                BackLine.line1X = object.position.x + object.userData.L;
                drawB = true;
              }
            } else if (
              object.rotation.y == degrees_to_radians(180) &&
              objects[index].rotation.y == degrees_to_radians(180)
            ) {
              if (
                maxRight > object.position.x &&
                ((object.position.z <= objects[index].position.z &&
                  object.position.z >=
                    objects[index].position.z - objects[index].userData.L) ||
                  (object.position.z - objects[index].userData.L <
                    objects[index].position.z &&
                    object.position.z - objects[index].userData.L >
                      objects[index].position.z - objects[index].userData.L)) &&
                object.position.x >=
                  objects[index].position.x + objects[index].userData.W
              ) {
                maxRight = object.position.x;
                RightLine.line1X = object.position.x;
                // console.log("Here lines ");
                drawR = true;
                hasChangedRight = true;
                // await drawLines(objects[index].userData.L/2);
              }

              if (
                maxLeft < object.position.x &&
                ((object.position.z <= objects[index].position.z &&
                  object.position.z >=
                    objects[index].position.z - objects[index].userData.L) ||
                  (object.position.z - objects[index].userData.L <
                    objects[index].position.z &&
                    object.position.z - objects[index].userData.L >
                      objects[index].position.z - objects[index].userData.L)) &&
                object.position.x < objects[index].position.x
              ) {
                maxLeft = object.position.x + object.userData.W;
                LeftLine.line1X = object.position.x + object.userData.W;
                drawL = true;
                hasChangedLeft = true;
              }

              if (
                maxFront < object.position.z &&
                ((object.position.x >= objects[index].position.x &&
                  object.position.x <=
                    objects[index].position.x + objects[index].userData.W) ||
                  (object.position.x + objects[index].userData.W >
                    objects[index].position.x &&
                    object.position.x + objects[index].userData.W <
                      objects[index].position.x + objects[index].userData.W)) &&
                object.position.z < objects[index].position.z
              ) {
                maxFront = object.position.z;
                FrontLine.line1Z = object.position.z;
                drawF = true;
              }

              if (
                maxBack > object.position.z &&
                ((object.position.x >= objects[index].position.x &&
                  object.position.x <=
                    objects[index].position.x + objects[index].userData.W) ||
                  (object.position.x + objects[index].userData.W >
                    objects[index].position.x &&
                    object.position.x + objects[index].userData.W <
                      objects[index].position.x + objects[index].userData.W)) &&
                object.position.z > objects[index].position.z
              ) {
                maxFront = object.position.z - object.userData.L;
                BackLine.line1Z = object.position.z - object.userData.L;
                drawB = true;
              }
            } else if (
              object.rotation.y == degrees_to_radians(-90) &&
              objects[index].rotation.y == degrees_to_radians(-90)
            ) {
              // console.log("HERE 2 ");
              if (
                maxRight < object.position.z &&
                ((object.position.x <= objects[index].position.x &&
                  object.position.x >=
                    objects[index].position.x - objects[index].userData.L) ||
                  (object.position.x - objects[index].userData.L <
                    objects[index].position.x &&
                    object.position.x - objects[index].userData.L >
                      objects[index].position.x - objects[index].userData.L)) &&
                object.position.z <=
                  objects[index].position.z - objects[index].userData.W
              ) {
                maxRight = object.position.z;
                RightLine.line1Z = object.position.z;
                drawR = true;
                hasChangedRight = true;
              }

              if (
                maxLeft > object.position.z &&
                ((object.position.x <= objects[index].position.x &&
                  object.position.x >=
                    objects[index].position.x - objects[index].userData.L) ||
                  (object.position.x - objects[index].userData.L <
                    objects[index].position.x &&
                    object.position.x - objects[index].userData.L >
                      objects[index].position.x - objects[index].userData.L)) &&
                object.position.z > objects[index].position.z
              ) {
                maxLeft = object.position.z - object.userData.W;
                LeftLine.line1Z = object.position.z - object.userData.W;
                drawL = true;
                hasChangedLeft = true;
              }

              if (
                maxFront < object.position.x &&
                ((object.position.z <= objects[index].position.z &&
                  object.position.z >=
                    objects[index].position.z - objects[index].userData.W) ||
                  (object.position.z - objects[index].userData.W <
                    objects[index].position.z &&
                    object.position.z - objects[index].userData.W >
                      objects[index].position.z - objects[index].userData.W)) &&
                object.position.x < objects[index].position.x
              ) {
                maxFront = object.position.x;
                FrontLine.line1X = object.position.x;
                drawF = true;
              }

              if (
                maxBack > object.position.x &&
                ((object.position.z <= objects[index].position.z &&
                  object.position.z >=
                    objects[index].position.z - objects[index].userData.W) ||
                  (object.position.z - objects[index].userData.W <
                    objects[index].position.z &&
                    object.position.z - objects[index].userData.W >
                      objects[index].position.z - objects[index].userData.W)) &&
                object.position.x > objects[index].position.x
              ) {
                maxBack = object.position.x - object.userData.L;
                BackLine.line1X = object.position.x - object.userData.L;
                drawB = true;
              }
            }
          }
        }
        let y = 0;
        heightText = objects[index].position.y + objects[index].userData.H / 2;
        if (objects[index].position.y > 0)
          y = objects[index].position.y + objects[index].userData.H / 2;
        else y = objects[index].userData.L / 2;

        if (is2D) y = wallWidth;
        // await drawLines();
        // Right line
        const material = new LineBasicMaterial({ color: 0x000000 });
        // console.log("drawR   ", drawR);
        if (drawR == true) {
          const points = [];
          // Right Line
          points.push(new Vector3(RightLine.line1X, y, RightLine.line1Z));
          points.push(new Vector3(RightLine.line2X, y, RightLine.line2Z));
          const geometryTop = new BufferGeometry().setFromPoints(points);

          let lineRight = new Line(geometryTop, material);
          lineRight.userData.type = "measures-line";
          scene.add(lineRight);
          RightLine.setValX();
          RightLine.setValZ();
        }
        if (drawL == true) {
          const points1 = [];
          // Left Line
          points1.push(new Vector3(LeftLine.line1X, y, LeftLine.line1Z));
          points1.push(new Vector3(LeftLine.line2X, y, LeftLine.line2Z));
          const geometryTop1 = new BufferGeometry().setFromPoints(points1);

          let lineRight1 = new Line(geometryTop1, material);
          lineRight1.userData.type = "measures-line";
          scene.add(lineRight1);

          LeftLine.setValX();
          LeftLine.setValZ();
        }
        if (drawB == true) {
          const points2 = [];
          // Back Line
          points2.push(new Vector3(BackLine.line1X, y, BackLine.line1Z));
          points2.push(new Vector3(BackLine.line2X, y, BackLine.line2Z));
          const geometryTop2 = new BufferGeometry().setFromPoints(points2);

          let lineRight2 = new Line(geometryTop2, material);
          lineRight2.userData.type = "measures-line";
          scene.add(lineRight2);
          // console.log("BackLine   ", BackLine);
          BackLine.setValX();
          BackLine.setValZ();
        }

        if (drawF == true) {
          const points3 = [];
          // Front Line
          points3.push(new Vector3(FrontLine.line1X, y, FrontLine.line1Z));
          points3.push(new Vector3(FrontLine.line2X, y, FrontLine.line2Z));
          const geometryTop3 = new BufferGeometry().setFromPoints(points3);

          let lineRight3 = new Line(geometryTop3, material);
          lineRight3.userData.type = "measures-line";
          scene.add(lineRight3);
          FrontLine.setValX();
          FrontLine.setValZ();
        }

        if (!is2D) {
          if (drawT == true) {
            const points3 = [];
            // Top Line
            points3.push(
              new Vector3(
                TopLine.line1X,
                objects[index].position.y + objects[index].userData.H,
                TopLine.line1Z
              )
            );
            points3.push(
              new Vector3(TopLine.line2X, measures.height, TopLine.line2Z)
            );
            const geometryTop3 = new BufferGeometry().setFromPoints(points3);

            let lineRight3 = new Line(geometryTop3, material);
            lineRight3.userData.type = "measures-line";
            scene.add(lineRight3);
            TopLine.setValX();
            TopLine.setValZ();
          }

          if (drawBO == true) {
            const points3 = [];
            // Front Line
            points3.push(
              new Vector3(
                BottomLine.line1X,
                objects[index].position.y,
                BottomLine.line1Z
              )
            );
            points3.push(new Vector3(BottomLine.line2X, 0, BottomLine.line2Z));
            const geometryTop3 = new BufferGeometry().setFromPoints(points3);

            let lineRight3 = new Line(geometryTop3, material);
            lineRight3.userData.type = "measures-line";
            scene.add(lineRight3);
            BottomLine.setValX();
            BottomLine.setValZ();
          }
        }
        // Lines between walls and the object in case it found another object beside it.
        if (objects[index].position.y > 0.1) {
          if (hasChangedRight == true) {
            if (objects[index].rotation.y == degrees_to_radians(0)) {
              RightWallLine.line1X =
                objects[index].position.x - objects[index].userData.W;
              RightWallLine.line2X = measuresXG.min;
              RightWallLine.line1Z = objects[index].position.z + 0.1;
              RightWallLine.line2Z = objects[index].position.z + 0.1;
            } else if (objects[index].rotation.y == degrees_to_radians(180)) {
              RightWallLine.line1X =
                objects[index].position.x + objects[index].userData.W;
              RightWallLine.line2X = measuresXG.max;
              RightWallLine.line1Z = objects[index].position.z - 0.1;
              RightWallLine.line2Z = objects[index].position.z - 0.1;
            } else if (objects[index].rotation.y == degrees_to_radians(90)) {
              RightWallLine.line1X = objects[index].position.x + 0.1;
              RightWallLine.line2X = objects[index].position.x + 0.1;
              RightWallLine.line1Z =
                objects[index].position.z + objects[index].userData.W;
              RightWallLine.line2Z = measuresZG.max;
            } else {
              RightWallLine.line1X = objects[index].position.x - 0.1;
              RightWallLine.line2X = objects[index].position.x - 0.1;
              RightWallLine.line1Z =
                objects[index].position.z - objects[index].userData.W;
              RightWallLine.line2Z = measuresZG.min;
            }

            const points3 = [];
            // Front Line
            points3.push(
              new Vector3(
                RightWallLine.line1X,
                measures.height,
                RightWallLine.line1Z
              )
            );
            points3.push(
              new Vector3(
                RightWallLine.line2X,
                measures.height,
                RightWallLine.line2Z
              )
            );
            const geometryTop3 = new BufferGeometry().setFromPoints(points3);

            let lineRight3 = new Line(geometryTop3, material);
            lineRight3.userData.type = "measures-line";
            scene.add(lineRight3);
            RightWallLine.setValX();
            RightWallLine.setValZ();
          }

          if (hasChangedLeft == true) {
            if (objects[index].rotation.y == degrees_to_radians(0)) {
              LeftWallLine.line1X = objects[index].position.x;
              LeftWallLine.line2X = measuresXG.max;
              LeftWallLine.line1Z = objects[index].position.z + 0.1;
              LeftWallLine.line2Z = objects[index].position.z + 0.1;
            } else if (objects[index].rotation.y == degrees_to_radians(180)) {
              LeftWallLine.line1X = objects[index].position.x;
              LeftWallLine.line2X = measuresXG.min;
              LeftWallLine.line1Z = objects[index].position.z - 0.1;
              LeftWallLine.line2Z = objects[index].position.z - 0.1;
            } else if (objects[index].rotation.y == degrees_to_radians(90)) {
              LeftWallLine.line1X = objects[index].position.x + 0.1;
              LeftWallLine.line2X = objects[index].position.x + 0.1;
              LeftWallLine.line1Z = objects[index].position.z;
              LeftWallLine.line2Z = measuresZG.min;
            } else {
              LeftWallLine.line1X = objects[index].position.x - 0.1;
              LeftWallLine.line2X = objects[index].position.x - 0.1;
              LeftWallLine.line1Z = objects[index].position.z;
              LeftWallLine.line2Z = measuresZG.max;
            }

            const points3 = [];
            // Front Line
            points3.push(
              new Vector3(
                LeftWallLine.line1X,
                measures.height,
                LeftWallLine.line1Z
              )
            );
            points3.push(
              new Vector3(
                LeftWallLine.line2X,
                measures.height,
                LeftWallLine.line2Z
              )
            );
            const geometryTop3 = new BufferGeometry().setFromPoints(points3);

            let lineRight3 = new Line(geometryTop3, material);
            lineRight3.userData.type = "measures-line";
            scene.add(lineRight3);
            LeftWallLine.setValX();
            LeftWallLine.setValZ();
          }
        }

        if (!is2D) {
          gsap.to(camera.position, {
            duration: 1,
            x: centerX,
            y: center.y,
            z: centerZ, // maybe adding even more offset depending on your model
            onUpdate: async function () {
              await camera.lookAt(center);
            },
          });
        }
        setTimeout(
          () => {
            if (drawR == true) {
              showText(RightLine, "Right", heightText);
            }

            if (drawL == true) {
              showText(LeftLine, "Left", heightText);
            }
            if (drawF == true) {
              showText(FrontLine, "Front", heightText);
            }
            // if(objects[index].position.x > -measures.width/2 + wallWidth){

            // console.log("OKKKKKKKKKKKKK");
            if (drawB == true) {
              showText(BackLine, "Back", heightText);
            }
            if (!is2D) {
              if (drawT == true) {
                // console.log("drawT    ", drawT);

                heightTopText =
                  (measures.height -
                    (objects[index].position.y + objects[index].userData.H)) /
                    2 +
                  objects[index].position.y +
                  objects[index].userData.H;
                TopLine.object = objects[index];
                showText(TopLine, "Top", heightTopText);
              }

              if (drawBO == true) {
                // console.log("drawBO    ", drawBO);
                heightBottomText = objects[index].position.y / 2;
                BottomLine.object = objects[index];
                showText(BottomLine, "Bottom", heightBottomText);
              }
            }
            if (objects[index].position.y > 0.1) {
              if (hasChangedRight == true) {
                showText(RightWallLine, "RightWall", measures.height);
              }
              if (hasChangedLeft == true) {
                showText(LeftWallLine, "LeftWall", measures.height);
              }
            }
            render();
          },
          is2D ? 10 : 1000
        );
        break;
      }
    }
    // }
    // uuidSelected = [];
    // for (let k = 0; k < scene.children.length; k++) {
    //   if (scene.children[k].name === "SelectedObject") {
    //     scene.remove(scene.children[k]);
    //     k -= 1;
    //   }
    // }
  }
};

async function essentialText() {
  const canvas = renderer.domElement;
  // Essential text Back
  const vectorBack = new Vector3(
    (measuresXG.max + measuresXG.min) / 2,
    0,
    measuresZG.min - 0.6
  );
  vectorBack.project(camera);
  vectorBack.x = ((vectorBack.x + 1) * canvas.width) / 2;
  vectorBack.y = (-(vectorBack.y - 1) * canvas.height) / 2;
  vectorBack.z = 0;

  document.getElementById("es-Back").style.top = `${vectorBack.y}px`;
  document.getElementById("es-Back").style.left = `${vectorBack.x - 35}px`;

  document.getElementById("es-Back").value = Math.ceil(
    (Math.max(measuresXG.min, measuresXG.max) -
      Math.min(measuresXG.min, measuresXG.max)) *
      1000 -
      200
  );

  if (document.getElementById("es-Back").style.display == "none")
    document.getElementById("es-Back").style.display = "flex";

  // Essential text front
  var vectorFront = new Vector3(
    (measuresXG.max + measuresXG.min) / 2,
    0,
    measuresZG.max + 0.6
  );
  vectorFront.project(camera);
  vectorFront.x = ((vectorFront.x + 1) * canvas.width) / 2;
  vectorFront.y = (-(vectorFront.y - 1) * canvas.height) / 2;
  vectorFront.z = 0;

  document.getElementById("es-Front").style.top = `${vectorFront.y}px`;
  document.getElementById("es-Front").style.left = `${vectorFront.x - 35}px`;

  document.getElementById("es-Front").value = Math.ceil(
    (Math.max(measuresXG.min, measuresXG.max) -
      Math.min(measuresXG.min, measuresXG.max)) *
      1000 -
      200
  );

  if (document.getElementById("es-Front").style.display == "none")
    document.getElementById("es-Front").style.display = "flex";

  // Essential text Left
  var vectorLeft = new Vector3(
    measuresXG.max + 0.6,
    0,
    (measuresZG.max + measuresZG.min) / 2
  );
  vectorLeft.project(camera);
  vectorLeft.x = ((vectorLeft.x + 1) * canvas.width) / 2;
  vectorLeft.y = (-(vectorLeft.y - 1) * canvas.height) / 2;
  vectorLeft.z = 0;

  document.getElementById("es-Left").style.top = `${vectorLeft.y}px`;
  document.getElementById("es-Left").style.left = `${vectorLeft.x - 35}px`;
  document.getElementById("es-Left").style.transform = "rotate(-90deg)";

  document.getElementById("es-Left").value = Math.ceil(
    (Math.max(measuresZG.min, measuresZG.max) -
      Math.min(measuresZG.min, measuresZG.max)) *
      1000 -
      200
  );

  if (document.getElementById("es-Left").style.display == "none")
    document.getElementById("es-Left").style.display = "flex";

  // Essential text Right
  var vectorRight = new Vector3(
    measuresXG.min - 0.6,
    0,
    (measuresZG.max + measuresZG.min) / 2
  );
  vectorRight.project(camera);
  vectorRight.x = ((vectorRight.x + 1) * canvas.width) / 2;
  vectorRight.y = (-(vectorRight.y - 1) * canvas.height) / 2;
  vectorRight.z = 0;

  document.getElementById("es-Right").style.top = `${vectorRight.y}px`;
  document.getElementById("es-Right").style.left = `${vectorRight.x - 35}px`;
  document.getElementById("es-Right").style.transform = "rotate(-90deg)";

  document.getElementById("es-Right").value = Math.ceil(
    (Math.max(measuresZG.min, measuresZG.max) -
      Math.min(measuresZG.min, measuresZG.max)) *
      1000 -
      200
  );

  if (document.getElementById("es-Right").style.display == "none")
    document.getElementById("es-Right").style.display = "flex";
}

async function showText(Line, Type, height = 0) {
  // console.log('height   :    ' , height);

  let value = 0;
  if (Type == "Top") {
    value = measures.height - (Line.object.position.y + Line.object.userData.H);
  } else if (Type == "Bottom") {
    value = Line.object.position.y;
  } else {
    // console.log("Line   " , Line);
    if (Line) value = Line.getValue();
  }

  // console.log('Line.valX ', Line.valX ,'y = ', Line.valZ );
  if (Line) {
    const vector = new Vector3(Line.valX, height, Line.valZ);
    const canvas = renderer.domElement;

    vector.project(camera);

    // vector.x = Math.round((0.5 + vector.x / 2) * (canvas.width / window.devicePixelRatio));
    // vector.y = Math.round((0.5 - vector.y / 2) * (canvas.height / window.devicePixelRatio));

    vector.x = ((vector.x + 1) * canvas.width) / 2;
    vector.y = (-(vector.y - 1) * canvas.height) / 2;
    vector.z = 0;

    document.getElementById(Type).style.top = `${vector.y + 0}px`;
    document.getElementById(Type).style.left = `${vector.x - 55}px`;
    // console.log("getValue  Type", Line.getValue() + "   " + Type);
    document.getElementById(Type).value = Math.ceil(value * 1000) - 100 + " mm";

    if (document.getElementById(Type).style.display == "none")
      document.getElementById(Type).style.display = "flex";
  }
}

async function drawLines(y) {
  // console.log('line1X ' , line1X);
  //           console.log('line2X ' , line2X);
  //           console.log('line1z ' , line1Z);
  //           console.log('line1Z ' , line2Z);
  const material = new LineBasicMaterial({ color: 0x000000 });
  const points = [];
  // Right Line
  points.push(new Vector3(line1X, y, line1Z));
  points.push(new Vector3(line2X, y, line2Z));
  const geometryTop = new BufferGeometry().setFromPoints(points);

  let lineRight = new Line(geometryTop, material);
  lineRight.userData.type = "measures-line";
  scene.add(lineRight);
}

window.clearMeasuresLines = async (width, length) => {
  uuidOfMeasures = null;
  for (let index = 0; index < scene.children.length; index++) {
    if (scene.children[index].userData.type === "measures-line") {
      scene.remove(scene.children[index]);
      index--;
      continue;
    }
  }
  document.getElementById("Left").style.display = "none";
  document.getElementById("Right").style.display = "none";
  document.getElementById("Front").style.display = "none";
  document.getElementById("Back").style.display = "none";
  document.getElementById("Top").style.display = "none";
  document.getElementById("Bottom").style.display = "none";
  document.getElementById("RightWall").style.display = "none";
  document.getElementById("LeftWall").style.display = "none";
  RightLine = null;
};

window.updateDimensions = async (width, length) => {
  // console.log("new width ", width);
  // console.log("new length ", length);

  // console.log("new  measuresXG.max ", measuresXG.max);
  // console.log("new  measuresZG.max ", measuresZG.max);
  // console.log("new measuresXG.min ", measuresXG.min);
  // console.log("new measuresXG.min ", measuresXG.min);

  measuresXG.max = measuresXG.min + width;
  measuresZG.min = measuresZG.max - length;

  // measures.width = width;
  // console.log("measures  ", measures);
  // await updateChangeDimensions();
  await essentialText();
  await setChanges();
  await walls();
  for (let index = 0; index < scene.children.length; index++) {
    if (scene.children[index].name == "planeBottom") {
      let plane = new BoxGeometry(
        measuresXG.max - measuresXG.min + 0.2,
        measuresZG.max - measuresZG.min + 0.2,
        0.2
      );
      scene.children[index].geometry = plane;
      scene.children[index].position.z = (measuresZG.max + measuresZG.min) / 2;
      // scene.children[index].material.map.repeat.set(
      //   (measuresXG.max - measuresXG.min) / 0.6,
      //   (measuresZG.max - measuresZG.min) / 0.6
      // );
      break;
    }
  }
  //  render();
};

// function drawLine(point1,point2) {
//   // Bottom Line
//   while (points.length > 0) {
//     points.pop();
//   }

//    const geometry4 = new BufferGeometry().setFromPoints(points);
//    lineBottom = new Line(geometry4, material);
//   scene.add(lineBottom);
// }

let objectLeft = undefined,
  objectRight = undefined;

async function finishTop(objDraggable, dir = undefined) {
  // console.log("Finish top new call");
  // if (objDraggable.userData.hasSink == true) {
  //   // console.log('emptying 33  ',objDraggable.userData.hasSink);
  //   var flag = true;
  //   for (let index = 0; index < emptying.length; index++) {
  //     if(emptying[index].uuid == objDraggable.uuid){
  //       flag = false;
  //       break;
  //     }
  //   }

  //   if(flag == true)emptying.push(objDraggable);

  // }

  let uuid_left = undefined,
    uuid_right = undefined;
  let RightLine = new Measures();
  let LeftLine = new Measures();
  loaderr = new GLTFLoader();
  let j;
  (drawR = false),
    (drawL = false),
    (drawF = false),
    (drawB = false),
    (drawT = false),
    (drawBO = false);
  obj = objDraggable;

  let maxRight = 0;
  let maxLeft = 0;

  if (objDraggable.rotation.y == degrees_to_radians(0)) {
    // Right Line
    if (
      objDraggable.position.x - objDraggable.userData.W >
      measuresXG.min + wallWidth
    ) {
      maxRight = measuresXG.min;
      RightLine.line1X = maxRight;
      RightLine.line2X = objDraggable.position.x - objDraggable.userData.W;
      RightLine.line1Z = objDraggable.position.z + objDraggable.userData.L / 2;
      RightLine.line2Z = objDraggable.position.z + objDraggable.userData.L / 2;

      // drawR = true;
    }
    // Left Line
    if (objDraggable.position.x < measuresXG.max - wallWidth) {
      maxLeft = +measuresXG.max;
      LeftLine.line1X = maxLeft;
      LeftLine.line2X = objDraggable.position.x;
      LeftLine.line1Z = objDraggable.position.z + objDraggable.userData.L / 2;
      LeftLine.line2Z = objDraggable.position.z + objDraggable.userData.L / 2;
      // drawL = true;
    }
  } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
    // Right Line
    if (
      objDraggable.position.x + objDraggable.userData.W <
      measuresXG.max - wallWidth
    ) {
      maxRight = measuresXG.max;
      RightLine.line1X = maxRight;
      RightLine.line2X = objDraggable.position.x + objDraggable.userData.W;
      RightLine.line1Z = objDraggable.position.z - objDraggable.userData.L / 2;
      RightLine.line2Z = objDraggable.position.z - objDraggable.userData.L / 2;
      // drawR = true;
    }
    // Left Line
    if (objDraggable.position.x > measuresXG.min + wallWidth) {
      maxLeft = measuresXG.min;
      LeftLine.line1X = maxLeft;
      LeftLine.line2X = objDraggable.position.x;
      LeftLine.line1Z = objDraggable.position.z - objDraggable.userData.L / 2;
      LeftLine.line2Z = objDraggable.position.z - objDraggable.userData.L / 2;
      // drawL = true;
    }
  } else if (objDraggable.rotation.y == degrees_to_radians(-90)) {
    // Right Line
    if (
      objDraggable.position.z - objDraggable.userData.W >
      measuresZG.min + wallWidth
    ) {
      maxRight = measuresZG.min;
      RightLine.line1X = +objDraggable.position.x - objDraggable.userData.L / 2;
      RightLine.line2X = +objDraggable.position.x - objDraggable.userData.L / 2;
      RightLine.line1Z = maxRight;
      RightLine.line2Z = objDraggable.position.z - objDraggable.userData.W;
      // drawR = true;
    }
    // Left Line
    if (objDraggable.position.z < measuresZG.max - wallWidth) {
      maxLeft = measuresZG.max;
      LeftLine.line1X = +objDraggable.position.x - objDraggable.userData.L / 2;
      LeftLine.line2X = +objDraggable.position.x - objDraggable.userData.L / 2;
      LeftLine.line1Z = maxLeft;
      LeftLine.line2Z = objDraggable.position.z;
      // drawL = true;
    }
  } else {
    // Right Line
    if (
      objDraggable.position.z + objDraggable.userData.W <
      measuresZG.max - wallWidth
    ) {
      maxRight = measuresZG.max;
      RightLine.line1X = +objDraggable.position.x + objDraggable.userData.L / 2;
      RightLine.line2X = +objDraggable.position.x + objDraggable.userData.L / 2;
      RightLine.line1Z = maxRight;
      RightLine.line2Z = objDraggable.position.z + objDraggable.userData.W;
      // drawR = true;
    }
    // Left Line
    if (objDraggable.position.z > measuresZG.min + wallWidth) {
      maxLeft = measuresZG.min;
      LeftLine.line1X = +objDraggable.position.x + objDraggable.userData.L / 2;
      LeftLine.line2X = +objDraggable.position.x + objDraggable.userData.L / 2;
      LeftLine.line1Z = maxLeft;
      LeftLine.line2Z = objDraggable.position.z;
      // drawL = true;
    }
  }

  let rightCoordinates = {
    x: 0,
    z: 0,
  };

  let leftCoordinates = {
    x: 0,
    z: 0,
  };

  for await (const object of objects) {
    if (object.name == "B") {
      var drawTop = false;
      if (
        object.rotation.y == degrees_to_radians(0) ||
        object.rotation.y == degrees_to_radians(180)
      ) {
        if (
          object.position.z == objDraggable.position.z &&
          object.position.y == objDraggable.position.y
        ) {
          drawTop = true;
        }
      } else if (
        object.rotation.y == degrees_to_radians(90) ||
        object.rotation.y == degrees_to_radians(-90)
      ) {
        if (
          object.position.x == objDraggable.position.x &&
          object.position.y == objDraggable.position.y
        ) {
          drawTop = true;
        }
      }

      if (drawTop == true) {
        if (
          object.rotation.y == degrees_to_radians(0) &&
          objDraggable.rotation.y == degrees_to_radians(0)
        ) {
          if (
            (dir == "Right" || dir == undefined) &&
            maxRight < object.position.x &&
            Math.abs(
              objDraggable.position.x -
                objDraggable.userData.W -
                object.position.x
            ) <= 0.2 &&
            ((object.position.z >= objDraggable.position.z &&
              object.position.z <=
                objDraggable.position.z + objDraggable.userData.L) ||
              (object.position.z + objDraggable.userData.L >=
                objDraggable.position.z &&
                object.position.z + objDraggable.userData.L <=
                  objDraggable.position.z + objDraggable.userData.L)) &&
            object.position.x <=
              objDraggable.position.x - objDraggable.userData.W
          ) {
            // console.log("Right HERE");
            maxRight = object.position.x;
            RightLine.line1X = object.position.x;
            drawR = true;
            objBeside = object;
            objBesideRight = object;
            uuid_right = object.uuid;
            objectRight = object;
            if (object.userData.hasSink) {
              emptying.push(object);
            }
          }
          if (
            (dir == "Left" || dir == undefined) &&
            maxLeft > object.position.x &&
            // Math.abs(objDraggable.position.x-object.position.x) <=0.2 &&
            Math.abs(
              objDraggable.position.x - (object.position.x - object.userData.W)
            ) <= 0.2 &&
            ((object.position.z >= objDraggable.position.z &&
              object.position.z <=
                objDraggable.position.z + objDraggable.userData.L) ||
              (object.position.z + objDraggable.userData.L >=
                objDraggable.position.z &&
                object.position.z + objDraggable.userData.L <=
                  objDraggable.position.z + objDraggable.userData.L)) &&
            object.position.x > objDraggable.position.x
          ) {
            maxLeft = object.position.x - object.userData.W;
            LeftLine.line1X = object.position.x - object.userData.W;
            drawL = true;
            objBeside = object;
            objBesideLeft = object;
            uuid_left = object.uuid;
            objectLeft = object;
            if (object.userData.hasSink) {
              emptying.push(object);
            }
          }

          // break;
        } else if (
          object.rotation.y == degrees_to_radians(90) &&
          objDraggable.rotation.y == degrees_to_radians(90)
        ) {
          if (
            (dir == "Right" || dir == undefined) &&
            maxRight > object.position.z &&
            Math.abs(
              objDraggable.position.z +
                objDraggable.userData.W -
                object.position.z
            ) <= 0.2 &&
            ((object.position.x >= objDraggable.position.x &&
              object.position.x <=
                objDraggable.position.x + objDraggable.userData.L) ||
              (object.position.x + objDraggable.userData.L >=
                objDraggable.position.x &&
                object.position.x + objDraggable.userData.L <=
                  objDraggable.position.x + objDraggable.userData.L)) &&
            object.position.z >=
              objDraggable.position.z + objDraggable.userData.W
          ) {
            maxRight = object.position.z;
            RightLine.line1Z = object.position.z;
            drawR = true;
            objBeside = object;
            objBesideRight = object;

            uuid_right = object.uuid;
            objectRight = object;
            if (object.userData.hasSink) {
              emptying.push(object);
            }
            // await drawLines(objDraggable.userData.L/2);
          }

          if (
            (dir == "Left" || dir == undefined) &&
            maxLeft < object.position.z &&
            Math.abs(
              objDraggable.position.z - (object.position.z + object.userData.W)
            ) <= 0.2 &&
            ((object.position.x >= objDraggable.position.x &&
              object.position.x <=
                objDraggable.position.x + objDraggable.userData.L) ||
              (object.position.x + objDraggable.userData.L >=
                objDraggable.position.x &&
                object.position.x + objDraggable.userData.L <=
                  objDraggable.position.x + objDraggable.userData.L)) &&
            object.position.z < objDraggable.position.z
          ) {
            maxLeft = object.position.z + object.userData.W;
            LeftLine.line1Z = object.position.z + object.userData.W;
            drawL = true;
            objBeside = object;
            objBesideLeft = object;
            if (object.userData.hasSink) {
              emptying.push(object);
            }
            uuid_left = object.uuid;
            objectLeft = object;
          }

          // break;
        } else if (
          object.rotation.y == degrees_to_radians(180) &&
          objDraggable.rotation.y == degrees_to_radians(180)
        ) {
          if (
            (dir == "Right" || dir == undefined) &&
            maxRight > object.position.x &&
            Math.abs(
              objDraggable.position.x +
                objDraggable.userData.W -
                object.position.x
            ) <= 0.2 &&
            ((object.position.z <= objDraggable.position.z &&
              object.position.z >=
                objDraggable.position.z - objDraggable.userData.L) ||
              (object.position.z - objDraggable.userData.L <
                objDraggable.position.z &&
                object.position.z - objDraggable.userData.L >
                  objDraggable.position.z - objDraggable.userData.L)) &&
            object.position.x >=
              objDraggable.position.x + objDraggable.userData.W
          ) {
            maxRight = object.position.x;
            RightLine.line1X = object.position.x;

            drawR = true;
            objBeside = object;
            objBesideRight = object;
            if (object.userData.hasSink) {
              emptying.push(object);
            }
            uuid_right = object.uuid;
            objectRight = object;

            // await drawLines(objDraggable.userData.L/2);
          }

          if (
            (dir == "Left" || dir == undefined) &&
            maxLeft < object.position.x &&
            Math.abs(
              objDraggable.position.x - (object.position.x + object.userData.W)
            ) <= 0.2 &&
            ((object.position.z <= objDraggable.position.z &&
              object.position.z >=
                objDraggable.position.z - objDraggable.userData.L) ||
              (object.position.z - objDraggable.userData.L <
                objDraggable.position.z &&
                object.position.z - objDraggable.userData.L >
                  objDraggable.position.z - objDraggable.userData.L)) &&
            object.position.x < objDraggable.position.x
          ) {
            maxLeft = object.position.x + object.userData.W;
            LeftLine.line1X = object.position.x + object.userData.W;
            drawL = true;
            objBeside = object;
            objBesideLeft = object;
            if (object.userData.hasSink) {
              emptying.push(object);
            }
            uuid_left = object.uuid;
            objectLeft = object;
          }

          // break;
        } else if (
          object.rotation.y == degrees_to_radians(-90) &&
          objDraggable.rotation.y == degrees_to_radians(-90)
        ) {
          if (
            (dir == "Right" || dir == undefined) &&
            maxRight < object.position.z &&
            Math.abs(
              objDraggable.position.z -
                objDraggable.userData.W -
                object.position.z
            ) <= 0.2 &&
            ((object.position.x <= objDraggable.position.x &&
              object.position.x >=
                objDraggable.position.x - objDraggable.userData.L) ||
              (object.position.x - objDraggable.userData.L <
                objDraggable.position.x &&
                object.position.x - objDraggable.userData.L >
                  objDraggable.position.x - objDraggable.userData.L)) &&
            object.position.z <=
              objDraggable.position.z - objDraggable.userData.W
          ) {
            maxRight = object.position.z;
            RightLine.line1Z = object.position.z;
            drawR = true;
            objBeside = object;
            objBesideRight = object;
            if (object.userData.hasSink) {
              emptying.push(object);
            }
            uuid_right = object.uuid;
            objectRight = object;
          }

          if (
            (dir == "Left" || dir == undefined) &&
            maxLeft > object.position.z &&
            Math.abs(
              objDraggable.position.z - (object.position.z - object.userData.W)
            ) <= 0.2 &&
            ((object.position.x <= objDraggable.position.x &&
              object.position.x >=
                objDraggable.position.x - objDraggable.userData.L) ||
              (object.position.x - objDraggable.userData.L <
                objDraggable.position.x &&
                object.position.x - objDraggable.userData.L >
                  objDraggable.position.x - objDraggable.userData.L)) &&
            object.position.z > objDraggable.position.z
          ) {
            maxLeft = object.position.z - object.userData.W;
            LeftLine.line1Z = object.position.z - object.userData.W;
            drawL = true;
            objBeside = object;
            objBesideLeft = object;
            if (object.userData.hasSink) {
              emptying.push(object);
            }
            uuid_left = object.uuid;
            objectLeft = object;
          }
          // break;
        }
      }
    }
  }

  if (uuid_left) {
    uuidsLeft.push(objectLeft);
    // if (!uuids.includes(objectLeft.uuid))
    uuids.push(objectLeft.uuid);
    // for (let index = 0; index < finishTops.length; index++) {
    //   if(objectLeft.userData.finish_uuid == finishTops[index].uuid){
    //     finishTops.splice(index,1);
    //     break;
    //   }

    // }
    if (objectLeft.name == "B") await finishTop(objectLeft, "Left");
    else return;
  }

  if (uuid_right) {
    uuidsRight.push(objectRight);
    // if (!uuids.includes(objectRight.uuid))
    uuids.push(objectRight.uuid);

    //  for (let index = 0; index < objectRight.length; index++) {
    //   if(objectLeft.userData.finish_uuid == objectRight[index].uuid){
    //     objectRight.splice(index,1);
    //     break;
    //   }
    // }
    if (objectRight.name == "B") await finishTop(objectRight, "Right");
    else return;
  }
}

window.objects = objects;

window.W = measuresXG.max - measuresXG.min;
window.L = measuresZG.max - measuresZG.min;

// $("#waterSupply").click(function (event) {
//   // console.log("Clicked");
//   $("#waterSupplyModal").modal("show");
//   // const canvas = document.querySelector("#water_shape");
//   // console.log(canvas);

//   // const renderer = new WebGLRenderer({
//   //   canvas: canvas,
//   //   antialias: true,
//   //   preserveDrawingBuffer: true,
//   // });
//   // renderer.setPixelRatio(window.devicePixelRatio);
//   // renderer.setSize(466, 400);
//   // // container.appendChild(renderer.domElement);
//   // renderer.shadowMap.enabled = true;

//   // const scene = new Scene();
//   // // const Box = new BoxGeometry(2,2,2);
//   // // const mesh = new Mesh(Box,new MeshBasicMaterial({color:'#ff55dd'}));
//   // scene.background = new Color(0xfffff8);

//   // let planeGeo = new BoxGeometry(
//   //   8,
//   //   0,
//   //   4
//   // );
//   // const directionalLightRight = new DirectionalLight("#ffffff", 3.2);
//   // directionalLightRight.position.set(
//   //   +measuresXG.max - 0.3,

//   // );
//   // directionalLightRight.castShadow = true;
//   // directionalLightRight.receiveShadow = true;
//   // directionalLightRight.shadow.normalBias = 0.05;
//   // console.log("directionalLightRight added");
//   // scene.add(directionalLightRight);

//   // const textureLoader = new TextureLoader();
//   // let texture = textureLoader.load("/colors/MC8.png");
//   // texture.wrapS = texture.wrapT = RepeatWrapping;
//   // let planeBottom = new Mesh(
//   //   planeGeo,
//   //   new MeshBasicMaterial({ color: '#DDC3A7' })
//   // );
//   // // planeBottom.rotateX(-Math.PI / 2);
//   // planeBottom.castShadow = true;
//   // planeBottom.receiveShadow = true;
//   // // planeBottom.name = "planeBottom";

//   // scene.add(planeBottom);

//   // let camera = new PerspectiveCamera(
//   //   75,
//   //   window.innerWidth / window.innerHeight,
//   //   1,
//   //   1000
//   // );

//   // //  camera = new OrthographicCamera( -2, 2, -10, 2, 1, 1000 );
//   // //  scene.add( camera );

//   // let controls = new OrbitControls(camera, renderer.domElement);
//   // camera.position.set(0, 5, 0);
//   // controls.target.set(0, 0, 0);
//   // controls.enabled = true;

//   // controls.minDistance = 1;
//   //   controls.maxDistance = 3000;
//   //   controls.rotateSpeed = 2.5;
//   //   controls.zoomSpeed = 6;
//   //   controls.panSpeed = 3.5;
//   //   controls.update();
//   // renderer.shadowMap.type = PCFShadowMap;
//   // renderer.shadowMap.enabled = true;
//   // renderer.render(scene, camera);
//   // window.scene = scene;
// });

window.reset = () => {
  scene = new Scene();
  objects = [];
  finishTops = [];
  uuidSelected = [];
  leftCovers = [];
  rightCovers = [];
  backCovers = [];
  wallPanels = [];
  init();
};

// function removeObject3D(object) {
//   if (!(object instanceof Object3D)) return false;
//   // for better memory management and performance
//   if (object.geometry) {
//     object.geometry.dispose();
//   }
//   if (object.material) {
//     if (object.material instanceof Array) {
//       // for better memory management and performance
//       object.material.forEach((material) => material.dispose());
//     } else {
//       // for better memory management and performance
//       object.material.dispose();
//     }
//   }
//   if (object.parent) {
//     object.parent.remove(object);
//   }
//   // the parent might be the scene or another Object3D, but it is sure to be removed this way
//   return true;
// }

window.applyChangeMeasures = async (type, newValue) => {
  // console.log("new value", newValue);
  // console.log("type ", type);
  let objUuid = uuidOfMeasures;
  let objDraggable = null;
  if (obj) {
    for (let index = 0; index < scene.children.length; index++) {
      if (scene.children[index].uuid == objUuid) {
        newValue = Number(newValue);
        newValue += 100;
        // console.log("new value", newValue);

        if (scene.children[index].rotation.y == degrees_to_radians(0)) {
          if (type == "Left") {
            var oldValue = LeftLine.getValue();
            // console.log("oldValue  ", oldValue);
            // console.log(
            //   "oldValue - newValue / 1000  ",
            //   oldValue - newValue / 1000
            // );

            scene.children[index].position.x += oldValue - newValue / 1000;
            // scene.children[index].position.x += ((oldValue - newValue / 1000) > measuresXG.max)?  measuresXG.max : (oldValue - newValue / 1000);
          } else if (type == "Right") {
            var oldValue = RightLine.getValue();
            // scene.children[index].position.x += ((newValue / 1000 - oldValue) < measuresXG.min)?  measuresXG.min : (newValue / 1000 - oldValue);
            scene.children[index].position.x += newValue / 1000 - oldValue;
          } else if (type == "Top") {
            scene.children[index].position.y =
              measures.height -
              newValue / 1000 -
              scene.children[index].userData.H;
            // scene.children[index].position.y = (( measures.height -
            //   newValue / 1000 -
            //   scene.children[index].userData.H) > measures.height - scene.children[index].userData.H)?  measures.height - scene.children[index].userData.H : (measures.height -
            //     newValue / 1000 -
            //     scene.children[index].userData.H)
            //   ;
          } else if (type == "Bottom") {
            // console.log("type  ", type);
            // scene.children[index].position.y = ((newValue / 1000 - scene.children[index].position.y) < wallWidth)?  wallWidth : (newValue / 1000 - scene.children[index].position.y);
            scene.children[index].position.y = newValue / 1000;
            // console.log("type  ", scene.children[index].position.y);
          } else if (type == "Front") {
            var oldValue = FrontLine.getValue();
            // scene.children[index].position.z += ((oldValue - newValue / 1000) > measuresZG.max)?  measuresZG.max : (oldValue - newValue / 1000);
            scene.children[index].position.z += oldValue - newValue / 1000;
          } else if (type == "Back") {
            var oldValue = BackLine.getValue();
            // scene.children[index].position.z += ((newValue / 1000 - oldValue) < measuresZG.min)?  measuresZG.min : (newValue / 1000 - oldValue);
            scene.children[index].position.z += newValue / 1000 - oldValue;
          } else if (type == "RightWall") {
            // scene.children[index].position.x = ((measuresXG.min +
            //   newValue / 1000 +
            //   scene.children[index].userData.W) < measuresXG.min)?  measuresXG.min : ( measuresXG.min +
            //     newValue / 1000 +
            //     scene.children[index].userData.W);
            scene.children[index].position.x =
              measuresXG.min +
              newValue / 1000 +
              scene.children[index].userData.W;
            // measuresXG.min +
            // newValue / 1000 +
            // scene.children[index].userData.W;
          } else if (type == "LeftWall") {
            // scene.children[index].position.x = ((measuresXG.max - newValue / 1000) > measuresXG.max)?  measuresXG.max : (measuresXG.max - newValue / 1000);
            scene.children[index].position.x = measuresXG.max - newValue / 1000;
          }
        } else if (
          scene.children[index].rotation.y == degrees_to_radians(180)
        ) {
          if (type == "Left") {
            var oldValue = LeftLine.getValue();
            scene.children[index].position.x += newValue / 1000 - oldValue;
          } else if (type == "Right") {
            var oldValue = RightLine.getValue();
            scene.children[index].position.x += oldValue - newValue / 1000;
          } else if (type == "Top") {
            scene.children[index].position.y =
              measures.height -
              newValue / 1000 -
              scene.children[index].userData.H;
          } else if (type == "Bottom") {
            scene.children[index].position.y +=
              newValue / 1000 - scene.children[index].position.y;
          } else if (type == "Front") {
            var oldValue = FrontLine.getValue();
            scene.children[index].position.z += newValue / 1000 - oldValue;
          } else if (type == "Back") {
            var oldValue = BackLine.getValue();
            scene.children[index].position.z += oldValue - newValue / 1000;
          } else if (type == "RightWall") {
            scene.children[index].position.x =
              measuresXG.max -
              newValue / 1000 -
              scene.children[index].userData.W;
          } else if (type == "LeftWall") {
            scene.children[index].position.x = measuresXG.min + newValue / 1000;
          }
        } else if (scene.children[index].rotation.y == degrees_to_radians(90)) {
          if (type == "Left") {
            var oldValue = LeftLine.getValue();
            scene.children[index].position.z += newValue / 1000 - oldValue;
          } else if (type == "Right") {
            var oldValue = RightLine.getValue();
            scene.children[index].position.z += oldValue - newValue / 1000;
          } else if (type == "Top") {
            scene.children[index].position.y =
              measures.height -
              newValue / 1000 -
              scene.children[index].userData.H;
          } else if (type == "Bottom") {
            scene.children[index].position.y +=
              newValue / 1000 - scene.children[index].position.y;
          } else if (type == "Front") {
            var oldValue = FrontLine.getValue();
            scene.children[index].position.x += oldValue - newValue / 1000;
          } else if (type == "Back") {
            var oldValue = BackLine.getValue();
            scene.children[index].position.x += newValue / 1000 - oldValue;
          } else if (type == "RightWall") {
            scene.children[index].position.z =
              measuresZG.max -
              newValue / 1000 -
              scene.children[index].userData.W;
          } else if (type == "LeftWall") {
            scene.children[index].position.z = measuresZG.min + newValue / 1000;
          }
        }
        // - 90 degree
        else {
          if (type == "Left") {
            var oldValue = LeftLine.getValue();
            scene.children[index].position.z += oldValue - newValue / 1000;
          } else if (type == "Right") {
            var oldValue = RightLine.getValue();
            scene.children[index].position.z += newValue / 1000 - oldValue;
          } else if (type == "Top") {
            scene.children[index].position.y =
              measures.height -
              newValue / 1000 -
              scene.children[index].userData.H;
          } else if (type == "Bottom") {
            scene.children[index].position.y +=
              newValue / 1000 - scene.children[index].position.y;
          } else if (type == "Front") {
            var oldValue = FrontLine.getValue();
            scene.children[index].position.x += newValue / 1000 - oldValue;
          } else if (type == "Back") {
            var oldValue = BackLine.getValue();
            scene.children[index].position.x += oldValue - newValue / 1000;
          } else if (type == "RightWall") {
            scene.children[index].position.z =
              measuresZG.min +
              newValue / 1000 +
              scene.children[index].userData.W;
          } else if (type == "LeftWall") {
            scene.children[index].position.z = measuresZG.max - newValue / 1000;
          }
        }
        // console.log("uuidOfMeasures ", uuidOfMeasures);
        for (let i = 0; i < objects.length; i++) {
          /// Start Determine Code
          if (objects[i].uuid == uuidOfMeasures) {
            if (objects[i].position.x < measuresXG.min + wallWidth) {
              objects[i].position.x = measuresXG.min + wallWidth;
            } else if (objects[i].position.x > measuresXG.max - wallWidth) {
              objects[i].position.x = measuresXG.max - wallWidth;
            }

            if (objects[i].position.z < measuresZG.min + wallWidth) {
              objects[i].position.z = measuresZG.min + wallWidth;
            } else if (objects[i].position.z > measuresZG.max - wallWidth) {
              objects[i].position.z = measuresZG.max - wallWidth;
            }
            /// End Determine Code

            /// Start Stay the component at the kitchen
            if (
              objects[i].rotation.y == degrees_to_radians(0) &&
              objects[i].position.x < measuresXG.min + objects[i].userData.W
            ) {
              objects[i].rotation.y = degrees_to_radians(90);
            } else if (
              objects[i].rotation.y == degrees_to_radians(90) &&
              objects[i].position.z > measuresZG.max - objects[i].userData.W
            ) {
              objects[i].rotation.y = degrees_to_radians(180);
            } else if (
              objects[i].rotation.y == degrees_to_radians(180) &&
              objects[i].position.x > measuresXG.max - objects[i].userData.W
            ) {
              objects[i].rotation.y = degrees_to_radians(-90);
            } else if (
              objects[i].rotation.y == degrees_to_radians(-90) &&
              objects[i].position.z < measuresZG.min + objects[i].userData.W
            ) {
              objects[i].rotation.y = degrees_to_radians(0);
            }
            /// End component in kitchen

            // End

            scene.add(objects[i]);

            // Left Cover
            if (objects[i].userData.hasLeftCover == true) {
              let positionX, positionY, positionZ;
              if (objects[i].rotation.y == degrees_to_radians(0)) {
                positionX = objects[i].position.x + 0.018;
                positionZ = objects[i].position.z;
                positionY = objects[i].position.y + 0.1;
              } else if (objects[i].rotation.y == degrees_to_radians(90)) {
                positionX = objects[i].position.x;
                positionZ = objects[i].position.z - 0.018;
                positionY = objects[i].position.y + 0.1;
              } else if (objects[i].rotation.y == degrees_to_radians(180)) {
                positionX = objects[i].position.x - 0.018;
                positionZ = objects[i].position.z;
                positionY = objects[i].position.y + 0.1;
              } else if (objects[i].rotation.y == degrees_to_radians(-90)) {
                positionX = objects[i].position.x;
                positionZ = objects[i].position.z + 0.018;
                positionY = objects[i].position.y + 0.1;
              }

              for (let index = 0; index < leftCovers.length; index++) {
                if (
                  leftCovers[index].uuid == objects[i].userData.uuidLeftCover
                ) {
                  leftCovers[index].position.x = positionX;
                  leftCovers[index].position.z = positionZ;
                  leftCovers[index].rotation.y = objects[i].rotation.y;
                  // leftCovers[index].position.y = objects[i].position.y;
                  // console.log(
                  //   "leftCovers before ",
                  //   leftCovers[index].position.y
                  // );
                  if (objects[i].name != "B")
                    leftCovers[index].position.y =
                      objects[i].position.y -
                      (objects[i].userData.hasDecoStrip == true ? 0.1 : 0);
                  // console.log(
                  //   "leftCovers after ",
                  //   leftCovers[index].position.y
                  // );

                  scene.add(leftCovers[index]);
                }
              }
            }

            // Right Cover
            if (objects[i].userData.hasRightCover == true) {
              let positionX, positionY, positionZ;
              if (objects[i].rotation.y == degrees_to_radians(0)) {
                positionX = objects[i].position.x - objects[i].userData.W;
                positionZ = objects[i].position.z;
                positionY = objects[i].position.y + 0.1;
              } else if (objects[i].rotation.y == degrees_to_radians(90)) {
                positionX = objects[i].position.x;
                positionZ = objects[i].position.z + objects[i].userData.W;
                positionY = objects[i].position.y + 0.1;
              } else if (objects[i].rotation.y == degrees_to_radians(180)) {
                positionX = objects[i].position.x + objects[i].userData.W;
                positionZ = objects[i].position.z;

                positionY = objects[i].position.y + 0.1;
              } else if (objects[i].rotation.y == degrees_to_radians(-90)) {
                positionX = objects[i].position.x;
                positionZ = objects[i].position.z - objects[i].userData.W;
                positionY = objects[i].position.y + 0.1;
              }

              for (let index = 0; index < rightCovers.length; index++) {
                if (
                  rightCovers[index].uuid == objects[i].userData.uuidRightCover
                ) {
                  rightCovers[index].position.x = positionX;
                  rightCovers[index].position.z = positionZ;
                  rightCovers[index].rotation.y = objects[i].rotation.y;
                  // rightCovers[index].position.y = objects[i].position.y;
                  if (objects[i].name != "B")
                    rightCovers[index].position.y =
                      objects[i].position.y -
                      (objects[i].userData.hasDecoStrip == true ? 0.1 : 0);

                  scene.add(rightCovers[index]);
                }
              }
            }

            // Back Cover
            if (objects[i].userData.hasBackCover == true) {
              let positionX, positionY, positionZ;

              positionX = objects[i].position.x;
              positionZ = objects[i].position.z;
              positionY = objects[i].position.y + 0.1;

              for (let index = 0; index < backCovers.length; index++) {
                if (
                  backCovers[index].uuid == objects[i].userData.uuidBackCover
                ) {
                  backCovers[index].position.x = positionX;
                  backCovers[index].position.z = positionZ;
                  backCovers[index].rotation.y = objects[i].rotation.y;
                  if (objects[i].name != "B")
                    backCovers[index].position.y = objects[i].position.y;

                  scene.add(backCovers[index]);
                }
              }
            }

            //  Change coordinates of the wall panel
            if (objects[i].userData.hasWallPanel == true) {
              let positionX, positionY, positionZ;
              positionX = objects[i].position.x;
              positionZ = objects[i].position.z;
              // positionY = objects[i].userData.H + 0.15;

              for (let index = 0; index < wallPanels.length; index++) {
                if (
                  wallPanels[index].uuid == objects[i].userData.uuidWallPanel
                ) {
                  wallPanels[index].position.x = positionX;
                  wallPanels[index].position.z = positionZ;
                  // wallPanels[index].position.y = positionY;
                  wallPanels[index].rotation.y = objects[i].rotation.y;
                  wallPanels[index].scale.x = objects[i].userData.W;

                  // console.log("wallPanels[index]   " , wallPanels[index]);

                  if (
                    positionX == measuresXG.max - wallWidth ||
                    positionX == measuresXG.min + wallWidth ||
                    positionZ == measuresZG.max - wallWidth ||
                    positionZ == measuresZG.min + wallWidth
                  )
                    wallPanels[index].visible = true;
                  else wallPanels[index].visible = false;
                  scene.add(wallPanels[index]);
                }
              }
            }

            //  Change coordinates of the Cornice
            if (objects[i].userData.hasCornice == true) {
              let positionX, positionY, positionZ;
              positionX = objects[i].position.x;
              positionZ = objects[i].position.z;

              var lightPosX;
              var lightPosZ;

              if (objects[i].rotation.y == degrees_to_radians(0)) {
                positionZ =
                  objects[i].position.z + objects[i].userData.L - 0.05;
                lightPosX = objects[i].position.x - objects[i].userData.W / 2;
                lightPosZ =
                  objects[i].position.z + objects[i].userData.L - 0.05;
                positionX += 0.018;
              } else if (objects[i].rotation.y == degrees_to_radians(180)) {
                positionZ =
                  objects[i].position.z - objects[i].userData.L + 0.05;
                lightPosX = objects[i].position.x + objects[i].userData.W / 2;
                lightPosZ =
                  objects[i].position.z - objects[i].userData.L + 0.05;
                positionX -= 0.018;
              } else if (objects[i].rotation.y == degrees_to_radians(90)) {
                positionX =
                  objects[i].position.x + objects[i].userData.L - 0.05;
                lightPosZ = objects[i].position.z + objects[i].userData.W / 2;
                lightPosX =
                  objects[i].position.x + objects[i].userData.L - 0.05;
                positionZ -= 0.018;
              } else {
                positionX =
                  objects[i].position.x - objects[i].userData.L + 0.05;
                lightPosZ = objects[i].position.z - objects[i].userData.W / 2;
                lightPosX =
                  objects[i].position.x - objects[i].userData.L + 0.05;
                positionZ += 0.018;
              }

              // positionY = objects[i].position.y - 0.1;

              for (let index = 0; index < Cornices.length; index++) {
                if (Cornices[index].uuid == objects[i].userData.uuidCornice) {
                  Cornices[index].position.x = positionX;
                  Cornices[index].position.z = positionZ;
                  // decoStrips[index].position.y = positionY;
                  Cornices[index].rotation.y = objects[i].rotation.y;

                  scene.add(Cornices[index]);
                }
              }
              for (let index = 0; index < lightObjects.length; index++) {
                if (
                  lightObjects[index].uuid ==
                  objects[i].userData.uuidLightCornice
                ) {
                  lightObjects[index].position.x = lightPosX;
                  lightObjects[index].position.z = lightPosZ;
                  lightObjects[index].rotation.y = objects[i].rotation.y;
                  scene.add(lightObjects[index]);
                }
              }
            }
            //  Change coordinates of the Deco strip
            if (objects[i].userData.hasDecoStrip == true) {
              let positionX, positionY, positionZ;
              positionX = objects[i].position.x;
              positionZ = objects[i].position.z;

              var lightPosX;
              var lightPosZ;

              var lightRotX = 0;
              var lightRotZ = 0;
              var lightRotY = 0;

              if (objects[i].rotation.y == degrees_to_radians(0)) {
                positionZ =
                  objects[i].position.z + objects[i].userData.L - 0.018;
                lightPosX = objects[i].position.x - objects[i].userData.W / 2;
                lightPosZ =
                  objects[i].position.z + objects[i].userData.L - 0.118;
                lightRotX = degrees_to_radians(-90);
                lightRotZ = degrees_to_radians(0);
                lightRotY = objects[i].rotation.y;
              } else if (objects[i].rotation.y == degrees_to_radians(180)) {
                positionZ =
                  objects[i].position.z - objects[i].userData.L + 0.018;
                lightPosX = objects[i].position.x + objects[i].userData.W / 2;
                lightPosZ =
                  objects[i].position.z - objects[i].userData.L + 0.118;
                lightRotX = degrees_to_radians(90);
                lightRotZ = degrees_to_radians(180);
                lightRotY = objects[i].rotation.y;
              } else if (objects[i].rotation.y == degrees_to_radians(90)) {
                positionX =
                  objects[i].position.x + objects[i].userData.L - 0.018;
                lightPosZ = objects[i].position.z + objects[i].userData.W / 2;
                lightPosX =
                  objects[i].position.x + objects[i].userData.L - 0.118;
                lightRotZ = degrees_to_radians(180);
                lightRotY = objects[i].rotation.y;
              } else {
                positionX =
                  objects[i].position.x - objects[i].userData.L + 0.018;
                lightPosZ = objects[i].position.z - objects[i].userData.W / 2;
                lightPosX =
                  objects[i].position.x - objects[i].userData.L + 0.118;
                lightRotZ = degrees_to_radians(180);
                lightRotY = objects[i].rotation.y;
              }
              positionY = objects[i].position.y - 0.1;

              for (let index = 0; index < decoStrips.length; index++) {
                if (
                  decoStrips[index].uuid == objects[i].userData.uuidDecoStrip
                ) {
                  decoStrips[index].position.x = positionX;
                  decoStrips[index].position.z = positionZ;
                  decoStrips[index].position.y = positionY;
                  decoStrips[index].rotation.y = objects[i].rotation.y;

                  scene.add(decoStrips[index]);
                }
              }

              for (let index = 0; index < lightObjects.length; index++) {
                if (lightObjects[index].uuid == objects[i].userData.uuidLight) {
                  lightObjects[index].position.x = lightPosX;
                  lightObjects[index].position.z = lightPosZ;
                  lightObjects[index].position.y = positionY + 0.1;
                  if (lightRotX == 0) {
                    lightObjects[index].rotation.y = lightRotZ;
                    lightObjects[index].rotation.z = degrees_to_radians(-90);
                    lightObjects[index].rotation.x = degrees_to_radians(90);
                    // console.log("Here1 lights");
                  } else {
                    lightObjects[index].rotation.x = lightRotX;
                    lightObjects[index].rotation.z = lightRotZ;
                    lightObjects[index].rotation.y = lightRotY;
                    // console.log("Here2 lights");
                  }

                  // lightObjects[index].rotation.y = objects[i].rotation.y;
                  scene.add(lightObjects[index]);
                  // console.log("lightObjects[index]  ", lightObjects[index]);
                  break;
                }
              }
            }

            //  Change coordinates of the light of skirting
            if (objects[i].userData.hasLightSkirting == true) {
              var lightPosX;
              var lightPosZ;
              if (objects[i].rotation.y == degrees_to_radians(0)) {
                lightPosX = objects[i].position.x - objects[i].userData.W / 2;
                lightPosZ =
                  objects[i].position.z + objects[i].userData.L - 0.014;
              } else if (objects[i].rotation.y == degrees_to_radians(180)) {
                lightPosX = objects[i].position.x + objects[i].userData.W / 2;
                lightPosZ =
                  objects[i].position.z - objects[i].userData.L + 0.014;
              } else if (objects[i].rotation.y == degrees_to_radians(90)) {
                lightPosZ = objects[i].position.z + objects[i].userData.W / 2;
                lightPosX =
                  objects[i].position.x + objects[i].userData.L - 0.014;
              } else {
                lightPosZ = objects[i].position.z - objects[i].userData.W / 2;
                lightPosX =
                  objects[i].position.x - objects[i].userData.L + 0.014;
              }

              for (let index = 0; index < lightObjects.length; index++) {
                if (
                  lightObjects[index].uuid ==
                  objects[i].userData.uuidLightSkirting
                ) {
                  lightObjects[index].position.x = lightPosX;
                  lightObjects[index].position.z = lightPosZ;
                  lightObjects[index].rotation.y = objects[i].rotation.y;
                  scene.add(lightObjects[index]);
                }
              }
            }

            // Delete finish top
            for (let index = 0; index < finishTops.length; index++) {
              for (
                let m = 0;
                m < objects[i].userData.finish_uuids.length;
                m++
              ) {
                if (
                  finishTops[index].uuid == objects[i].userData.finish_uuids[m]
                ) {
                  finishTops.splice(index, 1);
                  index--;
                  break;
                }
              }
            }
            // // Handle Direction

            if (objects[i].userData.hasHandleDirection == true) {
              let positionX, positionZ;

              for (let index = 0; index < directions.length; index++) {
                if (
                  directions[index].uuid == objects[i].userData.uuidDirection
                ) {
                  if (objects[i].rotation.y == degrees_to_radians(0)) {
                    positionX = objects[i].position.x;
                    positionZ = objects[i].position.z + objects[i].userData.L;
                  } else if (objects[i].rotation.y == degrees_to_radians(90)) {
                    positionX = objects[i].position.x + objects[i].userData.L;
                    positionZ = objects[i].position.z;
                  } else if (objects[i].rotation.y == degrees_to_radians(180)) {
                    positionX = objects[i].position.x;
                    positionZ = objects[i].position.z - objects[i].userData.L;
                  } else if (objects[i].rotation.y == degrees_to_radians(-90)) {
                    positionX = objects[i].position.x - objects[i].userData.L;
                    positionZ = objects[i].position.z;
                  }

                  directions[index].position.x = positionX;
                  directions[index].position.z = positionZ;
                  directions[index].rotation.y = objects[i].rotation.y;

                  scene.add(directions[index]);
                }
              }
            }

            for await (let obj of scene.children) {
              for (
                let m = 0;
                m < objects[i].userData.finish_uuids.length;
                m++
              ) {
                if (obj.uuid == objects[i].userData.finish_uuids[m]) {
                  objects[i].userData.finish_uuids.splice(m--, 1);
                  scene.remove(obj);
                  break;
                }
              }
            }
            if (objects[i].position.y < 0.1) objects[i].position.y = 0.1;
            else if (
              objects[i].position.y >
              measures.height - objects[i].userData.H
            )
              objects[i].position.y = measures.height - objects[i].userData.H;

            objects[i].userData.finish_uuids = [];

            objDraggable = objects[i];
            break;
          }
        }

        if (objDraggable.name == "B") {
          await finishTop(objDraggable);
          // console.log("Scene   ", scene);

          let widthTop = 0;

          let remain = 0;
          //          await loaderr.load("/obj/newObjects/finish_top.glb", function (gltf) {
          await loaderr.load(
            "https://storage.googleapis.com/kitchendata/accessories/finish_top.glb",
            function (gltf) {
              // console.log("6");

              let object = gltf.scene.children[0];
              widthTop = objDraggable.userData.W;

              if (uuidsLeft.length == 0) {
                object.position.x = objDraggable.position.x;
                object.position.z = objDraggable.position.z;
              } else {
                object.position.x = uuidsLeft[uuidsLeft.length - 1].position.x;
                object.position.z = uuidsLeft[uuidsLeft.length - 1].position.z;
              }

              if (uuidsRight.length > 0) {
                widthTop = uuidsRight[uuidsRight.length - 1].userData.W;
              }

              if (objDraggable.rotation.y == degrees_to_radians(0)) {
                /**
                 * widthTop is the distance with the filler
                 */

                let objCheck = null;
                if (uuidsLeft.length == 0) {
                  objCheck = objDraggable;
                } else {
                  objCheck = uuidsLeft[uuidsLeft.length - 1];
                }

                if (objCheck.position.x + 0.2 > measuresXG.max - wallWidth) {
                  widthTop = measuresXG.max - wallWidth - objCheck.position.x;
                  let remain = 0;
                  if (uuidsRight.length > 0)
                    remain = uuidsRight[uuidsRight.length - 1].userData.W;
                  else remain = objDraggable.userData.W;

                  widthTop += remain;
                  object.position.x = measuresXG.max - wallWidth;
                }

                if (uuidsRight.length == 0) {
                  objCheck = objDraggable;
                } else {
                  objCheck = uuidsRight[uuidsRight.length - 1];
                }

                if (
                  objCheck.position.x - objCheck.userData.W - 0.2 <
                  measuresXG.min + wallWidth
                ) {
                  widthTop = -measuresXG.min - wallWidth + objCheck.position.x;
                }

                /**
                 * Check 4 cases about the object
                 */
                if (uuidsLeft.length == 0) {
                  if (uuidsRight.length == 0) {
                    object.scale.x =
                      object.position.x - (object.position.x - widthTop);
                  } else {
                    if (
                      Math.abs(
                        uuidsRight[uuidsRight.length - 1].position.x -
                          uuidsRight[uuidsRight.length - 1].userData.W -
                          measuresXG.min -
                          wallWidth
                      ) <= 0.2
                    ) {
                      remain =
                        -measuresXG.min -
                        wallWidth +
                        (uuidsRight[uuidsRight.length - 1].position.x -
                          uuidsRight[uuidsRight.length - 1].userData.W);
                    }

                    object.scale.x =
                      object.position.x -
                      (uuidsRight[uuidsRight.length - 1].position.x -
                        uuidsRight[uuidsRight.length - 1].userData.W) +
                      remain;
                  }
                } else {
                  if (uuidsRight.length == 0) {
                    object.scale.x =
                      uuidsLeft[uuidsLeft.length - 1].position.x -
                      objDraggable.position.x +
                      widthTop;

                    // console.log(
                    //   "uuidsLeft[uuidsLeft.length - 1].position.x ",
                    //   uuidsLeft[uuidsLeft.length - 1].position.x
                    // );
                    // console.log(
                    //   "objDraggable.position.x   ",
                    //   objDraggable.position.x
                    // );
                    // console.log("widthTop  ", widthTop);
                    // console.log(
                    //   "objDraggable.userData.W  ",
                    //   objDraggable.userData.W
                    // );
                    // console.log("object.scale.x   ", object.scale.x);
                  } else {
                    // console.log(
                    //   "uuidsLeft[uuidsLeft.length - 1].position.x    ",
                    //   uuidsLeft[uuidsLeft.length - 1].position.x
                    // );
                    // console.log(
                    //   "uuidsRight[uuidsRight.length - 1].position.x   ",
                    //   uuidsRight[uuidsRight.length - 1].position.x
                    // );
                    // console.log("widthTop    ", widthTop);
                    object.scale.x =
                      uuidsLeft[uuidsLeft.length - 1].position.x -
                      (uuidsRight[uuidsRight.length - 1].position.x - widthTop);
                  }
                }

                object.scale.z = objDraggable.userData.L;
                object.rotation.y = objDraggable.rotation.y;
                // console.log("DDD   "  , object.scale.x);
              } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
                let objCheck = null;
                if (uuidsLeft.length == 0) {
                  objCheck = objDraggable;
                } else {
                  objCheck = uuidsLeft[uuidsLeft.length - 1];
                }

                if (objCheck.position.x - 0.2 < measuresXG.min + wallWidth) {
                  widthTop = objCheck.position.x - measuresXG.min - wallWidth;
                  let remain = 0;
                  if (uuidsRight.length > 0)
                    remain = uuidsRight[uuidsRight.length - 1].userData.W;
                  else remain = objDraggable.userData.W;

                  widthTop += remain;

                  object.position.x = measuresXG.min + wallWidth;
                }

                if (uuidsRight.length == 0) {
                  objCheck = objDraggable;
                } else {
                  objCheck = uuidsRight[uuidsRight.length - 1];
                }

                if (
                  objCheck.position.x + objCheck.userData.W + 0.2 >
                  measuresXG.max - wallWidth
                ) {
                  widthTop = measuresXG.max - wallWidth - objCheck.position.x;
                }

                if (uuidsLeft.length == 0) {
                  if (uuidsRight.length == 0) {
                    object.scale.x =
                      object.position.x - (object.position.x + widthTop);
                  } else {
                    if (
                      measuresXG.max -
                        wallWidth -
                        (uuidsRight[uuidsRight.length - 1].position.x +
                          uuidsRight[uuidsRight.length - 1].userData.W) <=
                      0.2
                    ) {
                      remain =
                        measuresXG.max -
                        wallWidth -
                        (uuidsRight[uuidsRight.length - 1].position.x +
                          uuidsRight[uuidsRight.length - 1].userData.W);
                    }
                    object.scale.x =
                      object.position.x -
                      (uuidsRight[uuidsRight.length - 1].position.x +
                        uuidsRight[uuidsRight.length - 1].userData.W) -
                      remain;
                    // remain;
                  }
                } else {
                  if (uuidsRight.length == 0) {
                    object.scale.x =
                      uuidsLeft[uuidsLeft.length - 1].position.x -
                      (objDraggable.position.x + widthTop);
                  } else {
                    object.scale.x =
                      uuidsLeft[uuidsLeft.length - 1].position.x -
                      uuidsRight[uuidsRight.length - 1].position.x -
                      widthTop;
                  }
                }
                object.position.z = object.position.z - objDraggable.userData.L;
                object.scale.z = objDraggable.userData.L;
              } else if (objDraggable.rotation.y == degrees_to_radians(90)) {
                let objCheck = null;
                if (uuidsLeft.length == 0) {
                  objCheck = objDraggable;
                } else {
                  objCheck = uuidsLeft[uuidsLeft.length - 1];
                }

                if (objCheck.position.z - 0.2 < measuresZG.min + wallWidth) {
                  widthTop = objCheck.position.z - measuresZG.min - wallWidth;
                  let remain = 0;

                  if (uuidsRight.length > 0)
                    remain = uuidsRight[uuidsRight.length - 1].userData.W;
                  else remain = objDraggable.userData.W;

                  widthTop += remain;

                  object.position.z = measuresZG.min + wallWidth;
                }

                if (uuidsRight.length == 0) {
                  objCheck = objDraggable;
                } else {
                  objCheck = uuidsRight[uuidsRight.length - 1];
                }

                if (
                  objCheck.position.z + objCheck.userData.W + 0.2 >
                  measuresZG.max - wallWidth
                ) {
                  widthTop = measuresZG.max - wallWidth - objCheck.position.z;
                }

                if (uuidsLeft.length == 0) {
                  if (uuidsRight.length == 0) {
                    object.scale.z =
                      object.position.z - (object.position.z + widthTop);
                  } else {
                    if (
                      measuresZG.max -
                        wallWidth -
                        (uuidsRight[uuidsRight.length - 1].position.z +
                          uuidsRight[uuidsRight.length - 1].userData.W) <=
                      0.2
                    ) {
                      remain =
                        measuresZG.max -
                        wallWidth -
                        (uuidsRight[uuidsRight.length - 1].position.z +
                          uuidsRight[uuidsRight.length - 1].userData.W);
                    }
                    object.scale.z =
                      object.position.z -
                      (uuidsRight[uuidsRight.length - 1].position.z +
                        uuidsRight[uuidsRight.length - 1].userData.W) -
                      remain;
                  }
                } else {
                  if (uuidsRight.length == 0) {
                    object.scale.z =
                      uuidsLeft[uuidsLeft.length - 1].position.z -
                      (objDraggable.position.z + widthTop);
                  } else {
                    object.scale.z =
                      uuidsLeft[uuidsLeft.length - 1].position.z -
                      (uuidsRight[uuidsRight.length - 1].position.z + widthTop);
                  }
                }

                object.rotation.y =
                  objDraggable.rotation.y + degrees_to_radians(90);
                object.scale.x = objDraggable.userData.L;
              }
              // -90 degree
              else {
                let objCheck = null;
                if (uuidsLeft.length == 0) {
                  objCheck = objDraggable;
                } else {
                  objCheck = uuidsLeft[uuidsLeft.length - 1];
                }
                if (objCheck.position.z + 0.2 > measuresZG.max - wallWidth) {
                  widthTop = measuresZG.max - wallWidth - objCheck.position.z;
                  let remain = 0;

                  if (uuidsRight.length > 0)
                    remain = uuidsRight[uuidsRight.length - 1].userData.W;
                  else remain = objDraggable.userData.W;

                  widthTop += remain;

                  object.position.z = measuresZG.max - wallWidth;
                }

                if (uuidsRight.length == 0) {
                  objCheck = objDraggable;
                } else {
                  objCheck = uuidsRight[uuidsRight.length - 1];
                }

                if (
                  objCheck.position.z - objCheck.userData.W - 0.2 <
                  measuresZG.min + wallWidth
                ) {
                  widthTop = objCheck.position.z + measuresZG.max - wallWidth;
                  // object.position.z = measures.length/2;
                }

                if (uuidsLeft.length == 0) {
                  if (uuidsRight.length == 0) {
                    object.scale.z =
                      object.position.z - (object.position.z + widthTop);
                    object.scale.x = objDraggable.userData.L;
                    object.rotation.y =
                      objDraggable.rotation.y + degrees_to_radians(90);
                  } else {
                    if (
                      uuidsRight[uuidsRight.length - 1].position.z -
                        uuidsRight[uuidsRight.length - 1].userData.W -
                        measuresZG.min -
                        wallWidth <=
                      0.2
                    ) {
                      remain =
                        uuidsRight[uuidsRight.length - 1].position.z -
                        uuidsRight[uuidsRight.length - 1].userData.W -
                        measuresZG.min -
                        wallWidth;
                    }
                    object.scale.x =
                      object.position.z -
                      (uuidsRight[uuidsRight.length - 1].position.z -
                        uuidsRight[uuidsRight.length - 1].userData.W) +
                      remain;
                    // remain;
                    object.scale.z = objDraggable.userData.L;
                    object.rotation.y = objDraggable.rotation.y;
                  }
                } else {
                  if (uuidsRight.length == 0) {
                    object.scale.x =
                      uuidsLeft[uuidsLeft.length - 1].position.z -
                      (objDraggable.position.z - widthTop);
                    object.scale.z = objDraggable.userData.L;
                    object.rotation.y = objDraggable.rotation.y;
                  } else {
                    object.scale.x =
                      uuidsLeft[uuidsLeft.length - 1].position.z -
                      (uuidsRight[uuidsRight.length - 1].position.z - widthTop);

                    object.scale.z = objDraggable.userData.L;
                    object.rotation.y = objDraggable.rotation.y;
                  }
                }
              }

              // if (objDraggable.rotation.y == degrees_to_radians(0)) {
              //   if (object.position.x + 0.2 > measuresXG.max) {
              //     // console.log("FFF");
              //     widthTop =
              //       measuresXG.max - object.position.x + objDraggable.userData.W;
              //     object.position.x = measuresXG.max;
              //   } else if (
              //     object.position.x - objDraggable.userData.W - 0.2 <
              //     measuresXG.min
              //   ) {
              //     // console.log("DDD");

              //     widthTop = measuresXG.max - wallWidth + object.position.x;

              //     // object.position.x = - measures.width/2;
              //   }

              //   if (uuidsLeft.length == 0) {
              //     if (uuidsRight.length == 0) {
              //       object.scale.x =
              //         object.position.x - (object.position.x - widthTop);
              //     } else {
              //       if (
              //         Math.abs(
              //           uuidsRight[uuidsRight.length - 1].position.x -
              //             uuidsRight[uuidsRight.length - 1].userData.W -
              //             measuresXG.min
              //         ) <= 0.2
              //       ) {
              //         remain =
              //           -measuresXG.min +
              //           (uuidsRight[uuidsRight.length - 1].position.x -
              //             uuidsRight[uuidsRight.length - 1].userData.W);
              //       }
              //       // console.log("WidthTop  " , widthTop);
              //       // console.log(" object.position.x  ",  object.position.x);
              //       // console.log(" measuresXG.max   ",  uuidsRight[uuidsRight.length - 1].position.x);
              //       // console.log(" object.position.x   ",   uuidsRight[uuidsRight.length - 1].userData.W );
              //       object.scale.x =
              //         object.position.x -
              //         (uuidsRight[uuidsRight.length - 1].position.x -
              //           uuidsRight[uuidsRight.length - 1].userData.W) +
              //         remain;

              //       // object.scale.x = widthTop ;
              //     }
              //   } else {
              //     if (uuidsRight.length == 0) {
              //       object.scale.x =
              //         uuidsLeft[uuidsLeft.length - 1].position.x -
              //         objDraggable.position.x +
              //         widthTop;
              //       // console.log('uuidsLeft[uuidsLeft.length - 1].position.x  ' , uuidsLeft[uuidsLeft.length - 1].position.x );
              //       // console.log('object.position.x   ' , objDraggable.position.x  );
              //       // console.log('widthTop  ' , widthTop  );
              //     } else {
              //       object.scale.x =
              //         uuidsLeft[uuidsLeft.length - 1].position.x -
              //         (uuidsRight[uuidsRight.length - 1].position.x -
              //           uuidsRight[uuidsRight.length - 1].userData.W);
              //     }
              //   }
              //   object.scale.z = objDraggable.userData.L;
              //   object.rotation.y = objDraggable.rotation.y;
              //   // console.log("DDD   "  , object.scale.x);
              // } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
              //   if (object.position.x - 0.2 < measuresXG.min) {
              //     widthTop =
              //       object.position.x + measuresXG.max + objDraggable.userData.W;
              //     object.position.x = measuresXG.min;
              //   } else if (
              //     object.position.x + objDraggable.userData.W + 0.2 >
              //     measuresXG.max
              //   ) {
              //     widthTop = measuresXG.max - object.position.x;
              //     // object.position.x = measures.width/2;
              //   }
              //   if (uuidsLeft.length == 0) {
              //     if (uuidsRight.length == 0) {
              //       object.scale.x =
              //         object.position.x - (object.position.x + widthTop);
              //     } else {
              //       if (
              //         measuresXG.max -
              //           (uuidsRight[uuidsRight.length - 1].position.x +
              //             uuidsRight[uuidsRight.length - 1].userData.W) <=
              //         0.2
              //       ) {
              //         remain =
              //           measuresXG.max -
              //           (uuidsRight[uuidsRight.length - 1].position.x +
              //             uuidsRight[uuidsRight.length - 1].userData.W);
              //       }
              //       object.scale.x =
              //         object.position.x -
              //         (uuidsRight[uuidsRight.length - 1].position.x +
              //           uuidsRight[uuidsRight.length - 1].userData.W) -
              //         remain;
              //     }
              //   } else {
              //     if (uuidsRight.length == 0) {
              //       object.scale.x =
              //         uuidsLeft[uuidsLeft.length - 1].position.x -
              //         (objDraggable.position.x + widthTop);
              //     } else {
              //       object.scale.x =
              //         uuidsLeft[uuidsLeft.length - 1].position.x -
              //         (uuidsRight[uuidsRight.length - 1].position.x +
              //           uuidsRight[uuidsRight.length - 1].userData.W);
              //     }
              //   }
              //   object.position.z = object.position.z - objDraggable.userData.L;
              //   object.scale.z = objDraggable.userData.L;
              // } else if (objDraggable.rotation.y == degrees_to_radians(90)) {
              //   if (object.position.z - 0.2 < measuresZG.min) {
              //     widthTop =
              //       object.position.z + measuresZG.max + objDraggable.userData.W;
              //     object.position.z = measuresZG.min;
              //   } else if (
              //     object.position.z + objDraggable.userData.W + 0.2 >
              //     measuresZG.max
              //   ) {
              //     widthTop = measuresZG.max - object.position.z;
              //     // object.position.z = measures.length/2;
              //   }
              //   if (uuidsLeft.length == 0) {
              //     if (uuidsRight.length == 0) {
              //       object.scale.z =
              //         object.position.z - (object.position.z + widthTop);
              //     } else {
              //       if (
              //         measuresZG.max -
              //           (uuidsRight[uuidsRight.length - 1].position.z +
              //             uuidsRight[uuidsRight.length - 1].userData.W) <=
              //         0.2
              //       ) {
              //         remain =
              //           measuresZG.max -
              //           (uuidsRight[uuidsRight.length - 1].position.z +
              //             uuidsRight[uuidsRight.length - 1].userData.W);
              //         // console.log("Remain  ", remain);
              //       }
              //       object.scale.z =
              //         object.position.z -
              //         (uuidsRight[uuidsRight.length - 1].position.z +
              //           uuidsRight[uuidsRight.length - 1].userData.W) -
              //         remain;
              //     }
              //   } else {
              //     if (uuidsRight.length == 0) {
              //       object.scale.z =
              //         uuidsLeft[uuidsLeft.length - 1].position.z -
              //         (objDraggable.position.z + widthTop);
              //     } else {
              //       object.scale.z =
              //         uuidsLeft[uuidsLeft.length - 1].position.z -
              //         (uuidsRight[uuidsRight.length - 1].position.z +
              //           uuidsRight[uuidsRight.length - 1].userData.W);
              //     }
              //   }
              //   object.rotation.y =
              //     objDraggable.rotation.y + degrees_to_radians(90);
              //   object.position.x = object.position.x;
              //   object.scale.x = objDraggable.userData.L;
              // } else {
              //   if (object.position.z + 0.2 > measuresZG.max) {
              //     widthTop =
              //       measuresZG.max - object.position.z + objDraggable.userData.W;
              //     object.position.z = measuresZG.max;
              //   } else if (
              //     object.position.z - objDraggable.userData.W - 0.2 <
              //     measuresZG.min
              //   ) {
              //     widthTop = object.position.z + measuresZG.max;
              //     // object.position.z = measures.length/2;
              //   }
              //   if (uuidsLeft.length == 0) {
              //     if (uuidsRight.length == 0) {
              //       object.scale.z =
              //         object.position.z - (object.position.z + widthTop);
              //       object.scale.x = objDraggable.userData.L;
              //       object.rotation.y =
              //         objDraggable.rotation.y + degrees_to_radians(90);
              //     } else {
              //       if (
              //         uuidsRight[uuidsRight.length - 1].position.z -
              //           uuidsRight[uuidsRight.length - 1].userData.W -
              //           measuresZG.min <=
              //         0.2
              //       ) {
              //         remain =
              //           uuidsRight[uuidsRight.length - 1].position.z -
              //           uuidsRight[uuidsRight.length - 1].userData.W -
              //           measuresZG.min;
              //       }
              //       object.scale.x =
              //         object.position.z -
              //         (uuidsRight[uuidsRight.length - 1].position.z -
              //           uuidsRight[uuidsRight.length - 1].userData.W) +
              //         remain;
              //       object.scale.z = objDraggable.userData.L;
              //       object.rotation.y = objDraggable.rotation.y;
              //     }
              //   } else {
              //     if (uuidsRight.length == 0) {
              //       object.scale.x =
              //         uuidsLeft[uuidsLeft.length - 1].position.z -
              //         (objDraggable.position.z - widthTop);
              //       object.scale.z = objDraggable.userData.L;
              //       object.rotation.y = objDraggable.rotation.y;
              //     } else {
              //       object.scale.x =
              //         uuidsLeft[uuidsLeft.length - 1].position.z -
              //         (uuidsRight[uuidsRight.length - 1].position.z -
              //           uuidsRight[uuidsRight.length - 1].userData.W);
              //       object.scale.z = objDraggable.userData.L;
              //       object.rotation.y = objDraggable.rotation.y;
              //     }
              //   }
              // }

              object.position.y =
                objDraggable.position.y + objDraggable.userData.H + 0.1;

              textureWorktops = textureLoader.load(
                "./colors/" + worktopsColor + ".png"
              );
              objDraggable.userData.worktops = worktopsColor;
              textureWorktops.wrapS = textureWorktops.wrapT = RepeatWrapping;
              textureWorktops.offset.set(0.02, 0.02);
              textureWorktops.repeat.set(0.02, 0.02);
              object.material.clone();
              object.material.metalness = -0.1;
              object.material.map = textureWorktops;

              // object.material.map.repeat.set(8, 8);
              // object.material.map.repeat.set(
              //   ((object.scale.x / 2) * 2) / 0.05,
              //   ((object.scale.z / 2) * 2) / 0.05
              // );

              object.castShadow = true;
              object.receiveShadow = true;

              object.name = "TOP";
              object.scale.x = object.scale.x / 2;
              object.scale.z = object.scale.z / 2;
              if (emptying.length > 0) {
                // console.log("object  ss", object);
                // console.log("emptying[0] ", emptying[0]);
                let meshB = new Mesh(
                  new BoxGeometry(
                    emptying[0].userData.sinkWidth - 0.03,
                    0.55,
                    0.036
                  ),
                  new MeshStandardMaterial({
                    color: new Color("#FF5512"),
                  })
                );
                //  console.log("position  ",meshB.position);
                let x = 0;
                let z = 0;
                if (objDraggable.rotation.y == degrees_to_radians(0)) {
                  x = emptying[0].position.x - emptying[0].userData.W / 2;
                  z = emptying[0].position.z + 0.55 / 2;
                  meshB.rotation.z = degrees_to_radians(90);
                  meshB.rotation.x = degrees_to_radians(90);
                } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
                  x = emptying[0].position.x + emptying[0].userData.W / 2;
                  z = emptying[0].position.z - 0.55 / 2;
                  meshB.rotation.x = degrees_to_radians(-90);
                  meshB.rotation.z = degrees_to_radians(-90);
                } else if (objDraggable.rotation.y == degrees_to_radians(90)) {
                  z = emptying[0].position.z + emptying[0].userData.W / 2;
                  x = emptying[0].position.x + 0.55 / 2;
                  meshB.rotation.z = degrees_to_radians(-90);
                  meshB.rotation.x = degrees_to_radians(90);
                } else if (objDraggable.rotation.y == degrees_to_radians(-90)) {
                  z = emptying[0].position.z - emptying[0].userData.W / 2;
                  x = emptying[0].position.x - 0.55 / 2;
                  meshB.rotation.z = degrees_to_radians(90);
                  meshB.rotation.x = degrees_to_radians(-90);
                }
                meshB.position.add(
                  new Vector3(x, object.position.y + 0.018, z)
                );

                meshB.updateMatrix();
                object.updateMatrix();

                let bspA = CSG.default.fromMesh(object);
                let bspB = CSG.default.fromMesh(meshB);
                let bspResult = "";

                if (objDraggable.rotation.y == degrees_to_radians(0))
                  bspResult = bspA.subtract(bspB);
                else bspResult = bspA.union(bspB);

                if (
                  objDraggable.rotation.y == degrees_to_radians(-90) &&
                  emptying.length > 1
                )
                  bspResult = bspA.subtract(bspB);

                for (let b = 1; b < emptying.length; b++) {
                  let meshB = new Mesh(
                    new BoxGeometry(
                      emptying[b].userData.sinkWidth - 0.03,
                      0.55,
                      0.036
                    ),
                    new MeshStandardMaterial({
                      color: new Color("#FF5512"),
                    })
                  );
                  // scene.add(meshB);

                  if (objDraggable.rotation.y == degrees_to_radians(0)) {
                    x = emptying[b].position.x - emptying[b].userData.W / 2;
                    z = emptying[b].position.z + 0.55 / 2;
                    meshB.rotation.z = degrees_to_radians(90);
                    meshB.rotation.x = degrees_to_radians(90);
                  } else if (
                    objDraggable.rotation.y == degrees_to_radians(180)
                  ) {
                    x = emptying[b].position.x + emptying[b].userData.W / 2;
                    z = emptying[b].position.z - 0.55 / 2;
                    meshB.rotation.x = degrees_to_radians(-90);
                  } else if (
                    objDraggable.rotation.y == degrees_to_radians(90)
                  ) {
                    z = emptying[b].position.z + emptying[b].userData.W / 2;
                    x = emptying[b].position.x + 0.55 / 2;
                    meshB.rotation.x = degrees_to_radians(90);
                  } else if (
                    objDraggable.rotation.y == degrees_to_radians(-90)
                  ) {
                    z = emptying[b].position.z - emptying[b].userData.W / 2;
                    x = emptying[b].position.x - 0.55 / 2;
                    meshB.rotation.z = degrees_to_radians(90);
                    meshB.rotation.x = degrees_to_radians(-90);
                  }

                  meshB.position.add(
                    new Vector3(x, object.position.y + 0.018, z)
                  );

                  meshB.updateMatrix();
                  let bspB = CSG.default.fromMesh(meshB);

                  if (
                    objDraggable.rotation.y == degrees_to_radians(0) ||
                    objDraggable.rotation.y == degrees_to_radians(-90)
                  )
                    bspResult = bspResult.subtract(bspB);
                  else bspResult = bspResult.union(bspB);
                }
                // object.userData.uuid = object.uuid;
                object.material.clone();
                object.material.metalness = -0.1;
                object.material.map = textureWorktops;

                // object.material.map.repeat.set(8, 8);

                object.castShadow = true;
                object.receiveShadow = true;
                object = CSG.default.toMesh(
                  bspResult,
                  object.matrix,
                  object.material
                );
                console.log("ddcobject ", object);
              }

              object.userData.uuid = object.uuid;

              object.name = "Top";
              objDraggable.userData.finish_uuids = [];
              objDraggable.userData.finish_uuids.push(object.uuid);
              for (let index = 0; index < uuidsLeft.length; index++) {
                for (let j = 0; j < scene.children.length; j++) {
                  for (
                    let m = 0;
                    m < objDraggable.userData.finish_uuids.length;
                    m++
                  ) {
                    if (
                      scene.children[j].uuid ==
                      uuidsLeft[index].userData.finish_uuids[m]
                    ) {
                      uuidsLeft[index].userData.finish_uuids.splice(m--, 1);
                      scene.children[j].children = [];
                      scene.remove(scene.children[j--]);
                    }
                    // }
                  }
                }
                uuidsLeft[index].userData.finish_uuids = [];
                uuidsLeft[index].userData.finish_uuids.push(object.uuid);
              }
              for (let index = 0; index < uuidsRight.length; index++) {
                for (let j = 0; j < scene.children.length; j++) {
                  for (
                    let m = 0;
                    m < objDraggable.userData.finish_uuids.length;
                    m++
                  ) {
                    if (
                      scene.children[j].uuid ==
                      uuidsRight[index].userData.finish_uuids
                    ) {
                      uuidsRight[index].userData.finish_uuids.splice(m--, 1);
                      scene.children[j].children = [];
                      scene.remove(scene.children[j--]);
                    }
                  }
                }
                uuidsRight[index].userData.finish_uuids = [];
                uuidsRight[index].userData.finish_uuids.push(object.uuid);
              }
              object.userData.rotationY = objDraggable.rotation.y;

              if (is2D) object.visible = false;

              finishTops.push(object);
              // console.log("object.scale.x   ", object.scale.x);
              // console.log("object.scale.y   ", object.scale.y);
              // console.log("object.scale.z   ", object.scale.z);
              // object.uuid.type='filler';
              scene.add(object);
            }
          );
        }
        deleteLines("SelectedObject");
        uuidSelected = [];
        postData();
        uuidSelected[0] = uuidOfMeasures;
        clearMeasuresLines();
        await calcMeasuresFunc();
        break;
      }
    }
  }
};

async function drawFinishTop(objDraggable) {
  // Finish Tops
  if (objDraggable.userData.hasSink == true) {
    // console.log('emptying 33  ',objDraggable.userData.hasSink);
    var flag = true;
    for (let index = 0; index < emptying.length; index++) {
      if (emptying[index].uuid == objDraggable.uuid) {
        flag = false;
        break;
      }
    }

    if (flag == true) {
      emptying.push(objDraggable);
    }
  }
  for (let s = 0; s < scene.children.length; s++) {
    if (scene.children[s].uuid == objDraggable.uuid) {
      if (objDraggable.name == "B") {
        (uuidsLeft = []), (uuidsRight = []);
        let finishTopId = objDraggable.userData.finish_uuids;
        let Id = objDraggable.uuid;
        await finishTop(objDraggable);
        // console.log("Scene   ", scene);

        for await (let obj of scene.children) {
          for (let m = 0; m < objDraggable.userData.finish_uuids.length; m++) {
            if (obj.uuid == objDraggable.userData.finish_uuids[m]) {
              obj.visible = false;
              obj.children = [];
              scene.remove(obj);
              objDraggable.userData.finish_uuids.splice(m--, 1);
              // break;
            }
          }
        }

        let widthTop = 0;
        let remain = 0;

        // console.log("uuidsRight   ", uuidsRight);
        // console.log("uuidsLeft   ", uuidsLeft);

        //        await loaderr.load("/obj/newObjects/finish_top.glb", function (gltf) {
        await loaderr.load(
          "https://storage.googleapis.com/kitchendata/accessories/finish_top.glb",
          function (gltf) {
            // console.log("7");

            let object = gltf.scene.children[0];
            widthTop = objDraggable.userData.W;

            if (uuidsLeft.length == 0) {
              object.position.x = objDraggable.position.x;
              object.position.z = objDraggable.position.z;
            } else {
              object.position.x = uuidsLeft[uuidsLeft.length - 1].position.x;
              object.position.z = uuidsLeft[uuidsLeft.length - 1].position.z;
            }

            if (uuidsRight.length > 0) {
              widthTop = uuidsRight[uuidsRight.length - 1].userData.W;
            }

            if (objDraggable.rotation.y == degrees_to_radians(0)) {
              /**
               * widthTop is the distance with the filler
               */

              let objCheck = null;
              if (uuidsLeft.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsLeft[uuidsLeft.length - 1];
              }

              if (objCheck.position.x + 0.2 > measuresXG.max - wallWidth) {
                widthTop = measuresXG.max - wallWidth - objCheck.position.x;
                let remain = 0;
                if (uuidsRight.length > 0)
                  remain = uuidsRight[uuidsRight.length - 1].userData.W;
                else remain = objDraggable.userData.W;

                widthTop += remain;
                object.position.x = measuresXG.max - wallWidth;
              }

              if (uuidsRight.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsRight[uuidsRight.length - 1];
              }

              if (
                objCheck.position.x - objCheck.userData.W - 0.2 <
                measuresXG.min + wallWidth
              ) {
                widthTop = -measuresXG.min - wallWidth + objCheck.position.x;
              }

              /**
               * Check 4 cases about the object
               */
              if (uuidsLeft.length == 0) {
                if (uuidsRight.length == 0) {
                  object.scale.x =
                    object.position.x - (object.position.x - widthTop);
                } else {
                  if (
                    Math.abs(
                      uuidsRight[uuidsRight.length - 1].position.x -
                        uuidsRight[uuidsRight.length - 1].userData.W -
                        measuresXG.min -
                        wallWidth
                    ) <= 0.2
                  ) {
                    remain =
                      -measuresXG.min -
                      wallWidth +
                      (uuidsRight[uuidsRight.length - 1].position.x -
                        uuidsRight[uuidsRight.length - 1].userData.W);
                  }

                  object.scale.x =
                    object.position.x -
                    (uuidsRight[uuidsRight.length - 1].position.x -
                      uuidsRight[uuidsRight.length - 1].userData.W) +
                    remain;
                }
              } else {
                if (uuidsRight.length == 0) {
                  object.scale.x =
                    uuidsLeft[uuidsLeft.length - 1].position.x -
                    objDraggable.position.x +
                    widthTop;

                  // console.log(
                  //   "uuidsLeft[uuidsLeft.length - 1].position.x ",
                  //   uuidsLeft[uuidsLeft.length - 1].position.x
                  // );
                  // console.log(
                  //   "objDraggable.position.x   ",
                  //   objDraggable.position.x
                  // );
                  // console.log("widthTop  ", widthTop);
                  // console.log(
                  //   "objDraggable.userData.W  ",
                  //   objDraggable.userData.W
                  // );
                  // console.log("object.scale.x   ", object.scale.x);
                } else {
                  // console.log(
                  //   "uuidsLeft[uuidsLeft.length - 1].position.x    ",
                  //   uuidsLeft[uuidsLeft.length - 1].position.x
                  // );
                  // console.log(
                  //   "uuidsRight[uuidsRight.length - 1].position.x   ",
                  //   uuidsRight[uuidsRight.length - 1].position.x
                  // );
                  // console.log("widthTop    ", widthTop);
                  object.scale.x =
                    uuidsLeft[uuidsLeft.length - 1].position.x -
                    (uuidsRight[uuidsRight.length - 1].position.x - widthTop);
                }
              }

              object.scale.z = objDraggable.userData.L;
              object.rotation.y = objDraggable.rotation.y;
              // console.log("DDD   "  , object.scale.x);
            } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
              let objCheck = null;
              if (uuidsLeft.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsLeft[uuidsLeft.length - 1];
              }

              if (objCheck.position.x - 0.2 < measuresXG.min + wallWidth) {
                widthTop = objCheck.position.x - measuresXG.min - wallWidth;
                let remain = 0;
                if (uuidsRight.length > 0)
                  remain = uuidsRight[uuidsRight.length - 1].userData.W;
                else remain = objDraggable.userData.W;

                widthTop += remain;

                object.position.x = measuresXG.min + wallWidth;
              }

              if (uuidsRight.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsRight[uuidsRight.length - 1];
              }

              if (
                objCheck.position.x + objCheck.userData.W + 0.2 >
                measuresXG.max - wallWidth
              ) {
                widthTop = measuresXG.max - wallWidth - objCheck.position.x;
              }

              if (uuidsLeft.length == 0) {
                if (uuidsRight.length == 0) {
                  object.scale.x =
                    object.position.x - (object.position.x + widthTop);
                } else {
                  if (
                    measuresXG.max -
                      wallWidth -
                      (uuidsRight[uuidsRight.length - 1].position.x +
                        uuidsRight[uuidsRight.length - 1].userData.W) <=
                    0.2
                  ) {
                    remain =
                      measuresXG.max -
                      wallWidth -
                      (uuidsRight[uuidsRight.length - 1].position.x +
                        uuidsRight[uuidsRight.length - 1].userData.W);
                  }
                  object.scale.x =
                    object.position.x -
                    (uuidsRight[uuidsRight.length - 1].position.x +
                      uuidsRight[uuidsRight.length - 1].userData.W) -
                    remain;
                  // remain;
                }
              } else {
                if (uuidsRight.length == 0) {
                  object.scale.x =
                    uuidsLeft[uuidsLeft.length - 1].position.x -
                    (objDraggable.position.x + widthTop);
                } else {
                  object.scale.x =
                    uuidsLeft[uuidsLeft.length - 1].position.x -
                    uuidsRight[uuidsRight.length - 1].position.x -
                    widthTop;
                }
              }
              object.position.z = object.position.z - objDraggable.userData.L;
              object.scale.z = objDraggable.userData.L;
            } else if (objDraggable.rotation.y == degrees_to_radians(90)) {
              let objCheck = null;
              if (uuidsLeft.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsLeft[uuidsLeft.length - 1];
              }

              if (objCheck.position.z - 0.2 < measuresZG.min + wallWidth) {
                widthTop = objCheck.position.z - measuresZG.min - wallWidth;
                let remain = 0;

                if (uuidsRight.length > 0)
                  remain = uuidsRight[uuidsRight.length - 1].userData.W;
                else remain = objDraggable.userData.W;

                widthTop += remain;

                object.position.z = measuresZG.min + wallWidth;
              }

              if (uuidsRight.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsRight[uuidsRight.length - 1];
              }

              if (
                objCheck.position.z + objCheck.userData.W + 0.2 >
                measuresZG.max - wallWidth
              ) {
                widthTop = measuresZG.max - wallWidth - objCheck.position.z;
              }

              if (uuidsLeft.length == 0) {
                if (uuidsRight.length == 0) {
                  object.scale.z =
                    object.position.z - (object.position.z + widthTop);
                } else {
                  if (
                    measuresZG.max -
                      wallWidth -
                      (uuidsRight[uuidsRight.length - 1].position.z +
                        uuidsRight[uuidsRight.length - 1].userData.W) <=
                    0.2
                  ) {
                    remain =
                      measuresZG.max -
                      wallWidth -
                      (uuidsRight[uuidsRight.length - 1].position.z +
                        uuidsRight[uuidsRight.length - 1].userData.W);
                  }
                  object.scale.z =
                    object.position.z -
                    (uuidsRight[uuidsRight.length - 1].position.z +
                      uuidsRight[uuidsRight.length - 1].userData.W) -
                    remain;
                }
              } else {
                if (uuidsRight.length == 0) {
                  object.scale.z =
                    uuidsLeft[uuidsLeft.length - 1].position.z -
                    (objDraggable.position.z + widthTop);
                } else {
                  object.scale.z =
                    uuidsLeft[uuidsLeft.length - 1].position.z -
                    (uuidsRight[uuidsRight.length - 1].position.z + widthTop);
                }
              }

              object.rotation.y =
                objDraggable.rotation.y + degrees_to_radians(90);
              object.scale.x = objDraggable.userData.L;
            }
            // -90 degree
            else {
              let objCheck = null;
              if (uuidsLeft.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsLeft[uuidsLeft.length - 1];
              }
              if (objCheck.position.z + 0.2 > measuresZG.max - wallWidth) {
                widthTop = measuresZG.max - wallWidth - objCheck.position.z;
                let remain = 0;

                if (uuidsRight.length > 0)
                  remain = uuidsRight[uuidsRight.length - 1].userData.W;
                else remain = objDraggable.userData.W;

                widthTop += remain;

                object.position.z = measuresZG.max - wallWidth;
              }

              if (uuidsRight.length == 0) {
                objCheck = objDraggable;
              } else {
                objCheck = uuidsRight[uuidsRight.length - 1];
              }

              if (
                objCheck.position.z - objCheck.userData.W - 0.2 <
                measuresZG.min + wallWidth
              ) {
                widthTop = objCheck.position.z + measuresZG.max - wallWidth;
                // object.position.z = measures.length/2;
              }

              if (uuidsLeft.length == 0) {
                if (uuidsRight.length == 0) {
                  object.scale.z =
                    object.position.z - (object.position.z + widthTop);
                  object.scale.x = objDraggable.userData.L;
                  object.rotation.y =
                    objDraggable.rotation.y + degrees_to_radians(90);
                } else {
                  if (
                    uuidsRight[uuidsRight.length - 1].position.z -
                      uuidsRight[uuidsRight.length - 1].userData.W -
                      measuresZG.min -
                      wallWidth <=
                    0.2
                  ) {
                    remain =
                      uuidsRight[uuidsRight.length - 1].position.z -
                      uuidsRight[uuidsRight.length - 1].userData.W -
                      measuresZG.min -
                      wallWidth;
                  }
                  object.scale.x =
                    object.position.z -
                    (uuidsRight[uuidsRight.length - 1].position.z -
                      uuidsRight[uuidsRight.length - 1].userData.W) +
                    remain;
                  // remain;
                  object.scale.z = objDraggable.userData.L;
                  object.rotation.y = objDraggable.rotation.y;
                }
              } else {
                if (uuidsRight.length == 0) {
                  object.scale.x =
                    uuidsLeft[uuidsLeft.length - 1].position.z -
                    (objDraggable.position.z - widthTop);
                  object.scale.z = objDraggable.userData.L;
                  object.rotation.y = objDraggable.rotation.y;
                } else {
                  object.scale.x =
                    uuidsLeft[uuidsLeft.length - 1].position.z -
                    (uuidsRight[uuidsRight.length - 1].position.z - widthTop);

                  object.scale.z = objDraggable.userData.L;
                  object.rotation.y = objDraggable.rotation.y;
                }
              }
            }

            // if (objDraggable.rotation.y == degrees_to_radians(0)) {
            //   if (object.position.x + 0.2 > measuresXG.max) {
            //     // console.log("FFF");
            //     widthTop =
            //       measuresXG.max - object.position.x + objDraggable.userData.W;
            //     object.position.x = measuresXG.max;
            //   } else if (
            //     object.position.x - objDraggable.userData.W - 0.2 <
            //     measuresXG.min
            //   ) {
            //     // console.log("DDD");

            //     widthTop = measuresXG.max - wallWidth + object.position.x;

            //     // object.position.x = - measures.width/2;
            //   }

            //   if (uuidsLeft.length == 0) {
            //     if (uuidsRight.length == 0) {
            //       object.scale.x =
            //         object.position.x - (object.position.x - widthTop);
            //     } else {
            //       if (
            //         Math.abs(
            //           uuidsRight[uuidsRight.length - 1].position.x -
            //             uuidsRight[uuidsRight.length - 1].userData.W -
            //             measuresXG.min
            //         ) <= 0.2
            //       ) {
            //         remain =
            //           -measuresXG.min +
            //           (uuidsRight[uuidsRight.length - 1].position.x -
            //             uuidsRight[uuidsRight.length - 1].userData.W);
            //       }
            //       // console.log("WidthTop  " , widthTop);
            //       // console.log(" object.position.x  ",  object.position.x);
            //       // console.log(" measuresXG.max   ",  uuidsRight[uuidsRight.length - 1].position.x);
            //       // console.log(" object.position.x   ",   uuidsRight[uuidsRight.length - 1].userData.W );
            //       object.scale.x =
            //         object.position.x -
            //         (uuidsRight[uuidsRight.length - 1].position.x -
            //           uuidsRight[uuidsRight.length - 1].userData.W) +
            //         remain;

            //       // object.scale.x = widthTop ;
            //     }
            //   } else {
            //     if (uuidsRight.length == 0) {
            //       object.scale.x =
            //         uuidsLeft[uuidsLeft.length - 1].position.x -
            //         objDraggable.position.x +
            //         widthTop;
            //       // console.log('uuidsLeft[uuidsLeft.length - 1].position.x  ' , uuidsLeft[uuidsLeft.length - 1].position.x );
            //       // console.log('object.position.x   ' , objDraggable.position.x  );
            //       // console.log('widthTop  ' , widthTop  );
            //     } else {
            //       object.scale.x =
            //         uuidsLeft[uuidsLeft.length - 1].position.x -
            //         (uuidsRight[uuidsRight.length - 1].position.x -
            //           uuidsRight[uuidsRight.length - 1].userData.W);
            //     }
            //   }
            //   object.scale.z = objDraggable.userData.L;
            //   object.rotation.y = objDraggable.rotation.y;
            //   // console.log("DDD   "  , object.scale.x);
            // } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
            //   if (object.position.x - 0.2 < measuresXG.min) {
            //     widthTop =
            //       object.position.x + measuresXG.max + objDraggable.userData.W;
            //     object.position.x = measuresXG.min;
            //   } else if (
            //     object.position.x + objDraggable.userData.W + 0.2 >
            //     measuresXG.max
            //   ) {
            //     widthTop = measuresXG.max - object.position.x;
            //     // object.position.x = measures.width/2;
            //   }
            //   if (uuidsLeft.length == 0) {
            //     if (uuidsRight.length == 0) {
            //       object.scale.x =
            //         object.position.x - (object.position.x + widthTop);
            //     } else {
            //       if (
            //         measuresXG.max -
            //           (uuidsRight[uuidsRight.length - 1].position.x +
            //             uuidsRight[uuidsRight.length - 1].userData.W) <=
            //         0.2
            //       ) {
            //         remain =
            //           measuresXG.max -
            //           (uuidsRight[uuidsRight.length - 1].position.x +
            //             uuidsRight[uuidsRight.length - 1].userData.W);
            //       }
            //       object.scale.x =
            //         object.position.x -
            //         (uuidsRight[uuidsRight.length - 1].position.x +
            //           uuidsRight[uuidsRight.length - 1].userData.W) -
            //         remain;
            //     }
            //   } else {
            //     if (uuidsRight.length == 0) {
            //       object.scale.x =
            //         uuidsLeft[uuidsLeft.length - 1].position.x -
            //         (objDraggable.position.x + widthTop);
            //     } else {
            //       object.scale.x =
            //         uuidsLeft[uuidsLeft.length - 1].position.x -
            //         (uuidsRight[uuidsRight.length - 1].position.x +
            //           uuidsRight[uuidsRight.length - 1].userData.W);
            //     }
            //   }
            //   object.position.z = object.position.z - objDraggable.userData.L;
            //   object.scale.z = objDraggable.userData.L;
            // } else if (objDraggable.rotation.y == degrees_to_radians(90)) {
            //   if (object.position.z - 0.2 < measuresZG.min) {
            //     widthTop =
            //       object.position.z + measuresZG.max + objDraggable.userData.W;
            //     object.position.z = measuresZG.min;
            //   } else if (
            //     object.position.z + objDraggable.userData.W + 0.2 >
            //     measuresZG.max
            //   ) {
            //     widthTop = measuresZG.max - object.position.z;
            //     // object.position.z = measures.length/2;
            //   }
            //   if (uuidsLeft.length == 0) {
            //     if (uuidsRight.length == 0) {
            //       object.scale.z =
            //         object.position.z - (object.position.z + widthTop);
            //     } else {
            //       if (
            //         measuresZG.max -
            //           (uuidsRight[uuidsRight.length - 1].position.z +
            //             uuidsRight[uuidsRight.length - 1].userData.W) <=
            //         0.2
            //       ) {
            //         remain =
            //           measuresZG.max -
            //           (uuidsRight[uuidsRight.length - 1].position.z +
            //             uuidsRight[uuidsRight.length - 1].userData.W);
            //         // console.log("Remain  ", remain);
            //       }
            //       object.scale.z =
            //         object.position.z -
            //         (uuidsRight[uuidsRight.length - 1].position.z +
            //           uuidsRight[uuidsRight.length - 1].userData.W) -
            //         remain;
            //     }
            //   } else {
            //     if (uuidsRight.length == 0) {
            //       object.scale.z =
            //         uuidsLeft[uuidsLeft.length - 1].position.z -
            //         (objDraggable.position.z + widthTop);
            //     } else {
            //       object.scale.z =
            //         uuidsLeft[uuidsLeft.length - 1].position.z -
            //         (uuidsRight[uuidsRight.length - 1].position.z +
            //           uuidsRight[uuidsRight.length - 1].userData.W);
            //     }
            //   }
            //   object.rotation.y =
            //     objDraggable.rotation.y + degrees_to_radians(90);
            //   object.position.x = object.position.x;
            //   object.scale.x = objDraggable.userData.L;
            // } else {
            //   if (object.position.z + 0.2 > measuresZG.max) {
            //     widthTop =
            //       measuresZG.max - object.position.z + objDraggable.userData.W;
            //     object.position.z = measuresZG.max;
            //   } else if (
            //     object.position.z - objDraggable.userData.W - 0.2 <
            //     measuresZG.min
            //   ) {
            //     widthTop = object.position.z + measuresZG.max;
            //     // object.position.z = measures.length/2;
            //   }
            //   if (uuidsLeft.length == 0) {
            //     if (uuidsRight.length == 0) {
            //       object.scale.z =
            //         object.position.z - (object.position.z + widthTop);
            //       object.scale.x = objDraggable.userData.L;
            //       object.rotation.y =
            //         objDraggable.rotation.y + degrees_to_radians(90);
            //     } else {
            //       if (
            //         uuidsRight[uuidsRight.length - 1].position.z -
            //           uuidsRight[uuidsRight.length - 1].userData.W -
            //           measuresZG.min <=
            //         0.2
            //       ) {
            //         remain =
            //           uuidsRight[uuidsRight.length - 1].position.z -
            //           uuidsRight[uuidsRight.length - 1].userData.W -
            //           measuresZG.min;
            //       }
            //       object.scale.x =
            //         object.position.z -
            //         (uuidsRight[uuidsRight.length - 1].position.z -
            //           uuidsRight[uuidsRight.length - 1].userData.W) +
            //         remain;
            //       object.scale.z = objDraggable.userData.L;
            //       object.rotation.y = objDraggable.rotation.y;
            //     }
            //   } else {
            //     if (uuidsRight.length == 0) {
            //       object.scale.x =
            //         uuidsLeft[uuidsLeft.length - 1].position.z -
            //         (objDraggable.position.z - widthTop);
            //       object.scale.z = objDraggable.userData.L;
            //       object.rotation.y = objDraggable.rotation.y;
            //     } else {
            //       object.scale.x =
            //         uuidsLeft[uuidsLeft.length - 1].position.z -
            //         (uuidsRight[uuidsRight.length - 1].position.z -
            //           uuidsRight[uuidsRight.length - 1].userData.W);
            //       object.scale.z = objDraggable.userData.L;
            //       object.rotation.y = objDraggable.rotation.y;
            //     }
            //   }
            // }

            object.position.y =
              objDraggable.position.y + objDraggable.userData.H + 0.1;

            textureWorktops = textureLoader.load(
              "./colors/" + worktopsColor + ".png"
            );
            objDraggable.userData.worktops = worktopsColor;
            textureWorktops.wrapS = textureWorktops.wrapT = RepeatWrapping;
            textureWorktops.offset.set(0.02, 0.02);
            textureWorktops.repeat.set(0.02, 0.02);
            object.material.clone();
            object.material.metalness = -0.1;
            object.material.map = textureWorktops;

            // object.material.map.repeat.set(8, 8);
            // object.material.map.repeat.set(
            //   ((object.scale.x / 2) * 2) / 0.05,
            //   ((object.scale.z / 2) * 2) / 0.05
            // );

            object.castShadow = true;
            object.receiveShadow = true;

            // object.userData.uuidObj = objDraggable.uuid;
            // if (is2D) object.visible = false;

            object.name = "TOP";
            object.scale.x = object.scale.x / 2;
            object.scale.z = object.scale.z / 2;
            if (emptying.length > 0) {
              // console.log("object  ss", object);
              // console.log("emptying[0] ", emptying[0]);
              let meshB = new Mesh(
                new BoxGeometry(
                  emptying[0].userData.sinkWidth - 0.03,
                  0.55,
                  0.036
                ),
                new MeshStandardMaterial({
                  color: new Color("#FF5512"),
                })
              );
              //  console.log("position  ",meshB.position);
              let x = 0;
              let z = 0;
              if (objDraggable.rotation.y == degrees_to_radians(0)) {
                x = emptying[0].position.x - emptying[0].userData.W / 2;
                z = emptying[0].position.z + 0.55 / 2;
                meshB.rotation.z = degrees_to_radians(90);
                meshB.rotation.x = degrees_to_radians(90);
              } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
                x = emptying[0].position.x + emptying[0].userData.W / 2;
                z = emptying[0].position.z - 0.55 / 2;
                meshB.rotation.x = degrees_to_radians(-90);
                meshB.rotation.z = degrees_to_radians(-90);
              } else if (objDraggable.rotation.y == degrees_to_radians(90)) {
                z = emptying[0].position.z + emptying[0].userData.W / 2;
                x = emptying[0].position.x + 0.55 / 2;
                meshB.rotation.z = degrees_to_radians(-90);
                meshB.rotation.x = degrees_to_radians(90);
              } else if (objDraggable.rotation.y == degrees_to_radians(-90)) {
                z = emptying[0].position.z - emptying[0].userData.W / 2;
                x = emptying[0].position.x - 0.55 / 2;
                meshB.rotation.z = degrees_to_radians(90);
                meshB.rotation.x = degrees_to_radians(-90);
              }
              meshB.position.add(new Vector3(x, object.position.y + 0.018, z));

              meshB.updateMatrix();
              object.updateMatrix();

              let bspA = CSG.default.fromMesh(object);
              let bspB = CSG.default.fromMesh(meshB);
              let bspResult = "";

              if (objDraggable.rotation.y == degrees_to_radians(0))
                bspResult = bspA.subtract(bspB);
              else bspResult = bspA.union(bspB);

              if (
                objDraggable.rotation.y == degrees_to_radians(-90) &&
                emptying.length > 1
              )
                bspResult = bspA.subtract(bspB);

              for (let b = 1; b < emptying.length; b++) {
                let meshB = new Mesh(
                  new BoxGeometry(
                    emptying[b].userData.sinkWidth - 0.03,
                    0.55,
                    0.036
                  ),
                  new MeshStandardMaterial({
                    color: new Color("#FF5512"),
                  })
                );
                // scene.add(meshB);

                if (objDraggable.rotation.y == degrees_to_radians(0)) {
                  x = emptying[b].position.x - emptying[b].userData.W / 2;
                  z = emptying[b].position.z + 0.55 / 2;
                  meshB.rotation.z = degrees_to_radians(90);
                  meshB.rotation.x = degrees_to_radians(90);
                } else if (objDraggable.rotation.y == degrees_to_radians(180)) {
                  x = emptying[b].position.x + emptying[b].userData.W / 2;
                  z = emptying[b].position.z - 0.55 / 2;
                  meshB.rotation.x = degrees_to_radians(-90);
                } else if (objDraggable.rotation.y == degrees_to_radians(90)) {
                  z = emptying[b].position.z + emptying[b].userData.W / 2;
                  x = emptying[b].position.x + 0.55 / 2;
                  meshB.rotation.x = degrees_to_radians(90);
                } else if (objDraggable.rotation.y == degrees_to_radians(-90)) {
                  z = emptying[b].position.z - emptying[b].userData.W / 2;
                  x = emptying[b].position.x - 0.55 / 2;
                  meshB.rotation.z = degrees_to_radians(90);
                  meshB.rotation.x = degrees_to_radians(-90);
                }

                meshB.position.add(
                  new Vector3(x, object.position.y + 0.018, z)
                );

                meshB.updateMatrix();
                let bspB = CSG.default.fromMesh(meshB);

                if (
                  objDraggable.rotation.y == degrees_to_radians(0) ||
                  objDraggable.rotation.y == degrees_to_radians(-90)
                )
                  bspResult = bspResult.subtract(bspB);
                else bspResult = bspResult.union(bspB);
              }
              // object.userData.uuid = object.uuid;
              object.material.clone();
              object.material.metalness = -0.1;
              object.material.map = textureWorktops;

              // object.material.map.repeat.set(8, 8);

              object.castShadow = true;
              object.receiveShadow = true;
              object = CSG.default.toMesh(
                bspResult,
                object.matrix,
                object.material
              );
              console.log("ddcobject ", object);
            }

            object.userData.uuid = object.uuid;

            object.name = "Top";
            objDraggable.userData.finish_uuids = [];
            objDraggable.userData.finish_uuids.push(object.uuid);
            for (let index = 0; index < uuidsLeft.length; index++) {
              for (let j = 0; j < scene.children.length; j++) {
                for (
                  let m = 0;
                  m < objDraggable.userData.finish_uuids.length;
                  m++
                ) {
                  if (
                    scene.children[j].uuid ==
                    uuidsLeft[index].userData.finish_uuids[m]
                  ) {
                    uuidsLeft[index].userData.finish_uuids.splice(m--, 1);
                    scene.children[j].children = [];
                    scene.remove(scene.children[j--]);
                  }
                  // }
                }
              }
              uuidsLeft[index].userData.finish_uuids = [];
              uuidsLeft[index].userData.finish_uuids.push(object.uuid);
            }
            for (let index = 0; index < uuidsRight.length; index++) {
              for (let j = 0; j < scene.children.length; j++) {
                for (
                  let m = 0;
                  m < objDraggable.userData.finish_uuids.length;
                  m++
                ) {
                  if (
                    scene.children[j].uuid ==
                    uuidsRight[index].userData.finish_uuids
                  ) {
                    uuidsRight[index].userData.finish_uuids.splice(m--, 1);
                    scene.children[j].children = [];
                    scene.remove(scene.children[j--]);
                  }
                }
              }
              uuidsRight[index].userData.finish_uuids = [];
              uuidsRight[index].userData.finish_uuids.push(object.uuid);
            }

            // object.userData.uuid = object.uuid;
            // object.material.metalness = -0.1;
            // object.material.map = textureWorktops;

            // object.material.map.repeat.set(8, 8);

            // object.castShadow = true;
            // object.receiveShadow = true;

            // object.userData.uuid = object.uuid;
            // object.material.metalness = -0.1;
            // object.material.map = textureWorktops;

            // object.material.map.repeat.set(8, 8);

            // object.castShadow = true;
            // object.receiveShadow = true;
            object.userData.rotationY = objDraggable.rotation.y;

            if (is2D) object.visible = false;

            finishTops.push(object);

            // object.uuid.type='filler';
            scene.add(object);
          }
        );
      }
      postData();
      break;
    }
  }
}
let finishTopSizeBack = 0;
let finishTopSizeLeft = 0;

window.screenShot = () => {
  camera.position.set(0, 5, 0);
  controls.target.set(0, 0, 0);
  controls.enabled = false;

  // Draw essential lines
  const material = new LineBasicMaterial({ color: 0x0000ff });
  const points = [];
  // Top Line
  points.push(new Vector3(measuresXG.min, 0, measuresZG.min - 1));
  points.push(new Vector3(+measuresXG.max, 0, measuresZG.min - 1));
  const geometryTop = new BufferGeometry().setFromPoints(points);

  lineTop = new Line(geometryTop, material);
  lineTop.userData.type = "Line";
  lineTop.userData.wall = "width";

  scene.add(lineTop);

  // Left Line
  while (points.length > 0) {
    points.pop();
  }

  points.push(new Vector3(measuresXG.min - 1, 0, measuresZG.max));
  points.push(new Vector3(measuresXG.min - 1, 0, measuresZG.min));

  const geometryLeft = new BufferGeometry().setFromPoints(points);
  lineLeft = new Line(geometryLeft, material);
  lineLeft.userData.type = "Line";
  lineLeft.userData.wall = "length";
  scene.add(lineLeft);

  // Right Line
  while (points.length > 0) {
    points.pop();
  }

  points.push(new Vector3(measuresXG.max + 1, 0, measuresZG.max));

  points.push(new Vector3(measuresXG.max + 1, 0, measuresZG.min));

  const geometryRight = new BufferGeometry().setFromPoints(points);

  lineRight = new Line(geometryRight, material);
  lineRight.userData.type = "Line";
  lineRight.userData.wall = "length";

  scene.add(lineRight);

  // Bottom Line
  while (points.length > 0) {
    points.pop();
  }

  points.push(new Vector3(measuresXG.min, 0, measuresZG.max + 1));

  points.push(new Vector3(+measuresXG.max, 0, measuresZG.max + 1));

  const geometryBottom = new BufferGeometry().setFromPoints(points);

  lineBottom = new Line(geometryBottom, material);
  lineBottom.userData.type = "Line";
  lineBottom.userData.wall = "width";

  scene.add(lineBottom);

  /// End essential lines
  const loaderr = new FontLoader();
  loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
    const color = new Color(0x00000);

    const matLite = new MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 0.6,
      side: DoubleSide,
    });

    const shapesTop = font.generateShapes(
      "" + Math.ceil((measuresXG.max - measuresXG.min - 0.2) * 1000) + " mm",
      150
    );
    const geometryTopBottom = new ShapeGeometry(shapesTop);
    geometryTopBottom.computeBoundingBox();
    geometryTopBottom.translate(
      -0.5 *
        (geometryTopBottom.boundingBox.max.x -
          geometryTopBottom.boundingBox.min.x),
      0,
      0
    );

    textBottom = new Mesh(geometryTopBottom, matLite);
    textBottom.position.set(0, 0, measuresZG.max + 1.2);
    textBottom.scale.set(0.0007, 0.0007, 0.0007);
    textBottom.rotation.x = degrees_to_radians(270);
    textBottom.rotation.z = degrees_to_radians(0);
    textBottom.userData.type = "Text";

    scene.add(textBottom);

    textTop = new Mesh(geometryTopBottom, matLite);
    textTop.position.set(0, 0, measuresZG.min - 1.2);
    textTop.scale.set(0.0007, 0.0007, 0.0007);
    textTop.rotation.x = degrees_to_radians(270);
    textTop.rotation.z = degrees_to_radians(0);
    textTop.userData.type = "Text";

    scene.add(textTop);

    const shapesLeftRight = font.generateShapes(
      "" + Math.ceil((measuresZG.max - measuresZG.min - 0.2) * 1000) + " mm",
      150
    );
    const geometryLeftRight = new ShapeGeometry(shapesLeftRight);
    geometryLeftRight.computeBoundingBox();
    geometryLeftRight.translate(
      -0.5 *
        (geometryLeftRight.boundingBox.max.x -
          geometryLeftRight.boundingBox.min.x),
      0,
      0
    );

    textLeft = new Mesh(geometryLeftRight, matLite);
    textLeft.scale.set(0.0007, 0.0007, 0.0007);
    textLeft.position.set(measuresXG.min - 1.2, 0, 0);

    textLeft.rotation.x = degrees_to_radians(270);
    textLeft.rotation.z = degrees_to_radians(90);
    textLeft.userData.type = "Text";

    scene.add(textLeft);

    textRight = new Mesh(geometryLeftRight, matLite);
    textRight.scale.set(0.0007, 0.0007, 0.0007);
    textRight.position.set(measuresXG.max + 1.2, 0, 0);

    textRight.rotation.x = degrees_to_radians(270);
    textRight.rotation.z = degrees_to_radians(90);
    textRight.userData.type = "Text";

    scene.add(textRight);

    render();
  }); //end essential texts

  let positionsZTopLines = [];
  let positionsZBottomLines = [];
  let positionsXLeftLines = [];
  let positionsXRightLines = [];
  // Draw lines of objects
  let distanceTop = 0.6;
  //  const materialObjects = new LineBasicMaterial({ color: 0xff0000 });
  //  const materialRight = new LineBasicMaterial({ color: 0x000000 });

  for (let index = 0; index < objects.length; index++) {
    if (
      objects[index].rotation.y == degrees_to_radians(0) &&
      objects[index].position.z === measuresZG.min + wallWidth &&
      objects[index].name !== "B" &&
      objects[index].userData.Type == "object"
    ) {
      const from = objects[index].position.x - objects[index].userData.W;
      drawLine(
        from,
        measuresZG.min - distanceTop,
        objects[index].position.x,
        measuresZG.min - distanceTop,
        null,
        materialObjects
      );

      positionsZTopLines.push({
        begin: from,
        width: objects[index].userData.W,
      });

      writeText(
        objects[index].userData.W,
        from + objects[index].userData.W / 2,
        measuresZG.min - 0.15 - distanceTop
      );
    } else if (
      objects[index].rotation.y == degrees_to_radians(180) &&
      objects[index].position.z === measuresZG.max - wallWidth &&
      objects[index].name !== "B" &&
      objects[index].userData.Type == "object"
    ) {
      // Draw lines of objects
      const from = objects[index].position.x;
      drawLine(
        from,
        measuresZG.max + distanceTop,
        objects[index].position.x + objects[index].userData.W,
        measuresZG.max + distanceTop,
        null,
        materialObjects
      );

      positionsZBottomLines.push({
        begin: from,
        width: objects[index].userData.W,
      });

      writeText(
        objects[index].userData.W,
        from + objects[index].userData.W / 2,
        measuresZG.max + distanceTop + 0.15
      );
    } else if (
      objects[index].rotation.y == degrees_to_radians(-90) &&
      objects[index].position.x === measuresXG.max - wallWidth &&
      objects[index].name !== "B" &&
      objects[index].userData.Type == "object"
    ) {
      // Draw lines of objects
      const from = objects[index].position.z - objects[index].userData.W;
      drawLine(
        +measuresXG.max + distanceTop,
        from,
        +measuresXG.max + distanceTop,
        objects[index].position.z,
        null,
        materialObjects
      );

      positionsXRightLines.push({
        begin: from,
        width: objects[index].userData.W,
      });

      writeText(
        objects[index].userData.W,
        +measuresXG.max + distanceTop + 0.15,
        from + objects[index].userData.W / 2,
        "x+"
      );
    } else if (
      objects[index].rotation.y == degrees_to_radians(90) &&
      objects[index].position.x === measuresXG.min + wallWidth &&
      objects[index].name !== "B" &&
      objects[index].userData.Type == "object"
    ) {
      // Draw lines of objects
      const from = objects[index].position.z;
      drawLine(
        measuresXG.min - distanceTop,
        from,
        measuresXG.min - distanceTop,
        objects[index].position.z + objects[index].userData.W,
        null,
        materialObjects
      );

      positionsXLeftLines.push({
        begin: from,
        width: objects[index].userData.W,
      });

      writeText(
        objects[index].userData.W,
        measuresXG.min - distanceTop - 0.15,
        from + objects[index].userData.W / 2,
        "x-"
      );
    }
  }
  // console.log("typeLine    ", typeLine);
  // if(typeLine == '' || typeLine == 'back'){
  positionsZTopLines?.sort((a, b) => (a.begin > b.begin ? 1 : -1));
  for (let index = 0; index < positionsZTopLines.length; index++) {
    var positions = [];

    if (index === 0) {
      drawLine(
        measuresXG.min,
        measuresZG.min - distanceTop,
        positionsZTopLines[index].begin,
        measuresZG.min - distanceTop,
        positions,
        materialRight
      );

      writeText(
        positionsZTopLines[index].begin + measuresXG.max,
        (measuresXG.min + positionsZTopLines[index].begin) / 2,
        measuresZG.min - 0.15 - distanceTop
      );
    }
    let finishPoint = 0;
    if (index < positionsZTopLines.length - 1) {
      finishPoint = positionsZTopLines[index + 1].begin;
    } else {
      finishPoint = measuresXG.max;
    }

    /// x1,z1,x2,z2,positions,material
    drawLine(
      positionsZTopLines[index].begin + positionsZTopLines[index].width,
      measuresZG.min - distanceTop,
      finishPoint,
      measuresZG.min - distanceTop,
      positions,
      materialRight
    );

    const text =
      finishPoint -
      (positionsZTopLines[index].begin + positionsZTopLines[index].width);

    if (text !== 0) {
      const x =
        positionsZTopLines[index].begin +
        positionsZTopLines[index].width +
        (finishPoint -
          (positionsZTopLines[index].begin + positionsZTopLines[index].width)) /
          2;
      const y = measuresZG.min - 0.15 - distanceTop;
      writeText(text, x, y);
    }

    // positions

    var geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));

    geometry.computeBoundingSphere();

    var materialPoints = new PointsMaterial({
      size: 0.04,
      vertexColors: new MeshPhongMaterial({ color: 0xff0000 }),
    });

    let points = new Points(geometry, materialPoints);
    points.name = "points";
    scene.add(points);
  }
  // }

  // if(typeLine == '' || typeLine == 'front'){
  positionsZBottomLines?.sort((a, b) => (a.begin > b.begin ? 1 : -1));
  for (let index = 0; index < positionsZBottomLines.length; index++) {
    var positions = [];

    if (index === 0) {
      drawLine(
        measuresXG.min,
        measuresZG.max + distanceTop,
        positionsZBottomLines[index].begin,
        measuresZG.max + distanceTop,
        positions,
        materialRight
      );
      writeText(
        positionsZBottomLines[index].begin + measuresXG.max,
        (measuresXG.min + positionsZBottomLines[index].begin) / 2,
        measuresZG.max + 0.15 + distanceTop
      );
    }
    let finishPoint = 0;
    if (index < positionsZBottomLines.length - 1) {
      finishPoint = positionsZBottomLines[index + 1].begin;
    } else {
      finishPoint = measuresXG.max;
    }

    /// x1,z1,x2,z2,positions,material
    drawLine(
      positionsZBottomLines[index].begin + positionsZBottomLines[index].width,
      measuresZG.max + distanceTop,
      finishPoint,
      measuresZG.max + distanceTop,
      positions,
      materialRight
    );

    const text =
      finishPoint -
      (positionsZBottomLines[index].begin + positionsZBottomLines[index].width);

    if (text !== 0) {
      const x =
        positionsZBottomLines[index].begin +
        positionsZBottomLines[index].width +
        (finishPoint -
          (positionsZBottomLines[index].begin +
            positionsZBottomLines[index].width)) /
          2;
      const y = measuresZG.max + 0.15 + distanceTop;
      writeText(text, x, y);
    }

    // positions

    var geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));

    geometry.computeBoundingSphere();

    var materialPoints = new PointsMaterial({
      size: 0.04,
      vertexColors: new MeshPhongMaterial({ color: 0xff0000 }),
    });

    let points = new Points(geometry, materialPoints);
    points.name = "points";
    scene.add(points);
  }
  // }

  // if(typeLine == '' || typeLine == 'left'){
  positionsXLeftLines?.sort((a, b) => (a.begin > b.begin ? 1 : -1));
  for (let index = 0; index < positionsXLeftLines.length; index++) {
    var positions = [];

    if (index === 0) {
      drawLine(
        measuresXG.min - distanceTop,
        measuresZG.min,
        measuresXG.min - distanceTop,
        positionsXLeftLines[index].begin,
        positions,
        materialRight
      );
      writeText(
        positionsXLeftLines[index].begin + measuresZG.max,

        measuresXG.min - 0.15 - distanceTop,
        (measuresZG.min + positionsXLeftLines[index].begin) / 2,
        "x-"
      );
    }
    let finishPoint = 0;
    if (index < positionsXLeftLines.length - 1) {
      finishPoint = positionsXLeftLines[index + 1].begin;
    } else {
      finishPoint = measuresZG.max;
    }

    /// x1,z1,x2,z2,positions,material
    drawLine(
      measuresXG.min - distanceTop,
      positionsXLeftLines[index].begin + positionsXLeftLines[index].width,
      measuresXG.min - distanceTop,
      finishPoint,
      positions,
      materialRight
    );

    const text =
      finishPoint -
      (positionsXLeftLines[index].begin + positionsXLeftLines[index].width);

    if (text !== 0) {
      const z =
        positionsXLeftLines[index].begin +
        positionsXLeftLines[index].width +
        (finishPoint -
          (positionsXLeftLines[index].begin +
            positionsXLeftLines[index].width)) /
          2;
      const x = measuresXG.min - 0.15 - distanceTop;
      writeText(text, x, z, "x-");
    }

    // positions

    var geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));

    geometry.computeBoundingSphere();

    var materialPoints = new PointsMaterial({
      size: 0.04,
      vertexColors: new MeshPhongMaterial({ color: 0xff0000 }),
    });

    let points = new Points(geometry, materialPoints);
    points.name = "points";
    scene.add(points);
  }
  // }

  // if(typeLine == '' || typeLine == 'right'){
  positionsXRightLines?.sort((a, b) => (a.begin > b.begin ? 1 : -1));
  for (let index = 0; index < positionsXRightLines.length; index++) {
    var positions = [];

    if (index === 0) {
      drawLine(
        +measuresXG.max + distanceTop,
        measuresZG.min,
        +measuresXG.max + distanceTop,
        positionsXRightLines[index].begin,
        positions,
        materialRight
      );
      writeText(
        positionsXRightLines[index].begin + measuresZG.max,

        +measuresXG.max + 0.15 + distanceTop,
        (measuresZG.min + positionsXRightLines[index].begin) / 2,
        "x+"
      );
    }
    let finishPoint = 0;
    if (index < positionsXRightLines.length - 1) {
      finishPoint = positionsXRightLines[index + 1].begin;
    } else {
      finishPoint = measuresZG.max;
    }

    /// x1,z1,x2,z2,positions,material
    drawLine(
      +measuresXG.max + distanceTop,
      positionsXRightLines[index].begin + positionsXRightLines[index].width,
      +measuresXG.max + distanceTop,
      finishPoint,
      positions,
      materialRight
    );

    const text =
      finishPoint -
      (positionsXRightLines[index].begin + positionsXRightLines[index].width);

    if (text !== 0) {
      const z =
        positionsXRightLines[index].begin +
        positionsXRightLines[index].width +
        (finishPoint -
          (positionsXRightLines[index].begin +
            positionsXRightLines[index].width)) /
          2;
      const x = +measuresXG.max + 0.15 + distanceTop;
      writeText(text, x, z, "x+");
    }

    // positions

    var geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));

    geometry.computeBoundingSphere();

    var materialPoints = new PointsMaterial({
      size: 0.04,
      vertexColors: new MeshPhongMaterial({ color: 0xff0000 }),
    });

    let points = new Points(geometry, materialPoints);
    points.name = "points";
    scene.add(points);
  }

  let time = 40;
  setTimeout(async () => {
    let c = document.getElementById("myCanvas");
    html2canvas(c).then(async (canvas) => {
      var t = canvas.toDataURL().replace("data:image/png;base64,", "");

      var imgData = canvas.toDataURL("image/jpeg");
      axios
        .post(
          "https://alashrafy-design-default-rtdb.firebaseio.com/screens.json",
          {
            image: imgData,
          }
        )
        .then(function (response) {
          console.log(response);
        })
        .catch(function (error) {
          console.log(error);
        });
      downloadBase64File("image/png", t, "image");

      // Delete lines
      await deleteLines();

      // console.log("BC",BC);
      // console.log("FC",FC);
      // if(BC >0){
      // time = time + 80;

      let promiseDrawBackScreen = new Promise(async (resolve, reject) => {
        await drawBackScreen(500, true);
        setTimeout(() => resolve("done!"), 2000);
      });
      await promiseDrawBackScreen;
      // await drawBackScreen(time,true)
      // await drawBackScreen(time+1000,false)

      // }

      // if(LC >0){
      // time = time + 40;
      // await drawBackScreen(time)
      // time += 1000;
      // setTimeout(async()=>{
      let promiseDrawLeftScreen = new Promise(async (resolve, reject) => {
        await drawLeftScreen(500, true);
        setTimeout(() => resolve("done!"), 2000);
      });
      await promiseDrawLeftScreen;

      // await drawLeftScreen(time,true)
      // },(BC>0)? 500:200)

      // }

      // if(RC >0){
      // time = time + 40;
      // await drawBackScreen(time)
      // setTimeout(async()=>{
      // time += 1000;
      let promiseDrawRightScreen = new Promise(async (resolve, reject) => {
        await drawRightScreen(500, true);
        setTimeout(() => resolve("done!"), 2000);
      });
      await promiseDrawRightScreen;
      // await drawRightScreen(time,true)
      // },(BC>0 || LC>0)? 2000:800)
      // }
      // console.log("FC  " ,FC);
      // if(FC >0){
      // time = time + 40;
      // await drawBackScreen(time)
      // setTimeout(async()=>{
      //
      let promiseDrawFrontScreen = new Promise(async (resolve, reject) => {
        await drawFrontScreen(500, true);
        setTimeout(() => resolve("done!"), 2000);
      });
      await promiseDrawFrontScreen;

      //   time += 1000;

      // await drawFrontScreen(time,true)
      // console.log("S1");
      // },(BC>0 || LC>0 || RC > 0)? 4000:2300)
      // }
    });
  }, time);
};

window.screenShot2 = async () => {
  // console.log("S2");
  var time = 0;
  // setTimeout(async()=>{
  // if(BC >0){
  // time =  5000;

  let promiseDrawBackScreen = new Promise(async (resolve, reject) => {
    await drawBackScreen(500, false);
    setTimeout(() => resolve("done!"), 2000);
  });
  await promiseDrawBackScreen;
  // await drawBackScreen(time,false)
  // await drawBackScreen(time+1000,false)

  // }

  // if(LC >0){
  // time = time + 40;
  // await drawBackScreen(time)
  // setTimeout(async()=>{
  // time +=  1000;
  let promiseDrawLeftScreen = new Promise(async (resolve, reject) => {
    await drawLeftScreen(500, false);
    setTimeout(() => resolve("done!"), 2000);
  });
  await promiseDrawLeftScreen;

  // await drawLeftScreen(time,false)
  // },(BC>0)? 500:150)

  // }

  // if(RC >0){
  // time = time + 40;
  // await drawBackScreen(time)
  // setTimeout(async()=>{
  time += 1000;

  let promiseDrawRightScreen = new Promise(async (resolve, reject) => {
    await drawRightScreen(500, false);
    setTimeout(() => resolve("done!"), 2000);
  });
  await promiseDrawRightScreen;
  // await drawRightScreen(time,false)
  // },(BC>0 || LC>0)? 1100:600)
  // }

  // if(FC >0){
  // time = time + 40;
  // await drawBackScreen(time)
  // setTimeout(async()=>{
  time += 1000;
  let promiseDrawFrontScreen = new Promise(async (resolve, reject) => {
    await drawFrontScreen(500, false);
    setTimeout(() => resolve("done!"), 2000);
  });
  await promiseDrawFrontScreen;
  // await drawFrontScreen(time,false)

  let all = new Promise(async (resolve, reject) => {
    if (is2D) {
      await to2D();
    }
    setTimeout(() => resolve("done!"), 2000);
  });
  await all;
  // },(BC>0 || LC>0 || RC > 0)? 2500:1200)
  // }
  // },15000)
};

window.screenShot3 = async () => {
  var time = 20;

  let promiseDrawFrontLeft = new Promise(async (resolve, reject) => {
    await drawFrontLeft(500, true);
    setTimeout(() => resolve("done!"), 2000);
  });
  await promiseDrawFrontLeft;

  let promiseDrawLeftBack = new Promise(async (resolve, reject) => {
    await drawLeftBack(500, true);
    setTimeout(() => resolve("done!"), 2000);
  });
  await promiseDrawLeftBack;

  let promiseDrawBackRight = new Promise(async (resolve, reject) => {
    await drawBackRight(500, true);
    setTimeout(() => resolve("done!"), 2000);
  });
  await promiseDrawBackRight;
  // await drawFrontLeft(time,true)
  // time+=1000;
  // await drawLeftBack(time,true)
  // time+=1000;

  // await drawBackRight(time,true)
};

async function drawBackScreen(time, wall) {
  setTimeout(async () => {
    if (is2D) {
      await to2D();
    }

    camera.position.set(0, measures.height / 2, 2);
    controls.target.set(0, measures.height / 2, 0);
    controls.enabled = false;

    controls.update();

    document.getElementById("myCanvas").style.cursor = "not-allowed";
    document.getElementById("myCanvas").style.pointerEvents = "none";

    planeFront.visible = false;
    planeLeft.visible = false;
    planeRight.visible = false;
    planeBottom.visible = false;
    planeTop.visible = false;

    // let condition = (wall)? (measuresZG.min + 0.1):0.1;
    var objNO = await changeScale(
      0,
      wall,
      measuresZG.min + 0.1,
      "positionZ",
      "z"
    );

    // console.log("Back objNO ", objNO);

    for (let index = 0; index < finishTops.length; index++) {
      finishTops[index].userData.oldValue = finishTops[index].scale.z;
      // if (degrees_to_radians(0) != finishTops[index].userData.rotationY)
      // {
      finishTops[index].visible = false;
      // }
      //   else
      // {
      //   if(wall){
      //     if(finishTops[index].position.z == measuresZG.min + 0.1){
      //       finishTops[index].scale.z = 0.0005;
      //     }else{
      //       finishTops[index].visible = false;

      //     }

      //   }else{
      //     if(finishTops[index].position.z != measuresZG.min + 0.1){
      //       finishTops[index].scale.z = 0.0005;
      //     }else{
      //       finishTops[index].visible = false;

      //     }
      //   }
      //   // finishTops[index].scale.z = 0.05;
      // }
    }

    if (objNO > 0) {
      const material = new LineBasicMaterial({ color: 0x0000ff });

      /// Essential texts
      const loaderr = new FontLoader();
      loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
        const color = new Color(0x00000);

        const matLite = new MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.6,
          side: DoubleSide,
        });

        const shapesTop = font.generateShapes(
          "" +
            Math.ceil((measuresXG.max - measuresXG.min - 0.2) * 1000) +
            " mm",
          150
        );
        const geometryTopBottom = new ShapeGeometry(shapesTop);
        geometryTopBottom.computeBoundingBox();
        geometryTopBottom.translate(
          -0.5 *
            (geometryTopBottom.boundingBox.max.x -
              geometryTopBottom.boundingBox.min.x),
          0,
          0
        );

        textBottom = new Mesh(geometryTopBottom, matLite);
        textBottom.position.set(0, -0.3, measuresZG.min + 0.8);
        textBottom.scale.set(0.0007, 0.0007, 0.0007);
        textBottom.rotation.x = degrees_to_radians(0);
        textBottom.userData.type = "Text";

        scene.add(textBottom);

        const shapesLeftRight = font.generateShapes(
          "" + Math.ceil(measures.height * 1000) + " mm",
          150
        );
        const geometryLeftRight = new ShapeGeometry(shapesLeftRight);
        geometryLeftRight.computeBoundingBox();
        geometryLeftRight.translate(
          -0.5 *
            (geometryLeftRight.boundingBox.max.x -
              geometryLeftRight.boundingBox.min.x),
          0,
          0
        );

        textLeft = new Mesh(geometryLeftRight, matLite);
        textLeft.scale.set(0.0007, 0.0007, 0.0007);
        textLeft.position.set(
          measuresXG.min - 0.8,
          measures.height / 2,
          measuresZG.min
        );

        textLeft.rotation.x = degrees_to_radians(0);
        textLeft.rotation.z = degrees_to_radians(90);
        textLeft.userData.type = "Text";

        scene.add(textLeft);

        render();
      }); //end essential texts

      let points = [];

      // Left Line
      while (points.length > 0) {
        points.pop();
      }

      points.push(new Vector3(measuresXG.min - 0.6, 0, measuresZG.min - 0.2));

      points.push(
        new Vector3(measuresXG.min - 0.6, measures.height, measuresZG.min - 0.2)
      );

      const geometryLeft = new BufferGeometry().setFromPoints(points);
      const lineLeft = new Line(geometryLeft, material);
      lineLeft.userData.type = "Line";

      scene.add(lineLeft);

      // Bottom Line
      while (points.length > 0) {
        points.pop();
      }

      points.push(new Vector3(measuresXG.min + 0.1, -0.6, measuresZG.min));

      points.push(new Vector3(+measuresXG.max - 0.1, -0.6, measuresZG.min));

      const geometryBottom = new BufferGeometry().setFromPoints(points);
      const lineBottom = new Line(geometryBottom, material);
      lineBottom.userData.type = "Line";

      scene.add(lineBottom);

      let distanceTop = 0.1;

      let positionsZBottomLines = [];
      let positionsXLeftLines = [];

      for (let index = 0; index < objects.length; index++) {
        if (
          objects[index].rotation.y == degrees_to_radians(0) &&
          ((wall && objects[index].position.z == measuresZG.min + 0.1) ||
            (!wall && objects[index].position.z != measuresZG.min + 0.1))
        ) {
          // Draw lines of objects

          let from = objects[index].position.x - objects[index].userData.W;
          if (objects[index].name == "B" || objects[index].name == "Element") {
            drawLine(
              from,
              measuresZG.min,
              objects[index].position.x,
              measuresZG.min,
              null,
              materialObjects,
              -0.2 - distanceTop
            );

            positionsZBottomLines.push({
              begin: from,
              width: objects[index].userData.W,
            });

            let loaderr = new FontLoader();
            loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
              const color = new Color(0x00000);

              const matLite = new MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6,
                side: DoubleSide,
              });
              let text = objects[index].userData.W;
              const shapesTop = font.generateShapes(
                "" + Math.ceil(text * 1000),
                150
              );
              const geometryTopBottom = new ShapeGeometry(shapesTop);
              geometryTopBottom.computeBoundingBox();
              geometryTopBottom.translate(
                -0.5 *
                  (geometryTopBottom.boundingBox.max.x -
                    geometryTopBottom.boundingBox.min.x),
                0,
                0
              );

              const textTop = new Mesh(geometryTopBottom, matLite);
              textTop.position.set(
                objects[index].position.x - objects[index].userData.W / 2,
                -0.4 - distanceTop,
                measuresZG.min
              );
              textTop.scale.set(0.0006, 0.0006, 0.0006);
              textTop.rotation.x = degrees_to_radians(0);
              // textTop.rotation.x = degrees_to_radians(270);
              // textTop.rotation.z = degrees_to_radians(90);
              textTop.userData.type = "Text";

              scene.add(textTop);

              render();
            });
          }
          // console.log("objects[index].position.y  " ,objects[index].position.y);
          positionsXLeftLines.push({
            begin: objects[index].position.y,
            width:
              objects[index].userData.H +
              (objects[index].position.y > 0.1 ? 0 : 0.1),
          });

          //end load function

          // positionsXLeftLines.push({
          //   begin: objects[index].position.y,
          //   width: objects[index].position.y + objects[index].userData.H,
          // });
          //  loaderr = new FontLoader();
          // loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
          //   const color = new Color(0x00000);

          //   const matLite = new MeshBasicMaterial({
          //     color: color,
          //     transparent: true,
          //     opacity: 0.6,
          //     side: DoubleSide,
          //   });
          //   let text = objects[index].position.y + objects[index].userData.H / 2;
          //   const shapesTop = font.generateShapes("" + Math.ceil(text * 1000), 100);
          //   const geometryTopBottom = new ShapeGeometry(shapesTop);
          //   geometryTopBottom.computeBoundingBox();
          //   geometryTopBottom.translate(
          //     -0.5 *
          //       (geometryTopBottom.boundingBox.max.x -
          //         geometryTopBottom.boundingBox.min.x),
          //     0,
          //     0
          //   );

          //   const textTop = new Mesh(geometryTopBottom, matLite);
          //   textTop.position.set(-measuresXG.max - 0.2 - distanceTop,  objects[index].position.y + (objects[index].userData.H / 2), z);
          //   textTop.scale.set(0.0006, 0.0006, 0.0006);
          //   textTop.rotation.x = degrees_to_radians(270);
          //   textTop.rotation.z = degrees_to_radians(90);
          //   textTop.userData.type = "Text";

          //   scene.add(textTop);
        }
      }

      positionsZBottomLines?.sort((a, b) => (a.begin > b.begin ? 1 : -1));
      positionsXLeftLines?.sort((a, b) => (a.begin > b.begin ? 1 : -1));

      for (let index = 0; index < positionsZBottomLines.length; index++) {
        var positions = [];

        if (index === 0) {
          drawLine(
            measuresXG.min + 0.1,
            measuresZG.min,
            positionsZBottomLines[index].begin,
            measuresZG.min,
            positions,
            materialRight,
            -0.2 - distanceTop
          );
          /// Write text
          let loaderr = new FontLoader();
          loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
            const color = new Color(0x00000);

            const matLite = new MeshBasicMaterial({
              color: color,
              transparent: true,
              opacity: 0.6,
              side: DoubleSide,
            });
            // console.log("positionsZBottomLines[index].begin    " , positionsZBottomLines[index].begin );
            // console.log("positionsZBottomLines[index].width    " , positionsZBottomLines[index].width );
            // console.log("measuresXG.min +0.1    " , measuresXG.min +0.1 );
            let text =
              positionsZBottomLines[index].begin - (measuresXG.min + 0.1);
            // console.log("text  , ",text);
            const shapesTop = font.generateShapes(
              "" + Math.ceil(text * 1000),
              150
            );
            const geometryTopBottom = new ShapeGeometry(shapesTop);
            geometryTopBottom.computeBoundingBox();
            geometryTopBottom.translate(
              -0.5 *
                (geometryTopBottom.boundingBox.max.x -
                  geometryTopBottom.boundingBox.min.x),
              0,
              0
            );

            const textTop = new Mesh(geometryTopBottom, matLite);
            textTop.position.set(
              (measuresXG.min + 0.1 + positionsZBottomLines[index].begin) / 2,
              -0.4 - distanceTop,
              measuresZG.min
            );
            textTop.scale.set(0.0006, 0.0006, 0.0006);
            textTop.rotation.x = degrees_to_radians(0);

            textTop.userData.type = "Text";

            scene.add(textTop);

            render();
          }); //end load function
        }
        let finishPoint = 0;
        if (index < positionsZBottomLines.length - 1) {
          finishPoint = positionsZBottomLines[index + 1].begin;
        } else {
          finishPoint = measuresXG.max - 0.1;
        }

        /// x1,z1,x2,z2,positions,material

        drawLine(
          positionsZBottomLines[index].begin +
            positionsZBottomLines[index].width,
          measuresZG.min,
          finishPoint,
          measuresZG.min,
          positions,
          materialRight,
          -0.2 - distanceTop
        );

        const text =
          finishPoint -
          (positionsZBottomLines[index].begin +
            positionsZBottomLines[index].width);

        if (text !== 0) {
          // writeText(text, x, y);
          let loaderr = new FontLoader();
          loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
            const color = new Color(0x00000);

            const matLite = new MeshBasicMaterial({
              color: color,
              transparent: true,
              opacity: 0.6,
              side: DoubleSide,
            });
            let text =
              finishPoint -
              (positionsZBottomLines[index].begin +
                positionsZBottomLines[index].width);
            const shapesTop = font.generateShapes(
              "" + Math.ceil(text * 1000),
              150
            );
            const geometryTopBottom = new ShapeGeometry(shapesTop);
            geometryTopBottom.computeBoundingBox();
            geometryTopBottom.translate(
              -0.5 *
                (geometryTopBottom.boundingBox.max.x -
                  geometryTopBottom.boundingBox.min.x),
              0,
              0
            );

            const textTop = new Mesh(geometryTopBottom, matLite);
            textTop.position.set(
              (positionsZBottomLines[index].begin +
                positionsZBottomLines[index].width +
                finishPoint) /
                2,
              -0.4 - distanceTop,
              measuresZG.min
            );
            textTop.scale.set(0.0006, 0.0006, 0.0006);
            textTop.rotation.x = degrees_to_radians(0);
            // textTop.rotation.x = degrees_to_radians(270);
            // textTop.rotation.z = degrees_to_radians(90);
            textTop.userData.type = "Text";

            scene.add(textTop);

            render();
          }); //end load function
        }

        // positions

        var geometry = new BufferGeometry();
        geometry.setAttribute(
          "position",
          new Float32BufferAttribute(positions, 3)
        );

        geometry.computeBoundingSphere();

        var materialPoints = new PointsMaterial({
          size: 0.04,
          vertexColors: new MeshPhongMaterial({ color: 0xff0000 }),
        });

        let points = new Points(geometry, materialPoints);
        points.name = "points";
        scene.add(points);
      }

      for (let index = 0; index < positionsXLeftLines.length; index++) {
        var positions = [];

        /// x1,z1,x2,z2,positions,material

        let xLeft = measuresXG.min - 0.2;
        let zLeft = measuresZG.min + 0.1;
        let yBegin = positionsXLeftLines[index].begin;
        let yEnd = positionsXLeftLines[index].width;

        let pointsLeft = [];

        pointsLeft.push(new Vector3(xLeft, yBegin, zLeft));
        pointsLeft.push(new Vector3(xLeft, yBegin + yEnd, zLeft));
        // console.log("points ", pointsLeft);

        if (positions) {
          positions.push(xLeft, yBegin, zLeft);
          positions.push(xLeft, yBegin + yEnd, zLeft);
        }
        // console.log("positionsXLeftLines  " , positionsXLeftLines);
        // if (index === 0) {
        //   // drawLine(
        //   //   measuresXG.min - 0.4,
        //   //   measuresZG.min,
        //   //   positionsXLeftLines[index].begin,
        //   //   measuresZG.min,
        //   //   positions,
        //   //   materialRight,
        //   //   -0.2 - distanceTop
        //   // );

        // let xLeft = measuresXG.min - 0.2;
        // let zLeft = measuresZG.min;
        // let yBegin = wallWidth*2;
        // let yEnd = positionsXLeftLines[index].begin;

        // let pointsLeft = [];

        // pointsLeft.push(new Vector3(xLeft, yBegin, zLeft));
        // pointsLeft.push(new Vector3(xLeft, yEnd, zLeft));
        // // console.log("points ", pointsLeft);

        // if (positions) {
        //   positions.push(xLeft, yBegin, zLeft);
        //   positions.push(xLeft, yEnd, zLeft);
        // }
        // const geometryFirst2 = new BufferGeometry().setFromPoints(
        //   pointsLeft
        // );
        // const lineFirst2 = new Line(geometryFirst2, materialRight);
        // lineFirst2.userData.type = "Line";
        // // scene.add(lineFirst2);

        //   /// Write text
        //   let loaderr = new FontLoader();
        //   loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
        //     const color = new Color(0x00000);

        //     const matLite = new MeshBasicMaterial({
        //       color: color,
        //       transparent: true,
        //       opacity: 0.6,
        //       side: DoubleSide,
        //     });

        //     let text = positionsXLeftLines[index].begin - wallWidth*2;
        //     const shapesTop = font.generateShapes(
        //       "" + Math.ceil(text * 1000),
        //       150
        //     );
        //     const geometryTopBottom = new ShapeGeometry(shapesTop);
        //     geometryTopBottom.computeBoundingBox();
        //     geometryTopBottom.translate(

        //       0,
        //       -0.5 *
        //       (geometryTopBottom.boundingBox.max.y -
        //         geometryTopBottom.boundingBox.min.y) ,0

        //     );

        //     const textTop = new Mesh(geometryTopBottom, matLite);
        //     textTop.position.set(
        //       measuresXG.min - 0.3,
        //       (measuresXG.min + positionsXLeftLines[index].begin) / 2,
        //       measuresZG.min
        //     );
        //     textTop.scale.set(0.0006, 0.0006, 0.0006);
        //     textTop.rotation.x = degrees_to_radians(0);
        //     textTop.rotation.y = degrees_to_radians(90);

        //     textTop.userData.type = "Text";

        //     scene.add(textTop);

        //     render();
        //   }); //end load function
        // }
        const geometryFirst2 = new BufferGeometry().setFromPoints(pointsLeft);
        const lineFirst2 = new Line(geometryFirst2, materialObjects);
        lineFirst2.userData.type = "Line";
        scene.add(lineFirst2);

        const text = positionsXLeftLines[index].width;

        if (text !== 0) {
          const z = measuresZG.min + 0.1;
          const x = measuresXG.min - 0.2 - distanceTop;

          writeText(
            text,
            x,
            z,
            "y+",
            positionsXLeftLines[index].begin +
              positionsXLeftLines[index].width / 2
          );
        }

        // positions

        var geometry = new BufferGeometry();
        geometry.setAttribute(
          "position",
          new Float32BufferAttribute(positions, 3)
        );

        geometry.computeBoundingSphere();

        var materialPoints = new PointsMaterial({
          size: 0.04,
          vertexColors: new MeshPhongMaterial({ color: 0xff0000 }),
        });

        let points = new Points(geometry, materialPoints);
        points.name = "points";
        scene.add(points);
      }
    }

    setTimeout(async () => {
      let c = document.getElementById("myCanvas");
      if (objNO > 0) {
        html2canvas(c).then(async (canvas) => {
          var t = canvas.toDataURL().replace("data:image/png;base64,", "");
          downloadBase64File("image/png", t, "image");

          // Delete lines
          await deleteLines();
          // camera.position.set(0, 5, 0.8);
          // controls.target.set(0, 0, 0.8);
          // // camera.position.set(0, measures.height/2, 2);
          // // controls.target.set(0, measures.height/2, 0);
          // controls.enabled = false;
          // // scene.background = new Color(0xeeeeee);
          // controls.update();
          // controls.enabled = false;
          // controls.update();
          // camera.position.set(0, 5, 0.8);
          // controls.target.set(0, 0, 0.8);
          // document.getElementById("myCanvas").style.cursor = "not-allowed";
          // document.getElementById("myCanvas").style.pointerEvents = "none";
          // cursor: ;
          // pointer-events: none;

          // dragControls.update();

          planeFront.visible = true;
          planeLeft.visible = true;
          planeRight.visible = true;
          planeBottom.visible = true;
          planeTop.visible = true;

          // backLight.visible = false;

          for (let index = 0; index < objects.length; index++) {
            if (objects[index].rotation.y != degrees_to_radians(0)) {
              objects[index].visible = true;
            } else {
              //   console.log('return old size z    ',objects[index].scale.z);
              // console.log('return    ',objects[index].userData.oldSizeZ);
              objects[index].scale.z = objects[index].userData.oldSizeZ;
              if (!wall && objects[index].userData.positionZScreen) {
                objects[index].position.z =
                  objects[index].userData.positionZScreen;
              }
            }
            scene.add(objects[index]);
          }

          for (let index = 0; index < leftCovers.length; index++) {
            // if (leftCovers[index].rotation.y != degrees_to_radians(0)) {
            leftCovers[index].visible = true;
            // } else {
            //   leftCovers[index].scale.z = 1;
            // }
          }
          for (let index = 0; index < rightCovers.length; index++) {
            // if (rightCovers[index].rotation.y != degrees_to_radians(0)) {
            rightCovers[index].visible = true;
            // } else {
            //   rightCovers[index].scale.z = 1;
            // }
          }
          for (let index = 0; index < backCovers.length; index++) {
            // if (backCovers[index].rotation.y != degrees_to_radians(0)) {
            backCovers[index].visible = true;
            // } else {
            //   backCovers[index].scale.z = 1;
            // }
          }
          for (let index = 0; index < wallPanels.length; index++) {
            // if (wallPanels[index].rotation.y != degrees_to_radians(0)) {
            wallPanels[index].visible = true;
            // } else {
            //   wallPanels[index].scale.z = 1;
            // }
          }
          // for (let index = 0; index < directions.length; index++) {
          //   // if (directions[index].rotation.y != degrees_to_radians(0)) {
          //     directions[index].visible = true;
          //   // } else {
          //   //   directions[index].scale.z = 1;
          //   // }
          // }
          // for (let index = 0; index < finishTops.length; index++) {

          //   if (degrees_to_radians(0) != finishTops[index].userData.rotationY) {
          //     finishTops[index].visible = true;
          //   } else {

          //     finishTops[index].scale.z = finishTops[index].userData.oldValue ;
          //   }
          // }

          for (let index = 0; index < Cornices.length; index++) {
            // if (Cornices[index].rotation.y != degrees_to_radians(0)) {
            Cornices[index].visible = true;
            // } else {
            //   Cornices[index].scale.z = 1;
            // }
          }
          for (let index = 0; index < decoStrips.length; index++) {
            // if (decoStrips[index].rotation.y != degrees_to_radians(0)) {
            decoStrips[index].visible = true;
            // } else {
            //   decoStrips[index].scale.z = 1;
            // }
          }
          for (let index = 0; index < sinks.length; index++) {
            // if (sinks[index].rotation.y != degrees_to_radians(0)) {
            sinks[index].visible = true;
            // } else {
            //   sinks[index].scale.z = 1;
            // }
          }
          for (let index = 0; index < ovens.length; index++) {
            // if (ovens[index].rotation.y != degrees_to_radians(0)) {
            ovens[index].visible = true;
            // } else {
            //   ovens[index].scale.z = 1;
            // }
          }

          for (let index = 0; index < fillers.length; index++) {
            // if (fillers[index].rotation.y != degrees_to_radians(0)) {
            fillers[index].visible = true;
            // } else {
            //   fillers[index].scale.z = 1;
            // }
          }

          // camera.position.set(3, 1, 9);
          // controls.target.set(0, 1, 0);
          // controls.enabled = true;
          // controls.update();

          await deleteLines();
        });
      }
      await to2D();
    }, time * 1.1);
  }, time);
}

async function drawLeftScreen(time, wall) {
  setTimeout(async () => {
    if (is2D) {
      await to2D();
    }

    await deleteLines();

    planeBack.visible = false;
    planeLeft.visible = true;
    planeFront.visible = false;
    planeRight.visible = false;
    planeBottom.visible = false;
    planeTop.visible = false;
    camera.position.set(2, measures.height / 2, 0);
    controls.target.set(0, measures.height / 2, 0);
    controls.enabled = false;

    controls.update();

    document.getElementById("myCanvas").style.cursor = "not-allowed";
    document.getElementById("myCanvas").style.pointerEvents = "none";

    var objNO = await changeScale(
      90,
      wall,
      measuresXG.min + 0.1,
      "positionX",
      "x"
    );

    // console.log("Left objNO ", objNO);

    for (let index = 0; index < finishTops.length; index++) {
      finishTops[index].userData.oldValue = finishTops[index].scale.x;

      // if (degrees_to_radians(90) != finishTops[index].userData.rotationY) {
      finishTops[index].visible = false;
      // } else {
      //   // finishTops[index].scale.x = 0.05;
      //   if(wall){
      //     if(finishTops[index].position.x == measuresXG.min + 0.1){
      //       finishTops[index].scale.x = 0.0005;
      //     }else{
      //       finishTops[index].visible = false;

      //     }

      //   }else{
      //     if(finishTops[index].position.x != measuresXG.min + 0.1){
      //       finishTops[index].scale.x = 0.0005;
      //     }else{
      //       finishTops[index].visible = false;

      //     }
      //   }
      // }
    }

    if (objNO > 0) {
      const material = new LineBasicMaterial({ color: 0x0000ff });

      /// Essential texts
      const loaderr = new FontLoader();
      loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
        const color = new Color(0x00000);

        const matLite = new MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.6,
          side: DoubleSide,
        });

        const shapesTop = font.generateShapes(
          "" +
            Math.ceil((measuresZG.max - measuresZG.min - 0.2) * 1000) +
            " mm",
          150
        );
        const geometryTopBottom = new ShapeGeometry(shapesTop);
        geometryTopBottom.computeBoundingBox();
        geometryTopBottom.translate(
          -0.5 *
            (geometryTopBottom.boundingBox.max.x -
              geometryTopBottom.boundingBox.min.x),
          0,
          0
        );

        textBottom = new Mesh(geometryTopBottom, matLite);
        textBottom.position.set(measuresXG.min, -0.9, 0);
        textBottom.scale.set(0.0007, 0.0007, 0.0007);
        textBottom.rotation.x = degrees_to_radians(-270);
        textBottom.rotation.y = degrees_to_radians(-225);
        textBottom.rotation.z = degrees_to_radians(-90);
        textBottom.userData.type = "Text";

        scene.add(textBottom);

        const shapesLeftRight = font.generateShapes(
          "" + Math.ceil(measures.height * 1000) + " mm",
          150
        );
        const geometryLeftRight = new ShapeGeometry(shapesLeftRight);
        geometryLeftRight.computeBoundingBox();
        geometryLeftRight.translate(
          0,
          0,
          -0.5 *
            (geometryLeftRight.boundingBox.max.z -
              geometryLeftRight.boundingBox.min.z)
        );

        textLeft = new Mesh(geometryLeftRight, matLite);
        textLeft.scale.set(0.0007, 0.0007, 0.0007);
        textLeft.position.set(
          measuresXG.min,
          measures.height / 2,
          measuresZG.max + 0.8
        );

        textLeft.rotation.x = degrees_to_radians(180);
        textLeft.rotation.z = degrees_to_radians(270);
        textLeft.rotation.y = degrees_to_radians(45);
        textLeft.userData.type = "Text";

        scene.add(textLeft);

        render();
      }); //end essential texts

      let points = [];

      // Left Line
      while (points.length > 0) {
        points.pop();
      }

      points.push(new Vector3(measuresXG.min - 0.2, 0, measuresZG.max + 0.6));

      points.push(
        new Vector3(measuresXG.min - 0.2, measures.height, measuresZG.max + 0.6)
      );

      const geometryLeft = new BufferGeometry().setFromPoints(points);
      const lineLeft = new Line(geometryLeft, material);
      lineLeft.userData.type = "Line";

      scene.add(lineLeft);

      // Bottom Line
      while (points.length > 0) {
        points.pop();
      }

      points.push(new Vector3(measuresXG.min, -0.6, measuresZG.min + 0.1));

      points.push(new Vector3(+measuresXG.min, -0.6, measuresZG.max - 0.1));

      const geometryBottom = new BufferGeometry().setFromPoints(points);
      const lineBottom = new Line(geometryBottom, material);
      lineBottom.userData.type = "Line";

      scene.add(lineBottom);

      let distanceTop = 0.1;

      let positionsZBottomLines = [];
      let positionsXLeftLines = [];

      for (let index = 0; index < objects.length; index++) {
        if (
          objects[index].rotation.y == degrees_to_radians(90) &&
          ((wall && objects[index].position.x == measuresXG.min + 0.1) ||
            (!wall && objects[index].position.x != measuresXG.min + 0.1))
        ) {
          // Draw lines of objects

          let from = objects[index].position.z;
          if (objects[index].name == "B" || objects[index].name == "Element") {
            drawLine(
              measuresXG.min,
              from,
              measuresXG.min,
              objects[index].position.z + objects[index].userData.W,
              null,
              materialObjects,
              -0.2 - distanceTop
            );

            positionsZBottomLines.push({
              begin: from,
              width: objects[index].userData.W,
            });

            let loaderr = new FontLoader();
            loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
              const color = new Color(0x00000);

              const matLite = new MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6,
                side: DoubleSide,
              });
              let text = objects[index].userData.W;
              const shapesTop = font.generateShapes(
                "" + Math.ceil(text * 1000),
                150
              );
              const geometryTopBottom = new ShapeGeometry(shapesTop);
              geometryTopBottom.computeBoundingBox();
              geometryTopBottom.translate(
                -0.5 *
                  (geometryTopBottom.boundingBox.max.x -
                    geometryTopBottom.boundingBox.min.x),
                0,
                0
              );

              const textTop = new Mesh(geometryTopBottom, matLite);
              textTop.position.set(
                measuresXG.min,
                -0.4 - distanceTop,
                objects[index].position.z + objects[index].userData.W / 2
              );
              textTop.scale.set(0.0006, 0.0006, 0.0006);
              textTop.rotation.x = degrees_to_radians(270);
              textTop.rotation.y = degrees_to_radians(90);
              // textTop.rotation.x = degrees_to_radians(270);
              textTop.rotation.z = degrees_to_radians(90);
              textTop.userData.type = "Text";

              scene.add(textTop);

              render();
            }); //end load function
            // console.log("objects[index].position.y  " ,objects[index].position.y);
          }
          positionsXLeftLines.push({
            begin: objects[index].position.y,
            width:
              objects[index].userData.H +
              (objects[index].position.y > 0.1 ? 0 : 0.1),
          });
          // positionsXLeftLines.push({
          //   begin: objects[index].position.y,
          //   width: objects[index].position.y + objects[index].userData.H,
          // });
          //  loaderr = new FontLoader();
          // loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
          //   const color = new Color(0x00000);

          //   const matLite = new MeshBasicMaterial({
          //     color: color,
          //     transparent: true,
          //     opacity: 0.6,
          //     side: DoubleSide,
          //   });
          //   let text = objects[index].position.y + objects[index].userData.H / 2;
          //   const shapesTop = font.generateShapes("" + Math.ceil(text * 1000), 100);
          //   const geometryTopBottom = new ShapeGeometry(shapesTop);
          //   geometryTopBottom.computeBoundingBox();
          //   geometryTopBottom.translate(
          //     -0.5 *
          //       (geometryTopBottom.boundingBox.max.x -
          //         geometryTopBottom.boundingBox.min.x),
          //     0,
          //     0
          //   );

          //   const textTop = new Mesh(geometryTopBottom, matLite);
          //   textTop.position.set(-measuresXG.max - 0.2 - distanceTop,  objects[index].position.y + (objects[index].userData.H / 2), z);
          //   textTop.scale.set(0.0006, 0.0006, 0.0006);
          //   textTop.rotation.x = degrees_to_radians(270);
          //   textTop.rotation.z = degrees_to_radians(90);
          //   textTop.userData.type = "Text";

          //   scene.add(textTop);
        }
      }

      positionsZBottomLines?.sort((a, b) => (a.begin > b.begin ? 1 : -1));
      positionsXLeftLines?.sort((a, b) => (a.begin > b.begin ? 1 : -1));

      for (let index = 0; index < positionsZBottomLines.length; index++) {
        var positions = [];

        if (index === 0) {
          drawLine(
            measuresXG.min,
            measuresZG.min + 0.1,
            measuresXG.min,
            positionsZBottomLines[index].begin,
            positions,
            materialRight,
            -0.2 - distanceTop
          );
          /// Write text
          let loaderr = new FontLoader();
          loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
            const color = new Color(0x00000);

            const matLite = new MeshBasicMaterial({
              color: color,
              transparent: true,
              opacity: 0.6,
              side: DoubleSide,
            });

            let text =
              -1 * (measuresZG.min + 0.1 - positionsZBottomLines[index].begin);

            const shapesTop = font.generateShapes(
              "" + Math.ceil(text * 1000),
              150
            );
            const geometryTopBottom = new ShapeGeometry(shapesTop);
            geometryTopBottom.computeBoundingBox();
            geometryTopBottom.translate(
              -0.5 *
                (geometryTopBottom.boundingBox.max.x -
                  geometryTopBottom.boundingBox.min.x),
              0,
              0
            );

            const textTop = new Mesh(geometryTopBottom, matLite);
            textTop.position.set(
              measuresXG.min,
              -0.4 - distanceTop,
              (measuresZG.min + 0.1 + positionsZBottomLines[index].begin) / 2
            );
            textTop.scale.set(0.0006, 0.0006, 0.0006);
            textTop.rotation.x = degrees_to_radians(90);
            textTop.rotation.z = degrees_to_radians(270);
            textTop.rotation.y = degrees_to_radians(90);

            textTop.userData.type = "Text";

            scene.add(textTop);

            render();
          }); //end load function
        }
        let finishPoint = 0;
        if (index < positionsZBottomLines.length - 1) {
          finishPoint = positionsZBottomLines[index + 1].begin;
        } else {
          finishPoint = measuresZG.max - 0.1;
        }

        /// x1,z1,x2,z2,positions,material

        drawLine(
          measuresXG.min,
          positionsZBottomLines[index].begin +
            positionsZBottomLines[index].width,
          measuresXG.min,
          finishPoint,
          positions,
          materialRight,
          -0.2 - distanceTop
        );

        const text =
          finishPoint -
          (positionsZBottomLines[index].begin +
            positionsZBottomLines[index].width);

        if (text !== 0) {
          // writeText(text, x, y);
          let loaderr = new FontLoader();
          loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
            const color = new Color(0x00000);

            const matLite = new MeshBasicMaterial({
              color: color,
              transparent: true,
              opacity: 0.6,
              side: DoubleSide,
            });
            let text =
              finishPoint -
              (positionsZBottomLines[index].begin +
                positionsZBottomLines[index].width);
            const shapesTop = font.generateShapes(
              "" + Math.ceil(text * 1000),
              150
            );
            const geometryTopBottom = new ShapeGeometry(shapesTop);
            geometryTopBottom.computeBoundingBox();
            geometryTopBottom.translate(
              -0.5 *
                (geometryTopBottom.boundingBox.max.x -
                  geometryTopBottom.boundingBox.min.x),
              0,
              0
            );

            const textTop = new Mesh(geometryTopBottom, matLite);
            textTop.position.set(
              measuresZG.min,
              -0.4 - distanceTop,
              (positionsZBottomLines[index].begin +
                positionsZBottomLines[index].width +
                finishPoint) /
                2
            );
            textTop.scale.set(0.0006, 0.0006, 0.0006);
            textTop.rotation.x = degrees_to_radians(90);
            textTop.rotation.z = degrees_to_radians(270);
            textTop.rotation.y = degrees_to_radians(90);
            textTop.userData.type = "Text";

            scene.add(textTop);

            render();
          }); //end load function
        }

        // positions

        var geometry = new BufferGeometry();
        geometry.setAttribute(
          "position",
          new Float32BufferAttribute(positions, 3)
        );

        geometry.computeBoundingSphere();

        var materialPoints = new PointsMaterial({
          size: 0.04,
          vertexColors: new MeshPhongMaterial({ color: 0xff0000 }),
        });

        let points = new Points(geometry, materialPoints);
        points.name = "points";
        scene.add(points);
      }
      for (let index = 0; index < positionsXLeftLines.length; index++) {
        var positions = [];

        /// x1,z1,x2,z2,positions,material

        let xLeft = measuresXG.min + 0.1;
        let zLeft = measuresZG.max + 0.1;
        let yBegin = positionsXLeftLines[index].begin;
        let yEnd = positionsXLeftLines[index].width;

        let pointsLeft = [];

        pointsLeft.push(new Vector3(xLeft, yBegin, zLeft));
        pointsLeft.push(new Vector3(xLeft, yBegin + yEnd, zLeft));
        // console.log("points ", pointsLeft);

        if (positions) {
          positions.push(xLeft, yBegin, zLeft);
          positions.push(xLeft, yBegin + yEnd, zLeft);
        }
        // console.log("positionsXLeftLines  " , positionsXLeftLines);
        // if (index === 0) {
        //   // drawLine(
        //   //   measuresXG.min - 0.4,
        //   //   measuresZG.min,
        //   //   positionsXLeftLines[index].begin,
        //   //   measuresZG.min,
        //   //   positions,
        //   //   materialRight,
        //   //   -0.2 - distanceTop
        //   // );

        // let xLeft = measuresXG.min - 0.2;
        // let zLeft = measuresZG.min;
        // let yBegin = wallWidth*2;
        // let yEnd = positionsXLeftLines[index].begin;

        // let pointsLeft = [];

        // pointsLeft.push(new Vector3(xLeft, yBegin, zLeft));
        // pointsLeft.push(new Vector3(xLeft, yEnd, zLeft));
        // // console.log("points ", pointsLeft);

        // if (positions) {
        //   positions.push(xLeft, yBegin, zLeft);
        //   positions.push(xLeft, yEnd, zLeft);
        // }
        // const geometryFirst2 = new BufferGeometry().setFromPoints(
        //   pointsLeft
        // );
        // const lineFirst2 = new Line(geometryFirst2, materialRight);
        // lineFirst2.userData.type = "Line";
        // // scene.add(lineFirst2);

        //   /// Write text
        //   let loaderr = new FontLoader();
        //   loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
        //     const color = new Color(0x00000);

        //     const matLite = new MeshBasicMaterial({
        //       color: color,
        //       transparent: true,
        //       opacity: 0.6,
        //       side: DoubleSide,
        //     });

        //     let text = positionsXLeftLines[index].begin - wallWidth*2;
        //     const shapesTop = font.generateShapes(
        //       "" + Math.ceil(text * 1000),
        //       150
        //     );
        //     const geometryTopBottom = new ShapeGeometry(shapesTop);
        //     geometryTopBottom.computeBoundingBox();
        //     geometryTopBottom.translate(

        //       0,
        //       -0.5 *
        //       (geometryTopBottom.boundingBox.max.y -
        //         geometryTopBottom.boundingBox.min.y) ,0

        //     );

        //     const textTop = new Mesh(geometryTopBottom, matLite);
        //     textTop.position.set(
        //       measuresXG.min - 0.3,
        //       (measuresXG.min + positionsXLeftLines[index].begin) / 2,
        //       measuresZG.min
        //     );
        //     textTop.scale.set(0.0006, 0.0006, 0.0006);
        //     textTop.rotation.x = degrees_to_radians(0);
        //     textTop.rotation.y = degrees_to_radians(90);

        //     textTop.userData.type = "Text";

        //     scene.add(textTop);

        //     render();
        //   }); //end load function
        // }
        const geometryFirst2 = new BufferGeometry().setFromPoints(pointsLeft);

        const lineFirst2 = new Line(geometryFirst2, materialObjects);
        lineFirst2.userData.type = "Line";
        scene.add(lineFirst2);

        const text = positionsXLeftLines[index].width;

        if (text !== 0) {
          // const z = measuresZG.max + 0.2 + distanceTop ;
          const x = measuresXG.min;
          // Side
          let loaderr = new FontLoader();

          loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
            const color = new Color(0x00000);

            const matLite = new MeshBasicMaterial({
              color: color,
              transparent: true,
              opacity: 0.6,
              side: DoubleSide,
            });

            // let text = positionsXLeftLines[index].begin - wallWidth*2;
            const shapesTop = font.generateShapes(
              "" + Math.ceil(text * 1000),
              150
            );
            const geometryTopBottom = new ShapeGeometry(shapesTop);
            geometryTopBottom.computeBoundingBox();
            geometryTopBottom.translate(
              0,
              -0.5 *
                (geometryTopBottom.boundingBox.max.y -
                  geometryTopBottom.boundingBox.min.y),
              0
            );

            const textTop = new Mesh(geometryTopBottom, matLite);
            textTop.position.set(
              x,
              positionsXLeftLines[index].begin +
                positionsXLeftLines[index].width / 2,
              measuresZG.max + 0.3
            );
            textTop.scale.set(0.0006, 0.0006, 0.0006);
            textTop.rotation.x = degrees_to_radians(90);
            textTop.rotation.y = degrees_to_radians(90);

            textTop.userData.type = "Text";

            scene.add(textTop);

            render();
          }); //end load function
        }

        // positions

        var geometry = new BufferGeometry();
        geometry.setAttribute(
          "position",
          new Float32BufferAttribute(positions, 3)
        );

        geometry.computeBoundingSphere();

        var materialPoints = new PointsMaterial({
          size: 0.04,
          vertexColors: new MeshPhongMaterial({ color: 0xff0000 }),
        });

        let points = new Points(geometry, materialPoints);
        points.name = "points";
        scene.add(points);
      }
    }
    setTimeout(async () => {
      let c = document.getElementById("myCanvas");
      if (objNO > 0) {
        html2canvas(c).then(async (canvas) => {
          var t = canvas.toDataURL().replace("data:image/png;base64,", "");
          downloadBase64File("image/png", t, "image");

          // Delete lines

          // backLight.visible = false;

          for (let index = 0; index < objects.length; index++) {
            if (objects[index].rotation.y != degrees_to_radians(90)) {
              objects[index].visible = true;
            } else {
              // objects[index].scale.z = 1;
              objects[index].scale.z = objects[index].userData.oldSizeZ;
              if (!wall && objects[index].userData.positionXScreen) {
                objects[index].position.x =
                  objects[index].userData.positionXScreen;
              }
            }
            scene.add(objects[index]);
          }

          for (let index = 0; index < leftCovers.length; index++) {
            // if (leftCovers[index].rotation.y != degrees_to_radians(90)) {
            leftCovers[index].visible = true;
            // } else {
            //   leftCovers[index].scale.z = 1;
            // }
          }
          for (let index = 0; index < rightCovers.length; index++) {
            // if (rightCovers[index].rotation.y != degrees_to_radians(90)) {
            rightCovers[index].visible = true;
            // } else {
            //   rightCovers[index].scale.z = 1;
            // }
          }
          for (let index = 0; index < backCovers.length; index++) {
            // if (backCovers[index].rotation.y != degrees_to_radians(90)) {
            backCovers[index].visible = true;
            // } else {
            //   backCovers[index].scale.z = 1;
            // }
          }
          for (let index = 0; index < wallPanels.length; index++) {
            // if (wallPanels[index].rotation.y != degrees_to_radians(90)) {
            wallPanels[index].visible = true;
            // } else {
            //   wallPanels[index].scale.z = 1;
            // }
          }
          // for (let index = 0; index < directions.length; index++) {
          //   if (directions[index].rotation.y != degrees_to_radians(90)) {
          //     directions[index].visible = true;
          //   } else {
          //     directions[index].scale.z = 1;
          //   }
          // }
          // for (let index = 0; index < finishTops.length; index++) {

          //   if (degrees_to_radians(90) != finishTops[index].userData.rotationY) {
          //     finishTops[index].visible = true;
          //   } else {
          //     finishTops[index].scale.x = finishTops[index].userData.oldValue ;
          //   }
          // }

          for (let index = 0; index < Cornices.length; index++) {
            // if (Cornices[index].rotation.y != degrees_to_radians(90)) {
            Cornices[index].visible = true;
            // } else {
            //   Cornices[index].scale.z = 1;
            // }
          }
          for (let index = 0; index < decoStrips.length; index++) {
            // if (decoStrips[index].rotation.y != degrees_to_radians(90)) {
            decoStrips[index].visible = true;
            // } else {
            //   decoStrips[index].scale.z = 1;
            // }
          }
          for (let index = 0; index < sinks.length; index++) {
            // if (sinks[index].rotation.y != degrees_to_radians(90)) {
            sinks[index].visible = true;
            // } else {
            //   sinks[index].scale.z = 1;
            // }
          }
          for (let index = 0; index < ovens.length; index++) {
            // if (ovens[index].rotation.y != degrees_to_radians(90)) {
            ovens[index].visible = true;
            // } else {
            //   ovens[index].scale.z = 1;
            // }
          }

          for (let index = 0; index < fillers.length; index++) {
            // if (fillers[index].rotation.y != degrees_to_radians(90)) {
            fillers[index].visible = true;
            // } else {
            //   fillers[index].scale.z = 1;
            // }
          }
          // camera.position.set(3, 1, 9);
          // controls.target.set(0, 1, 0);
          // controls.enabled = true;
          // controls.update();

          planeFront.visible = true;
          planeBack.visible = true;
          planeRight.visible = true;
          planeBottom.visible = true;
          planeTop.visible = true;

          await deleteLines();
        });
      }
      await to2D();
    }, time * 1.1);
  }, time);

  //  (BC > 0)?160:120
}

async function drawRightScreen(time, wall) {
  setTimeout(async () => {
    if (is2D) {
      await to2D();
      // await to2D();
    }
    // if(is2D){
    //   await to2D();
    //  }
    await deleteLines();
    // camera.position.set(0, 5, 0.8);
    // controls.target.set(0, 0, 0.8);
    planeBack.visible = false;
    planeLeft.visible = false;
    planeFront.visible = false;
    planeRight.visible = true;
    planeBottom.visible = false;
    planeTop.visible = false;

    camera.position.set(-2, measures.height / 2, 0);
    controls.target.set(0, measures.height / 2, 0);
    controls.enabled = false;

    controls.update();

    document.getElementById("myCanvas").style.cursor = "not-allowed";
    document.getElementById("myCanvas").style.pointerEvents = "none";

    // backLight.visible = false;

    var objNO = await changeScale(
      -90,
      wall,
      measuresXG.max - 0.1,
      "positionX",
      "x"
    );
    // for (let index = 0; index < objects.length; index++) {
    //   if (objects[index].rotation.y != degrees_to_radians(-90)) {
    //     objects[index].visible = false;
    //   } else {
    //     objects[index].scale.z = 0.1;
    //   }
    //   // scene.add(objects[index]);
    // }

    // console.log("Right objNO ", objNO);

    // console.log("Heeree    ");
    for (let index = 0; index < finishTops.length; index++) {
      finishTops[index].userData.oldValue = finishTops[index].scale.x;
      //  console.log("finishTops[index].userData.rotationY    ",finishTops[index].userData.rotationY);
      // if (degrees_to_radians(-90) != finishTops[index].userData.rotationY) {
      finishTops[index].visible = false;
      // } else {
      //   // finishTops[index].scale.x = 0.05;
      //   if(wall){
      //     if(finishTops[index].position.x == measuresXG.max - 0.1){
      //       finishTops[index].scale.x = 0.0005;
      //     }else{
      //       finishTops[index].visible = false;

      //     }

      //   }else{
      //     if(finishTops[index].position.x != measuresXG.max - 0.1){
      //       finishTops[index].scale.x = 0.0005;
      //     }else{
      //       finishTops[index].visible = false;

      //     }
      //   }
      // }
    }

    if (objNO > 0) {
      const material = new LineBasicMaterial({ color: 0x0000ff });

      /// Essential texts
      const loaderr = new FontLoader();
      loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
        const color = new Color(0x00000);

        const matLite = new MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.6,
          side: DoubleSide,
        });

        const shapesTop = font.generateShapes(
          "" +
            Math.ceil((measuresZG.max - measuresZG.min - 0.2) * 1000) +
            " mm",
          150
        );
        const geometryTopBottom = new ShapeGeometry(shapesTop);
        geometryTopBottom.computeBoundingBox();
        geometryTopBottom.translate(
          -0.5 *
            (geometryTopBottom.boundingBox.max.x -
              geometryTopBottom.boundingBox.min.x),
          0,
          0
        );

        textBottom = new Mesh(geometryTopBottom, matLite);
        textBottom.position.set(measuresXG.max, -0.9, 0);
        textBottom.scale.set(0.0007, 0.0007, 0.0007);
        textBottom.rotation.x = degrees_to_radians(-270);
        textBottom.rotation.y = degrees_to_radians(-135);
        textBottom.rotation.z = degrees_to_radians(+90);
        textBottom.userData.type = "Text";

        scene.add(textBottom);

        const shapesLeftRight = font.generateShapes(
          "" + Math.ceil(measures.height * 1000) + " mm",
          150
        );
        const geometryLeftRight = new ShapeGeometry(shapesLeftRight);
        geometryLeftRight.computeBoundingBox();
        geometryLeftRight.translate(
          0,
          0,
          -0.5 *
            (geometryLeftRight.boundingBox.max.z -
              geometryLeftRight.boundingBox.min.z)
        );

        textLeft = new Mesh(geometryLeftRight, matLite);
        textLeft.scale.set(0.0007, 0.0007, 0.0007);
        textLeft.position.set(
          measuresXG.max,
          measures.height / 2,
          measuresZG.min - 0.8
        );

        textLeft.rotation.x = degrees_to_radians(180);
        textLeft.rotation.z = degrees_to_radians(270);
        textLeft.rotation.y = degrees_to_radians(270);
        textLeft.userData.type = "Text";

        scene.add(textLeft);

        render();
      }); //end essential texts

      let points = [];

      // Left Line
      while (points.length > 0) {
        points.pop();
      }

      points.push(new Vector3(measuresXG.max + 0.2, 0, measuresZG.min - 0.6));

      points.push(
        new Vector3(measuresXG.max + 0.2, measures.height, measuresZG.min - 0.6)
      );

      const geometryLeft = new BufferGeometry().setFromPoints(points);
      const lineLeft = new Line(geometryLeft, material);
      lineLeft.userData.type = "Line";

      scene.add(lineLeft);

      // Bottom Line
      while (points.length > 0) {
        points.pop();
      }

      points.push(new Vector3(measuresXG.max, -0.6, measuresZG.min + 0.1));

      points.push(new Vector3(+measuresXG.max, -0.6, measuresZG.max - 0.1));

      const geometryBottom = new BufferGeometry().setFromPoints(points);
      const lineBottom = new Line(geometryBottom, material);
      lineBottom.userData.type = "Line";

      scene.add(lineBottom);

      let distanceTop = 0.1;

      let positionsZBottomLines = [];
      let positionsXLeftLines = [];

      for (let index = 0; index < objects.length; index++) {
        if (
          objects[index].rotation.y == degrees_to_radians(-90) &&
          ((wall && objects[index].position.x == measuresXG.max - 0.1) ||
            (!wall && objects[index].position.x != measuresXG.max - 0.1))
        ) {
          // Draw lines of objects

          let from = objects[index].position.z;
          // console.log("from   " , objects[index].position.z);
          // console.log("from   " , from);
          // console.log("to   " , objects[index].position.z + objects[index].userData.W);
          if (objects[index].name == "B" || objects[index].name == "Element") {
            drawLine(
              measuresXG.max,
              objects[index].position.z - objects[index].userData.W,
              measuresXG.max,
              from,
              null,
              materialObjects,
              -0.2 - distanceTop
            );

            // let points = [];

            // // Left Line
            // while (points.length > 0) {
            //   points.pop();
            // }

            // points.push(new Vector3(measuresXG.min - 0.6, 0, measuresZG.min));

            // points.push(
            //   new Vector3(measuresXG.min - 0.6, measures.height, measuresZG.min)
            // );

            // const geometryLeft = new BufferGeometry().setFromPoints(points);
            // const lineLeft = new Line(geometryLeft, material);
            // lineLeft.userData.type = "Line";

            // scene.add(lineLeft);

            positionsZBottomLines.push({
              begin: objects[index].position.z - objects[index].userData.W,
              width: objects[index].userData.W,
            });
            let loaderr = new FontLoader();
            loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
              const color = new Color(0x00000);

              const matLite = new MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6,
                side: DoubleSide,
              });
              let text = objects[index].userData.W;
              const shapesTop = font.generateShapes(
                "" + Math.ceil(text * 1000),
                150
              );
              const geometryTopBottom = new ShapeGeometry(shapesTop);
              geometryTopBottom.computeBoundingBox();
              geometryTopBottom.translate(
                -0.5 *
                  (geometryTopBottom.boundingBox.max.x -
                    geometryTopBottom.boundingBox.min.x),
                0,
                0
              );

              const textTop = new Mesh(geometryTopBottom, matLite);
              textTop.position.set(
                measuresXG.max,
                -0.4 - distanceTop,
                objects[index].position.z - objects[index].userData.W / 2
              );
              textTop.scale.set(0.0006, 0.0006, 0.0006);
              textTop.rotation.x = degrees_to_radians(270);
              textTop.rotation.y = degrees_to_radians(270);
              // textTop.rotation.x = degrees_to_radians(270);
              textTop.rotation.z = degrees_to_radians(270);
              textTop.userData.type = "Text";

              scene.add(textTop);

              render();
            }); //end load function
          }
          // console.log("objects[index].position.y  " ,objects[index].position.y);
          positionsXLeftLines.push({
            begin: objects[index].position.y,
            width:
              objects[index].userData.H +
              (objects[index].position.y > 0.1 ? 0 : 0.1),
          });

          // positionsXLeftLines.push({
          //   begin: objects[index].position.y,
          //   width: objects[index].position.y + objects[index].userData.H,
          // });
          //  loaderr = new FontLoader();
          // loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
          //   const color = new Color(0x00000);

          //   const matLite = new MeshBasicMaterial({
          //     color: color,
          //     transparent: true,
          //     opacity: 0.6,
          //     side: DoubleSide,
          //   });
          //   let text = objects[index].position.y + objects[index].userData.H / 2;
          //   const shapesTop = font.generateShapes("" + Math.ceil(text * 1000), 100);
          //   const geometryTopBottom = new ShapeGeometry(shapesTop);
          //   geometryTopBottom.computeBoundingBox();
          //   geometryTopBottom.translate(
          //     -0.5 *
          //       (geometryTopBottom.boundingBox.max.x -
          //         geometryTopBottom.boundingBox.min.x),
          //     0,
          //     0
          //   );

          //   const textTop = new Mesh(geometryTopBottom, matLite);
          //   textTop.position.set(-measuresXG.max - 0.2 - distanceTop,  objects[index].position.y + (objects[index].userData.H / 2), z);
          //   textTop.scale.set(0.0006, 0.0006, 0.0006);
          //   textTop.rotation.x = degrees_to_radians(270);
          //   textTop.rotation.z = degrees_to_radians(90);
          //   textTop.userData.type = "Text";

          //   scene.add(textTop);
        }
      }

      positionsZBottomLines?.sort((a, b) => (a.begin > b.begin ? 1 : -1));
      positionsXLeftLines?.sort((a, b) => (a.begin > b.begin ? 1 : -1));

      for (let index = 0; index < positionsZBottomLines.length; index++) {
        var positions = [];

        if (index === 0) {
          drawLine(
            measuresXG.max,
            measuresZG.min + 0.1,
            measuresXG.max,
            positionsZBottomLines[index].begin,
            positions,
            materialRight,
            -0.2 - distanceTop
          );
          /// Write text
          let loaderr = new FontLoader();
          loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
            const color = new Color(0x00000);

            const matLite = new MeshBasicMaterial({
              color: color,
              transparent: true,
              opacity: 0.6,
              side: DoubleSide,
            });
            // console.log("positionsZBottomLines[index].begin  ", positionsZBottomLines[index].begin);
            // console.log("measuresXG.max  ", measuresXG.max);

            let text =
              -1 * (measuresZG.min + 0.1 - positionsZBottomLines[index].begin);
            // console.log("text  ", text);
            // let text = positionsZBottomLines[index].begin + measuresXG.max - 0.1;
            const shapesTop = font.generateShapes(
              "" + Math.ceil(text * 1000),
              150
            );
            const geometryTopBottom = new ShapeGeometry(shapesTop);
            geometryTopBottom.computeBoundingBox();
            geometryTopBottom.translate(
              -0.5 *
                (geometryTopBottom.boundingBox.max.x -
                  geometryTopBottom.boundingBox.min.x),
              0,
              0
            );

            const textTop = new Mesh(geometryTopBottom, matLite);
            textTop.position.set(
              measuresXG.max,
              -0.4 - distanceTop,
              (measuresZG.min + 0.1 + positionsZBottomLines[index].begin) / 2
            );
            textTop.scale.set(0.0006, 0.0006, 0.0006);
            textTop.rotation.x = degrees_to_radians(90);
            textTop.rotation.z = degrees_to_radians(90);
            textTop.rotation.y = degrees_to_radians(270);

            textTop.userData.type = "Text";

            scene.add(textTop);

            render();
          }); //end load function
        }
        let finishPoint = 0;
        if (index < positionsZBottomLines.length - 1) {
          finishPoint = positionsZBottomLines[index + 1].begin;
        } else {
          finishPoint = measuresZG.max - 0.1;
        }

        /// x1,z1,x2,z2,positions,material

        drawLine(
          measuresXG.max,
          positionsZBottomLines[index].begin +
            positionsZBottomLines[index].width,
          measuresXG.max,
          finishPoint,
          positions,
          materialRight,
          -0.2 - distanceTop
        );

        const text =
          finishPoint -
          (positionsZBottomLines[index].begin +
            positionsZBottomLines[index].width);

        if (text !== 0) {
          // writeText(text, x, y);
          let loaderr = new FontLoader();
          loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
            const color = new Color(0x00000);

            const matLite = new MeshBasicMaterial({
              color: color,
              transparent: true,
              opacity: 0.6,
              side: DoubleSide,
            });
            let text =
              finishPoint -
              (positionsZBottomLines[index].begin +
                positionsZBottomLines[index].width);
            const shapesTop = font.generateShapes(
              "" + Math.ceil(text * 1000),
              150
            );
            const geometryTopBottom = new ShapeGeometry(shapesTop);
            geometryTopBottom.computeBoundingBox();
            geometryTopBottom.translate(
              -0.5 *
                (geometryTopBottom.boundingBox.max.x -
                  geometryTopBottom.boundingBox.min.x),
              0,
              0
            );
            // textTop.position.set(measuresZG.min,
            //   -0.4 - distanceTop, (positionsZBottomLines[index].begin + positionsZBottomLines[index].width +finishPoint) /2
            // );
            const textTop = new Mesh(geometryTopBottom, matLite);
            textTop.position.set(
              measuresZG.max,
              -0.4 - distanceTop,
              (positionsZBottomLines[index].begin +
                positionsZBottomLines[index].width +
                finishPoint) /
                2
            );
            textTop.scale.set(0.0006, 0.0006, 0.0006);
            textTop.rotation.x = degrees_to_radians(90);
            textTop.rotation.z = degrees_to_radians(90);
            textTop.rotation.y = degrees_to_radians(270);
            textTop.userData.type = "Text";

            scene.add(textTop);

            render();
          }); //end load function
        }

        // positions

        var geometry = new BufferGeometry();
        geometry.setAttribute(
          "position",
          new Float32BufferAttribute(positions, 3)
        );

        geometry.computeBoundingSphere();

        var materialPoints = new PointsMaterial({
          size: 0.04,
          vertexColors: new MeshPhongMaterial({ color: 0xff0000 }),
        });

        let points = new Points(geometry, materialPoints);
        points.name = "points";
        scene.add(points);
      }
      for (let index = 0; index < positionsXLeftLines.length; index++) {
        var positions = [];

        /// x1,z1,x2,z2,positions,material

        let xLeft = measuresXG.max;
        let zLeft = measuresZG.min - 0.2;
        let yBegin = positionsXLeftLines[index].begin;
        let yEnd = positionsXLeftLines[index].width;

        let pointsLeft = [];

        pointsLeft.push(new Vector3(xLeft, yBegin, zLeft));
        pointsLeft.push(new Vector3(xLeft, yBegin + yEnd, zLeft));
        // console.log("points ", pointsLeft);

        if (positions) {
          positions.push(xLeft, yBegin, zLeft);
          positions.push(xLeft, yBegin + yEnd, zLeft);
        }
        // console.log("positionsXLeftLines  " , positionsXLeftLines);
        // if (index === 0) {
        //   // drawLine(
        //   //   measuresXG.min - 0.4,
        //   //   measuresZG.min,
        //   //   positionsXLeftLines[index].begin,
        //   //   measuresZG.min,
        //   //   positions,
        //   //   materialRight,
        //   //   -0.2 - distanceTop
        //   // );

        // let xLeft = measuresXG.min - 0.2;
        // let zLeft = measuresZG.min;
        // let yBegin = wallWidth*2;
        // let yEnd = positionsXLeftLines[index].begin;

        // let pointsLeft = [];

        // pointsLeft.push(new Vector3(xLeft, yBegin, zLeft));
        // pointsLeft.push(new Vector3(xLeft, yEnd, zLeft));
        // // console.log("points ", pointsLeft);

        // if (positions) {
        //   positions.push(xLeft, yBegin, zLeft);
        //   positions.push(xLeft, yEnd, zLeft);
        // }
        // const geometryFirst2 = new BufferGeometry().setFromPoints(
        //   pointsLeft
        // );
        // const lineFirst2 = new Line(geometryFirst2, materialRight);
        // lineFirst2.userData.type = "Line";
        // // scene.add(lineFirst2);

        //   /// Write text
        //   let loaderr = new FontLoader();
        //   loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
        //     const color = new Color(0x00000);

        //     const matLite = new MeshBasicMaterial({
        //       color: color,
        //       transparent: true,
        //       opacity: 0.6,
        //       side: DoubleSide,
        //     });

        //     let text = positionsXLeftLines[index].begin - wallWidth*2;
        //     const shapesTop = font.generateShapes(
        //       "" + Math.ceil(text * 1000),
        //       150
        //     );
        //     const geometryTopBottom = new ShapeGeometry(shapesTop);
        //     geometryTopBottom.computeBoundingBox();
        //     geometryTopBottom.translate(

        //       0,
        //       -0.5 *
        //       (geometryTopBottom.boundingBox.max.y -
        //         geometryTopBottom.boundingBox.min.y) ,0

        //     );

        //     const textTop = new Mesh(geometryTopBottom, matLite);
        //     textTop.position.set(
        //       measuresXG.min - 0.3,
        //       (measuresXG.min + positionsXLeftLines[index].begin) / 2,
        //       measuresZG.min
        //     );
        //     textTop.scale.set(0.0006, 0.0006, 0.0006);
        //     textTop.rotation.x = degrees_to_radians(0);
        //     textTop.rotation.y = degrees_to_radians(90);

        //     textTop.userData.type = "Text";

        //     scene.add(textTop);

        //     render();
        //   }); //end load function
        // }
        const geometryFirst2 = new BufferGeometry().setFromPoints(pointsLeft);

        const lineFirst2 = new Line(geometryFirst2, materialObjects);
        lineFirst2.userData.type = "Line";
        scene.add(lineFirst2);

        const text = positionsXLeftLines[index].width;

        if (text !== 0) {
          // const z = measuresZG.max + 0.2 + distanceTop ;
          const x = measuresXG.max;
          // Side
          let loaderr = new FontLoader();

          loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
            const color = new Color(0x00000);

            const matLite = new MeshBasicMaterial({
              color: color,
              transparent: true,
              opacity: 0.6,
              side: DoubleSide,
            });

            // let text = positionsXLeftLines[index].begin - wallWidth*2;
            const shapesTop = font.generateShapes(
              "" + Math.ceil(text * 1000),
              150
            );
            const geometryTopBottom = new ShapeGeometry(shapesTop);
            geometryTopBottom.computeBoundingBox();
            geometryTopBottom.translate(
              -0.5 *
                (geometryTopBottom.boundingBox.max.x -
                  geometryTopBottom.boundingBox.min.x),
              0,
              0
            );

            const textTop = new Mesh(geometryTopBottom, matLite);
            textTop.position.set(
              x,
              positionsXLeftLines[index].begin +
                positionsXLeftLines[index].width / 2,
              measuresZG.min - 0.3
            );
            textTop.scale.set(0.0006, 0.0006, 0.0006);
            textTop.rotation.x = degrees_to_radians(90);
            textTop.rotation.y = degrees_to_radians(270);
            textTop.rotation.z = degrees_to_radians(180);

            textTop.userData.type = "Text";

            scene.add(textTop);

            render();
          }); //end load function
        }

        // positions

        var geometry = new BufferGeometry();
        geometry.setAttribute(
          "position",
          new Float32BufferAttribute(positions, 3)
        );

        geometry.computeBoundingSphere();

        var materialPoints = new PointsMaterial({
          size: 0.04,
          vertexColors: new MeshPhongMaterial({ color: 0xff0000 }),
        });

        let points = new Points(geometry, materialPoints);
        points.name = "points";
        scene.add(points);
      }
    }
    setTimeout(async () => {
      let c = document.getElementById("myCanvas");
      if (objNO > 0) {
        html2canvas(c).then(async (canvas) => {
          var t = canvas.toDataURL().replace("data:image/png;base64,", "");
          downloadBase64File("image/png", t, "image");

          // Delete lines

          // backLight.visible = false;

          for (let index = 0; index < objects.length; index++) {
            if (objects[index].rotation.y != degrees_to_radians(-90)) {
              objects[index].visible = true;
            } else {
              // objects[index].scale.z = 1;
              objects[index].scale.z = objects[index].userData.oldSizeZ;

              if (!wall && objects[index].userData.positionXScreen) {
                objects[index].position.x =
                  objects[index].userData.positionXScreen;
              }
            }
            scene.add(objects[index]);
          }

          for (let index = 0; index < leftCovers.length; index++) {
            // if (leftCovers[index].rotation.y != degrees_to_radians(-90)) {
            leftCovers[index].visible = true;
            // } else {
            //   leftCovers[index].scale.z = 1;
            // }
          }
          for (let index = 0; index < rightCovers.length; index++) {
            // if (rightCovers[index].rotation.y != degrees_to_radians(-90)) {
            rightCovers[index].visible = true;
            // } else {
            //   rightCovers[index].scale.z = 1;
            // }
          }
          for (let index = 0; index < backCovers.length; index++) {
            // if (backCovers[index].rotation.y != degrees_to_radians(-90)) {
            backCovers[index].visible = true;
            // } else {
            //   backCovers[index].scale.z = 1;
            // }
          }
          for (let index = 0; index < wallPanels.length; index++) {
            // if (wallPanels[index].rotation.y != degrees_to_radians(-90)) {
            wallPanels[index].visible = true;
            // } else {
            //   wallPanels[index].scale.z = 1;
            // }
          }
          // for (let index = 0; index < directions.length; index++) {
          //   if (directions[index].rotation.y != degrees_to_radians(-90)) {
          //     directions[index].visible = true;
          //   // } else {
          //   //   directions[index].scale.z = 1;
          //   // }
          // }
          // for (let index = 0; index < finishTops.length; index++) {

          //   if (degrees_to_radians(-90) != finishTops[index].userData.rotationY) {
          //     finishTops[index].visible = true;
          //   } else {
          //     finishTops[index].scale.x = finishTops[index].userData.oldValue ;
          //   }
          // }

          for (let index = 0; index < Cornices.length; index++) {
            // if (Cornices[index].rotation.y != degrees_to_radians(-90)) {
            Cornices[index].visible = true;
            // } else {
            //   Cornices[index].scale.z = 1;
            // }
          }
          for (let index = 0; index < decoStrips.length; index++) {
            // if (decoStrips[index].rotation.y != degrees_to_radians(-90)) {
            decoStrips[index].visible = true;
            // } else {
            //   decoStrips[index].scale.z = 1;
            // }
          }
          for (let index = 0; index < sinks.length; index++) {
            // if (sinks[index].rotation.y != degrees_to_radians(-90)) {
            sinks[index].visible = true;
            // } else {
            //   sinks[index].scale.z = 1;
            // }
          }
          for (let index = 0; index < ovens.length; index++) {
            // if (ovens[index].rotation.y != degrees_to_radians(-90)) {
            ovens[index].visible = true;
            // } else {
            //   ovens[index].scale.z = 1;
            // }
          }

          for (let index = 0; index < fillers.length; index++) {
            // if (fillers[index].rotation.y != degrees_to_radians(-90)) {
            fillers[index].visible = true;
            // } else {
            //   fillers[index].scale.z = 1;
            // }
          }
          // camera.position.set(3, 1, 9);
          // controls.target.set(0, 1, 0);
          // controls.enabled = true;
          // controls.update();

          planeFront.visible = true;
          planeLeft.visible = true;
          planeBack.visible = true;
          // planeRight.visible = true;
          planeBottom.visible = true;
          planeTop.visible = true;

          await deleteLines();
        });
      }
      await to2D();
    }, time * 1.1);
  }, time);
  // },(BC > 0 || LC >0)?700:300);
}

async function drawFrontScreen(time, wall) {
  setTimeout(async () => {
    if (is2D) {
      await to2D();
    }
    // camera.position.set(0, 5, 0.8);
    // controls.target.set(0, 0, 0.8);
    camera.position.set(0, measures.height / 2, -2);
    controls.target.set(0, measures.height / 2, 0);
    controls.enabled = false;

    controls.update();
    // controls.enabled = false;
    // controls.update();
    // camera.position.set(0, 5, 0.8);
    // controls.target.set(0, 0, 0.8);
    document.getElementById("myCanvas").style.cursor = "not-allowed";
    document.getElementById("myCanvas").style.pointerEvents = "none";
    // cursor: ;
    // pointer-events: none;

    // dragControls.update();
    planeBack.visible = false;
    planeFront.visible = true;
    planeLeft.visible = false;
    planeRight.visible = false;
    planeBottom.visible = false;
    planeTop.visible = false;

    planeFront.scale.y = planeBack.scale.y;
    planeFront.position.y = planeBack.position.y;
    //  planeFront.scale.y = measures.height;
    // backLight.visible = false;

    var objNO = await changeScale(
      180,
      wall,
      measuresZG.max - 0.1,
      "positionZ",
      "z"
    );
    //  console.log("Front objNO ", objNO);

    for (let index = 0; index < finishTops.length; index++) {
      finishTops[index].userData.oldValue = finishTops[index].scale.z;

      finishTops[index].visible = false;
      //  if(wall){
      //   if(finishTops[index].position.x == measuresXG.max - 0.1){
      //     finishTops[index].scale.x = 0.0005;
      //   }else{
      //     finishTops[index].visible = false;

      //   }

      // }else{
      //   if(finishTops[index].position.x != measuresXG.max - 0.1){
      //     finishTops[index].scale.x = 0.0005;
      //   }else{
      //     finishTops[index].visible = false;

      //   }
      // }
    }
    //  console.log("objNO   " , objNO);
    if (objNO > 0) {
      const material = new LineBasicMaterial({ color: 0x0000ff });

      /// Essential texts
      const loaderr = new FontLoader();
      loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
        const color = new Color(0x00000);

        const matLite = new MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.6,
          side: DoubleSide,
        });

        const shapesTop = font.generateShapes(
          "" +
            Math.ceil((measuresXG.max - measuresXG.min - 0.2) * 1000) +
            " mm",
          150
        );
        const geometryTopBottom = new ShapeGeometry(shapesTop);
        geometryTopBottom.computeBoundingBox();
        geometryTopBottom.translate(
          -0.5 *
            (geometryTopBottom.boundingBox.max.x -
              geometryTopBottom.boundingBox.min.x),
          0,
          0
        );

        textBottom = new Mesh(geometryTopBottom, matLite);
        textBottom.position.set(0, -1.0, measuresZG.max + 0.2);
        textBottom.scale.set(0.0007, 0.0007, 0.0007);
        textBottom.rotation.x = degrees_to_radians(180);
        textBottom.rotation.z = degrees_to_radians(180);

        textBottom.userData.type = "Text";

        scene.add(textBottom);

        const shapesLeftRight = font.generateShapes(
          "" + Math.ceil(measures.height * 1000) + " mm",
          150
        );
        const geometryLeftRight = new ShapeGeometry(shapesLeftRight);
        geometryLeftRight.computeBoundingBox();
        geometryLeftRight.translate(
          -0.5 *
            (geometryLeftRight.boundingBox.max.x -
              geometryLeftRight.boundingBox.min.x),
          0,
          0
        );

        textLeft = new Mesh(geometryLeftRight, matLite);
        textLeft.scale.set(0.0007, 0.0007, 0.0007);
        textLeft.position.set(
          measuresXG.max + 0.8,
          measures.height / 2,
          measuresZG.max + 0.2
        );

        textLeft.rotation.x = degrees_to_radians(180);
        textLeft.rotation.z = degrees_to_radians(-90);
        //  textLeft.rotation.y = degrees_to_radians(180);
        textLeft.userData.type = "Text";

        scene.add(textLeft);

        render();
      }); //end essential texts

      let points = [];

      // Left Line
      while (points.length > 0) {
        points.pop();
      }

      points.push(new Vector3(measuresXG.max + 0.6, 0, measuresZG.max + 0.2));

      points.push(
        new Vector3(measuresXG.max + 0.6, measures.height, measuresZG.max + 0.2)
      );

      const geometryLeft = new BufferGeometry().setFromPoints(points);
      const lineLeft = new Line(geometryLeft, material);
      lineLeft.userData.type = "Line";

      scene.add(lineLeft);

      // Bottom Line
      while (points.length > 0) {
        points.pop();
      }

      points.push(new Vector3(measuresXG.min + 0.1, -0.6, measuresZG.max));

      points.push(new Vector3(+measuresXG.max - 0.1, -0.6, measuresZG.max));

      const geometryBottom = new BufferGeometry().setFromPoints(points);
      const lineBottom = new Line(geometryBottom, material);
      lineBottom.userData.type = "Line";

      scene.add(lineBottom);

      let distanceTop = 0.1;

      let positionsZBottomLines = [];
      let positionsXLeftLines = [];

      for (let index = 0; index < objects.length; index++) {
        if (
          objects[index].rotation.y == degrees_to_radians(180) &&
          ((wall && objects[index].position.z == measuresZG.max - 0.1) ||
            (!wall && objects[index].position.z != measuresZG.max - 0.1))
        ) {
          // Draw lines of objects

          let from = objects[index].position.x;
          if (objects[index].name == "B" || objects[index].name == "Element") {
            drawLine(
              from,
              measuresZG.max,
              objects[index].position.x + objects[index].userData.W,
              measuresZG.max,
              null,
              materialObjects,
              -0.2 - distanceTop
            );

            positionsZBottomLines.push({
              begin: from,
              width: objects[index].userData.W,
            });

            let loaderr = new FontLoader();
            loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
              const color = new Color(0x00000);

              const matLite = new MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6,
                side: DoubleSide,
              });
              let text = objects[index].userData.W;
              const shapesTop = font.generateShapes(
                "" + Math.ceil(text * 1000),
                150
              );
              const geometryTopBottom = new ShapeGeometry(shapesTop);
              geometryTopBottom.computeBoundingBox();
              geometryTopBottom.translate(
                -0.5 *
                  (geometryTopBottom.boundingBox.max.x -
                    geometryTopBottom.boundingBox.min.x),
                0,
                0
              );

              const textTop = new Mesh(geometryTopBottom, matLite);
              textTop.position.set(
                objects[index].position.x + objects[index].userData.W / 2,
                -0.4 - distanceTop,
                measuresZG.max
              );
              textTop.scale.set(0.0006, 0.0006, 0.0006);
              textTop.rotation.x = degrees_to_radians(180);
              // textTop.rotation.x = degrees_to_radians(270);
              textTop.rotation.z = degrees_to_radians(180);
              textTop.userData.type = "Text";

              scene.add(textTop);

              render();
            }); //end load function
          }
          //  console.log("objects[index].position.y  " ,objects[index].position.y);
          positionsXLeftLines.push({
            begin: objects[index].position.y,
            width:
              objects[index].userData.H +
              (objects[index].position.y > 0.1 ? 0 : 0.1),
          });

          // positionsXLeftLines.push({
          //   begin: objects[index].position.y,
          //   width: objects[index].position.y + objects[index].userData.H,
          // });
          //  loaderr = new FontLoader();
          // loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
          //   const color = new Color(0x00000);

          //   const matLite = new MeshBasicMaterial({
          //     color: color,
          //     transparent: true,
          //     opacity: 0.6,
          //     side: DoubleSide,
          //   });
          //   let text = objects[index].position.y + objects[index].userData.H / 2;
          //   const shapesTop = font.generateShapes("" + Math.ceil(text * 1000), 100);
          //   const geometryTopBottom = new ShapeGeometry(shapesTop);
          //   geometryTopBottom.computeBoundingBox();
          //   geometryTopBottom.translate(
          //     -0.5 *
          //       (geometryTopBottom.boundingBox.max.x -
          //         geometryTopBottom.boundingBox.min.x),
          //     0,
          //     0
          //   );

          //   const textTop = new Mesh(geometryTopBottom, matLite);
          //   textTop.position.set(-measuresXG.max - 0.2 - distanceTop,  objects[index].position.y + (objects[index].userData.H / 2), z);
          //   textTop.scale.set(0.0006, 0.0006, 0.0006);
          //   textTop.rotation.x = degrees_to_radians(270);
          //   textTop.rotation.z = degrees_to_radians(90);
          //   textTop.userData.type = "Text";

          //   scene.add(textTop);
        }
      }

      positionsZBottomLines?.sort((a, b) => (a.begin > b.begin ? 1 : -1));
      positionsXLeftLines?.sort((a, b) => (a.begin > b.begin ? 1 : -1));

      for (let index = 0; index < positionsZBottomLines.length; index++) {
        var positions = [];

        if (index === 0) {
          drawLine(
            measuresXG.min + 0.1,
            measuresZG.max,
            positionsZBottomLines[index].begin,
            measuresZG.max,
            positions,
            materialRight,
            -0.2 - distanceTop
          );
          /// Write text
          let loaderr = new FontLoader();
          loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
            const color = new Color(0x00000);

            const matLite = new MeshBasicMaterial({
              color: color,
              transparent: true,
              opacity: 0.6,
              side: DoubleSide,
            });

            let text =
              positionsZBottomLines[index].begin + measuresXG.max - 0.1;
            const shapesTop = font.generateShapes(
              "" + Math.ceil(text * 1000),
              150
            );
            const geometryTopBottom = new ShapeGeometry(shapesTop);
            geometryTopBottom.computeBoundingBox();
            geometryTopBottom.translate(
              -0.5 *
                (geometryTopBottom.boundingBox.max.x -
                  geometryTopBottom.boundingBox.min.x),
              0,
              0
            );

            const textTop = new Mesh(geometryTopBottom, matLite);
            textTop.position.set(
              (measuresXG.min + 0.1 + positionsZBottomLines[index].begin) / 2,
              -0.4 - distanceTop,
              measuresZG.max
            );
            textTop.scale.set(0.0006, 0.0006, 0.0006);
            textTop.rotation.x = degrees_to_radians(180);
            textTop.rotation.z = degrees_to_radians(180);

            textTop.userData.type = "Text";

            scene.add(textTop);

            render();
          }); //end load function
        }
        let finishPoint = 0;
        if (index < positionsZBottomLines.length - 1) {
          finishPoint = positionsZBottomLines[index + 1].begin;
        } else {
          finishPoint = measuresXG.max - 0.1;
        }

        /// x1,z1,x2,z2,positions,material

        drawLine(
          positionsZBottomLines[index].begin +
            positionsZBottomLines[index].width,
          measuresZG.max,
          finishPoint,
          measuresZG.max,
          positions,
          materialRight,
          -0.2 - distanceTop
        );

        const text =
          finishPoint -
          (positionsZBottomLines[index].begin +
            positionsZBottomLines[index].width);

        if (text !== 0) {
          // writeText(text, x, y);
          let loaderr = new FontLoader();
          loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
            const color = new Color(0x00000);

            const matLite = new MeshBasicMaterial({
              color: color,
              transparent: true,
              opacity: 0.6,
              side: DoubleSide,
            });
            let text =
              finishPoint -
              (positionsZBottomLines[index].begin +
                positionsZBottomLines[index].width);
            const shapesTop = font.generateShapes(
              "" + Math.ceil(text * 1000),
              150
            );
            const geometryTopBottom = new ShapeGeometry(shapesTop);
            geometryTopBottom.computeBoundingBox();
            geometryTopBottom.translate(
              -0.5 *
                (geometryTopBottom.boundingBox.max.x -
                  geometryTopBottom.boundingBox.min.x),
              0,
              0
            );

            const textTop = new Mesh(geometryTopBottom, matLite);
            textTop.position.set(
              (positionsZBottomLines[index].begin +
                positionsZBottomLines[index].width +
                finishPoint) /
                2,
              -0.4 - distanceTop,
              measuresZG.max
            );
            textTop.scale.set(0.0006, 0.0006, 0.0006);
            textTop.rotation.x = degrees_to_radians(180);
            textTop.rotation.z = degrees_to_radians(180);
            textTop.userData.type = "Text";

            scene.add(textTop);

            render();
          }); //end load function
        }

        // positions

        var geometry = new BufferGeometry();
        geometry.setAttribute(
          "position",
          new Float32BufferAttribute(positions, 3)
        );

        geometry.computeBoundingSphere();

        var materialPoints = new PointsMaterial({
          size: 0.04,
          vertexColors: new MeshPhongMaterial({ color: 0xff0000 }),
        });

        let points = new Points(geometry, materialPoints);
        points.name = "points";
        scene.add(points);
      }
      for (let index = 0; index < positionsXLeftLines.length; index++) {
        var positions = [];

        /// x1,z1,x2,z2,positions,material

        let xLeft = measuresXG.max + 0.2;
        let zLeft = measuresZG.max;
        let yBegin = positionsXLeftLines[index].begin;
        let yEnd = positionsXLeftLines[index].width;

        let pointsLeft = [];

        pointsLeft.push(new Vector3(xLeft, yBegin, zLeft));
        pointsLeft.push(new Vector3(xLeft, yBegin + yEnd, zLeft));
        // console.log("points ", pointsLeft);

        if (positions) {
          positions.push(xLeft, yBegin, zLeft);
          positions.push(xLeft, yBegin + yEnd, zLeft);
        }
        //  console.log("positionsXLeftLines  " , positionsXLeftLines);
        // if (index === 0) {
        //   // drawLine(
        //   //   measuresXG.min - 0.4,
        //   //   measuresZG.min,
        //   //   positionsXLeftLines[index].begin,
        //   //   measuresZG.min,
        //   //   positions,
        //   //   materialRight,
        //   //   -0.2 - distanceTop
        //   // );

        // let xLeft = measuresXG.min - 0.2;
        // let zLeft = measuresZG.min;
        // let yBegin = wallWidth*2;
        // let yEnd = positionsXLeftLines[index].begin;

        // let pointsLeft = [];

        // pointsLeft.push(new Vector3(xLeft, yBegin, zLeft));
        // pointsLeft.push(new Vector3(xLeft, yEnd, zLeft));
        // // console.log("points ", pointsLeft);

        // if (positions) {
        //   positions.push(xLeft, yBegin, zLeft);
        //   positions.push(xLeft, yEnd, zLeft);
        // }
        // const geometryFirst2 = new BufferGeometry().setFromPoints(
        //   pointsLeft
        // );
        // const lineFirst2 = new Line(geometryFirst2, materialRight);
        // lineFirst2.userData.type = "Line";
        // // scene.add(lineFirst2);

        //   /// Write text
        //   let loaderr = new FontLoader();
        //   loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
        //     const color = new Color(0x00000);

        //     const matLite = new MeshBasicMaterial({
        //       color: color,
        //       transparent: true,
        //       opacity: 0.6,
        //       side: DoubleSide,
        //     });

        //     let text = positionsXLeftLines[index].begin - wallWidth*2;
        //     const shapesTop = font.generateShapes(
        //       "" + Math.ceil(text * 1000),
        //       150
        //     );
        //     const geometryTopBottom = new ShapeGeometry(shapesTop);
        //     geometryTopBottom.computeBoundingBox();
        //     geometryTopBottom.translate(

        //       0,
        //       -0.5 *
        //       (geometryTopBottom.boundingBox.max.y -
        //         geometryTopBottom.boundingBox.min.y) ,0

        //     );

        //     const textTop = new Mesh(geometryTopBottom, matLite);
        //     textTop.position.set(
        //       measuresXG.min - 0.3,
        //       (measuresXG.min + positionsXLeftLines[index].begin) / 2,
        //       measuresZG.min
        //     );
        //     textTop.scale.set(0.0006, 0.0006, 0.0006);
        //     textTop.rotation.x = degrees_to_radians(0);
        //     textTop.rotation.y = degrees_to_radians(90);

        //     textTop.userData.type = "Text";

        //     scene.add(textTop);

        //     render();
        //   }); //end load function
        // }
        const geometryFirst2 = new BufferGeometry().setFromPoints(pointsLeft);
        const lineFirst2 = new Line(geometryFirst2, materialObjects);
        lineFirst2.userData.type = "Line";
        scene.add(lineFirst2);

        const text = positionsXLeftLines[index].width;
        // side text
        if (text !== 0) {
          const z = measuresZG.max;
          const x = measuresXG.max + 0.2 + distanceTop;

          let loaderr = new FontLoader();
          loaderr.load("fonts/Tajawal Medium_Regular.json", function (font) {
            const color = new Color(0x00000);

            const matLite = new MeshBasicMaterial({
              color: color,
              transparent: true,
              opacity: 0.6,
              side: DoubleSide,
            });

            const shapesTop = font.generateShapes(
              "" + Math.ceil(text * 1000),
              150
            );
            const geometryTopBottom = new ShapeGeometry(shapesTop);
            geometryTopBottom.computeBoundingBox();
            geometryTopBottom.translate(
              -0.5 *
                (geometryTopBottom.boundingBox.max.x -
                  geometryTopBottom.boundingBox.min.x),
              0,
              0
            );

            const textTop = new Mesh(geometryTopBottom, matLite);

            textTop.position.set(
              x,
              positionsXLeftLines[index].begin +
                positionsXLeftLines[index].width / 2,
              z
            );
            textTop.scale.set(0.0006, 0.0006, 0.0006);

            textTop.rotation.x = degrees_to_radians(180);
            textTop.rotation.z = degrees_to_radians(-90);
            textTop.userData.type = "Text";

            scene.add(textTop);

            render();
          }); //end load function
        }

        // positions

        var geometry = new BufferGeometry();
        geometry.setAttribute(
          "position",
          new Float32BufferAttribute(positions, 3)
        );

        geometry.computeBoundingSphere();

        var materialPoints = new PointsMaterial({
          size: 0.04,
          vertexColors: new MeshPhongMaterial({ color: 0xff0000 }),
        });

        let points = new Points(geometry, materialPoints);
        points.name = "points";
        scene.add(points);
      }
    }
    setTimeout(async () => {
      let c = document.getElementById("myCanvas");
      if (objNO > 0) {
        html2canvas(c).then(async (canvas) => {
          var t = canvas.toDataURL().replace("data:image/png;base64,", "");
          downloadBase64File("image/png", t, "image");

          // Delete lines
          await deleteLines();

          planeBack.visible = true;
          planeFront.scale.y = 0.001;
          planeFront.position.y = 0.001;
          planeLeft.visible = true;
          planeRight.visible = true;
          planeBottom.visible = true;
          planeTop.visible = true;

          for (let index = 0; index < objects.length; index++) {
            if (objects[index].rotation.y != degrees_to_radians(180)) {
              objects[index].visible = true;
            } else {
              //  objects[index].scale.z = 1;
              objects[index].scale.z = objects[index].userData.oldSizeZ;

              if (!wall && objects[index].userData.positionZScreen) {
                objects[index].position.z =
                  objects[index].userData.positionZScreen;
              }
            }
            scene.add(objects[index]);
          }

          for (let index = 0; index < leftCovers.length; index++) {
            //  if (leftCovers[index].rotation.y != degrees_to_radians(180)) {
            leftCovers[index].visible = true;
            //  } else {
            //    leftCovers[index].scale.z = 1;
            //  }
          }
          for (let index = 0; index < rightCovers.length; index++) {
            //  if (rightCovers[index].rotation.y != degrees_to_radians(180)) {
            rightCovers[index].visible = true;
            //  } else {
            //    rightCovers[index].scale.z = 1;
            //  }
          }
          for (let index = 0; index < backCovers.length; index++) {
            //  if (backCovers[index].rotation.y != degrees_to_radians(180)) {
            backCovers[index].visible = true;
            //  } else {
            //    backCovers[index].scale.z = 1;
            //  }
          }
          for (let index = 0; index < wallPanels.length; index++) {
            //  if (wallPanels[index].rotation.y != degrees_to_radians(180)) {
            wallPanels[index].visible = true;
            //  } else {
            //    wallPanels[index].scale.z = 1;
            //  }
          }

          //  for (let index = 0; index < finishTops.length; index++) {

          //      finishTops[index].visible = true;

          //  }

          for (let index = 0; index < Cornices.length; index++) {
            //  if (Cornices[index].rotation.y != degrees_to_radians(180)) {
            Cornices[index].visible = true;
            //  } else {
            //    Cornices[index].scale.z = 1;
            //  }
          }
          for (let index = 0; index < decoStrips.length; index++) {
            //  if (decoStrips[index].rotation.y != degrees_to_radians(180)) {
            decoStrips[index].visible = true;
            //  } else {
            //    decoStrips[index].scale.z = 1;
            //  }
          }
          for (let index = 0; index < sinks.length; index++) {
            //  if (sinks[index].rotation.y != degrees_to_radians(180)) {
            sinks[index].visible = true;
            //  } else {
            //    sinks[index].scale.z = 1;
            //  }
          }
          for (let index = 0; index < ovens.length; index++) {
            //  if (ovens[index].rotation.y != degrees_to_radians(180)) {
            ovens[index].visible = true;
            //  } else {
            //    ovens[index].scale.z = 1;
            //  }
          }
          for (let index = 0; index < fillers.length; index++) {
            // if (fillers[index].rotation.y != degrees_to_radians(180)) {
            fillers[index].visible = true;
            // } else {
            //   fillers[index].scale.z = 1;
            // }
          }

          await deleteLines();
        });
      }
      await to2D();
    }, time * 1.1);
  }, time);
}

async function drawFrontLeft(time, wall) {
  setTimeout(async () => {
    if (is2D) {
      await to2D();
    }
    var maxZ = -10;
    var maxL = -10;
    var maxHW = 0;
    var maxHB = 0;
    var firstObject = {};
    var firstObjectX = 0;
    var firstObjectZ = 0;
    var tallerObject = -1;
    let objectsLeft = [];

    for await (const object of objects) {
      object.userData.oldSizeZ = object.scale.z;
      object.userData.oldSizeX = object.scale.x;
      if (
        object.rotation.y == degrees_to_radians(90) &&
        object.position.x == measuresXG.min + 0.1
      ) {
        if (maxZ < object.position.z) {
          maxZ = object.position.z;
          firstObject = object.position.z + object.userData.W;
          firstObjectX = object.position.x;
          firstObjectZ = object.position.z;
        }
        if (tallerObject < object.userData.H + object.position.y) {
          tallerObject = object.userData.H + object.position.y;
        }

        if (object.position.y > 1) {
          if (maxHW < object.position.y + object.userData.H)
            maxHW = object.position.y + object.userData.H;
        } else {
          if (maxHB < object.position.y + object.userData.H)
            maxHB = object.position.y + object.userData.H;
        }

        if (maxL < object.userData.L) maxL = object.userData.L;

        objectsLeft.push(object);

        for (let w = 0; w < object.children.length; w++) {
          if (object.children[w].type == "Mesh")
            object.children[w].material.wireframe = true;
        }
      } else {
        object.visible = false;
      }
    }

    if (objectsLeft.length > 0) {
      var lentext = 0.35;
      var len = 0.35;

      let endLines = [];
      var lengthW = 0.1;
      var lengthB = 0.1;
      for (let index = 0; index < objectsLeft.length; index++) {
        var value = objectsLeft[index].position.z;
        objectsLeft[index].position.z = firstObject;
        objectsLeft[index].userData.oldPositionZ = value;
        // objects[index].scale.z = objects[index].userData.oldSizeZ;

        objectsLeft[index].scale.x = 0.0001;
        var lineExist = false;
        for (let l = 0; l < endLines.length; l++) {
          if (
            endLines[l].end ==
              objectsLeft[index].position.x + objectsLeft[index].userData.L &&
            endLines[l].height == objectsLeft[index].position.y
          ) {
            lineExist = true;
            break;
          }
        }
        if (!lineExist) {
          var line = {
            end: objectsLeft[index].position.x + objectsLeft[index].userData.L,
            height: objectsLeft[index].position.y,
          };

          endLines.push(line);
          var heightLine = 0;
          var heightText = 0;

          //  drawLine(
          //     objectsLeft[index].position.x ,
          //     firstObject ,
          //     objectsLeft[index].position.x + objectsLeft[index].userData.L,
          //     firstObject ,
          //     null,
          //     materialObjects,
          //     heightLine
          //   );
          // console.log("len  ",len);
          // console.log("heightLine  ",heightLine);
          // console.log("heightLine+ len  ",heightLine+ len);

          let loaderr = new FontLoader();
          loaderr.load(
            "fonts/Tajawal Medium_Regular.json",
            function async(font) {
              const color = new Color(0x00000);

              const matLite = new MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6,
                side: DoubleSide,
              });
              let text = objectsLeft[index].userData.L;
              const shapesTop = font.generateShapes(
                "" + Math.ceil(text * 1000),
                100
              );
              const geometryTopBottom = new ShapeGeometry(shapesTop);
              geometryTopBottom.computeBoundingBox();
              geometryTopBottom.translate(
                -0.5 *
                  (geometryTopBottom.boundingBox.max.x -
                    geometryTopBottom.boundingBox.min.x),
                0,
                0
              );

              if (objectsLeft[index].position.y > 1) {
                lengthW += 0.1;
                heightText = maxHW + lengthW + 0.025;
                heightLine = maxHW + lengthW;
              } else {
                lengthB += 0.1;
                heightText = maxHB + lengthB + 0.025;
                heightLine = maxHB + lengthB;
              }
              const textTop = new Mesh(geometryTopBottom, matLite);
              drawLine(
                objectsLeft[index].position.x,
                firstObject,
                objectsLeft[index].position.x + objectsLeft[index].userData.L,
                firstObject,
                null,
                materialObjects,
                heightLine
              );
              textTop.position.set(
                objectsLeft[index].position.x +
                  objectsLeft[index].userData.L / 2,
                heightText,
                firstObject
              );

              textTop.scale.set(0.0006, 0.0006, 0.0006);
              textTop.rotation.x = degrees_to_radians(0);
              textTop.rotation.z = degrees_to_radians(0);
              textTop.userData.type = "Text";

              scene.add(textTop);
              lentext = lentext + 0.1;
              render();
            }
          ); //end load function

          len = len + 0.1;
        }
      }

      camera.position.set(
        firstObjectX + maxL / 2,
        tallerObject / 2,
        measuresZG.max + (firstObjectZ > 0 ? 3 : 0.8)
      );
      controls.target.set(
        firstObjectX + maxL / 2,
        tallerObject / 2,
        measuresZG.min
      );

      controls.enabled = false;

      controls.update();

      document.getElementById("myCanvas").style.cursor = "not-allowed";
      document.getElementById("myCanvas").style.pointerEvents = "none";

      planeBack.visible = false;
      planeFront.visible = false;
      planeLeft.visible = false;
      planeRight.visible = false;
      planeBottom.visible = false;
      planeTop.visible = false;

      var objNO = await changeScale(
        180,
        wall,
        measuresZG.max - 0.1,
        "positionZ",
        "a"
      );
      var objNO = 1;

      for (let index = 0; index < finishTops.length; index++) {
        finishTops[index].userData.oldValue = finishTops[index].scale.z;

        finishTops[index].visible = false;
      }

      setTimeout(async () => {
        let c = document.getElementById("myCanvas");
        if (objNO > 0 || wall) {
          html2canvas(c).then(async (canvas) => {
            var t = canvas.toDataURL().replace("data:image/png;base64,", "");
            downloadBase64File("image/png", t, "image");

            // Delete lines
            await deleteLines();

            planeBack.visible = true;
            planeFront.scale.y = 0.001;
            planeFront.position.y = 0.001;
            planeLeft.visible = true;
            planeRight.visible = true;
            planeBottom.visible = true;
            planeTop.visible = true;

            var zVal = 1;
            for (let index = 0; index < objects.length; index++) {
              //  if (objects[index].rotation.y != degrees_to_radians(180) ) {
              //    objects[index].visible = true;
              //  } else {

              if (objects[index].rotation.y == degrees_to_radians(0))
                objects[index].scale.z = objects[index].userData.oldSizeZ;
              if (objects[index].rotation.y == degrees_to_radians(90))
                objects[index].scale.z = objects[index].userData.oldSizeZ;
              if (objects[index].rotation.y == degrees_to_radians(-90))
                objects[index].scale.z = objects[index].userData.oldSizeZ;
              if (objects[index].rotation.y == degrees_to_radians(180))
                objects[index].scale.z = objects[index].userData.oldSizeZ;

              //  objects[index].scale.z = 1;
              //  }
              for (let w = 0; w < objects[index].children.length; w++) {
                if (objects[index].children[w].type == "Mesh")
                  objects[index].children[w].material.wireframe = false;
              }
            }

            for (let index = 0; index < leftCovers.length; index++) {
              //  if (leftCovers[index].rotation.y != degrees_to_radians(180)) {
              //    leftCovers[index].visible = true;
              //  } else {
              // if(leftCovers[index].rotation.y == degrees_to_radians(0))
              // leftCovers[index].scale.z = zVal;
              //   if(leftCovers[index].rotation.y == degrees_to_radians(90))
              //   leftCovers[index].scale.z = zVal;
              //   if(leftCovers[index].rotation.y == degrees_to_radians(-90))
              //   leftCovers[index].scale.z = zVal;
              //   if(leftCovers[index].rotation.y == degrees_to_radians(180))
              //   leftCovers[index].scale.z = zVal;
              //  leftCovers[index].scale.z = 1;
              //  }
            }
            for (let index = 0; index < rightCovers.length; index++) {
              //  if (rightCovers[index].rotation.y != degrees_to_radians(180)) {
              //    rightCovers[index].visible = true;
              //  } else {
              // if(rightCovers[index].rotation.y == degrees_to_radians(0))
              // rightCovers[index].scale.z = zVal;
              //   if(rightCovers[index].rotation.y == degrees_to_radians(90))
              //   rightCovers[index].scale.z = zVal;
              //   if(rightCovers[index].rotation.y == degrees_to_radians(-90))
              //   rightCovers[index].scale.z = zVal;
              //   if(rightCovers[index].rotation.y == degrees_to_radians(180))
              //   rightCovers[index].scale.z = zVal;
              //  rightCovers[index].scale.z = 1;
              //  }
            }
            for (let index = 0; index < backCovers.length; index++) {
              //  if (backCovers[index].rotation.y != degrees_to_radians(180)) {
              //    backCovers[index].visible = true;
              //  } else {
              // if(backCovers[index].rotation.y == degrees_to_radians(0))
              // backCovers[index].scale.z = zVal;
              //   if(backCovers[index].rotation.y == degrees_to_radians(90))
              //   backCovers[index].scale.z = zVal;
              //   if(backCovers[index].rotation.y == degrees_to_radians(-90))
              //   backCovers[index].scale.z = zVal;
              //   if(backCovers[index].rotation.y == degrees_to_radians(180))
              //   backCovers[index].scale.z = zVal;
              //  backCovers[index].scale.z = 1;
              //  }
            }
            for (let index = 0; index < wallPanels.length; index++) {
              //  if (wallPanels[index].rotation.y != degrees_to_radians(180)) {
              //    wallPanels[index].visible = true;
              //  } else {
              // if(wallPanels[index].rotation.y == degrees_to_radians(0))
              // wallPanels[index].scale.z = zVal;
              //   if(wallPanels[index].rotation.y == degrees_to_radians(90))
              //   wallPanels[index].scale.z = zVal;
              //   if(wallPanels[index].rotation.y == degrees_to_radians(-90))
              //   wallPanels[index].scale.z = zVal;
              //   if(wallPanels[index].rotation.y == degrees_to_radians(180))
              //   wallPanels[index].scale.z = zVal;
              //  wallPanels[index].scale.z = 1;
              //  }
            }

            //  for (let index = 0; index < finishTops.length; index++) {

            //      finishTops[index].visible = true;

            //  }

            for (let index = 0; index < Cornices.length; index++) {
              //  if (Cornices[index].rotation.y != degrees_to_radians(180)) {
              //    Cornices[index].visible = true;
              //  } else {
              // if(Cornices[index].rotation.y == degrees_to_radians(0))
              // Cornices[index].scale.z = zVal;
              //   if(Cornices[index].rotation.y == degrees_to_radians(90))
              //   Cornices[index].scale.z = zVal;
              //   if(Cornices[index].rotation.y == degrees_to_radians(-90))
              //   Cornices[index].scale.z = zVal;
              //   if(Cornices[index].rotation.y == degrees_to_radians(180))
              //   Cornices[index].scale.z = zVal;
              //  Cornices[index].scale.z = 1;
              //  }
            }
            for (let index = 0; index < decoStrips.length; index++) {
              //  if (decoStrips[index].rotation.y != degrees_to_radians(180)) {
              //    decoStrips[index].visible = true;
              //  } else {
              // if(decoStrips[index].rotation.y == degrees_to_radians(0))
              // decoStrips[index].scale.z = zVal;
              //   if(decoStrips[index].rotation.y == degrees_to_radians(90))
              //   decoStrips[index].scale.z = zVal;
              //   if(decoStrips[index].rotation.y == degrees_to_radians(-90))
              //   decoStrips[index].scale.z = zVal;
              //   if(decoStrips[index].rotation.y == degrees_to_radians(180))
              //   decoStrips[index].scale.z = zVal;
              //  decoStrips[index].scale.z = 1;
              //  }
            }
            for (let index = 0; index < sinks.length; index++) {
              //  if (sinks[index].rotation.y != degrees_to_radians(180)) {
              //    sinks[index].visible = true;
              //  } else {
              // if(sinks[index].rotation.y == degrees_to_radians(0))
              // sinks[index].scale.z = zVal;
              //   if(sinks[index].rotation.y == degrees_to_radians(90))
              //   sinks[index].scale.z = zVal;
              //   if(sinks[index].rotation.y == degrees_to_radians(-90))
              //   sinks[index].scale.z = zVal;
              //   if(sinks[index].rotation.y == degrees_to_radians(180))
              //   sinks[index].scale.z = zVal;
              //  sinks[index].scale.z = 1;
              //  }
            }
            for (let index = 0; index < ovens.length; index++) {
              //  if (ovens[index].rotation.y != degrees_to_radians(180)) {
              //    ovens[index].visible = true;
              //  } else {
              // if(ovens[index].rotation.y == degrees_to_radians(0))
              // ovens[index].scale.z = zVal;
              //   if(ovens[index].rotation.y == degrees_to_radians(90))
              //   ovens[index].scale.z = zVal;
              //   if(ovens[index].rotation.y == degrees_to_radians(-90))
              //   ovens[index].scale.z = zVal;
              //   if(ovens[index].rotation.y == degrees_to_radians(180))
              //   ovens[index].scale.z = zVal;
              //  ovens[index].scale.z = 1;
              //  }
            }
            for (let index = 0; index < fillers.length; index++) {
              // if (fillers[index].rotation.y != degrees_to_radians(180)) {
              //   fillers[index].visible = true;
              // } else {
              // if(fillers[index].rotation.y == degrees_to_radians(0))
              // fillers[index].scale.z = zVal;
              //   if(fillers[index].rotation.y == degrees_to_radians(90))
              //   fillers[index].scale.z = zVal;
              //   if(fillers[index].rotation.y == degrees_to_radians(-90))
              //   fillers[index].scale.z = zVal;
              //   if(fillers[index].rotation.y == degrees_to_radians(180))
              //   fillers[index].scale.z = zVal;
              // fillers[index].scale.z = 1;
              // }
            }

            await deleteLines();

            for (let index = 0; index < objectsLeft.length; index++) {
              // objectsLeft.userData.oldPositionZ = objectsLeft[index].position.z
              objectsLeft[index].position.z =
                objectsLeft[index].userData.oldPositionZ;
              objectsLeft[index].userData.oldPositionZ = null;
              objectsLeft[index].scale.x = objectsLeft[index].userData.oldSizeX;

              scene.add(objectsLeft[index]);
            }
          });
        }
        await to2D();
      }, time * 1.1);
    } else {
      for (let index = 0; index < objects.length; index++) {
        if (objects[index].visible == false) {
          objects[index].visible = true;
        } else {
          for (let w = 0; w < objects[index].children.length; w++) {
            if (objects[index].children[w].type == "Mesh")
              objects[index].children[w].material.wireframe = true;
          }
        }
      }
    }
  }, time);
}

async function drawLeftBack(time, wall) {
  setTimeout(async () => {
    if (is2D) {
      await to2D();
    }
    var minX = 10;
    var maxL = -10;
    var maxHW = 0;
    var maxHB = 0;
    var firstObject = {};
    var firstObjectX = 0;
    var firstObjectZ = 0;
    var tallerObject = -1;
    let objectsLeft = [];

    for await (const object of objects) {
      object.userData.oldSizeZ = object.scale.z;
      object.userData.oldSizeX = object.scale.x;
      if (
        object.rotation.y == degrees_to_radians(0) &&
        object.position.z == measuresZG.min + 0.1
      ) {
        if (minX > object.position.x) {
          minX = object.position.x;
          firstObject = object.position.x - object.userData.W;
          firstObjectX = object.position.x;
          firstObjectZ = object.position.z;
        }
        if (tallerObject < object.userData.H + object.position.y) {
          tallerObject = object.userData.H + object.position.y;
        }

        if (object.position.y > 1) {
          if (maxHW < object.position.y + object.userData.H)
            maxHW = object.position.y + object.userData.H;
        } else {
          if (maxHB < object.position.y + object.userData.H)
            maxHB = object.position.y + object.userData.H;
        }

        if (maxL < object.userData.L) maxL = object.userData.L;

        objectsLeft.push(object);
        for (let w = 0; w < object.children.length; w++) {
          if (object.children[w].type == "Mesh")
            object.children[w].material.wireframe = true;
        }
      } else {
        object.visible = false;
      }
    }

    if (objectsLeft.length > 0) {
      var lentext = 0.35;
      var len = 0.35;
      var lengthW = 0.1;
      var lengthB = 0.1;

      let endLines = [];
      for (let index = 0; index < objectsLeft.length; index++) {
        var value = objectsLeft[index].position.x;
        objectsLeft[index].position.x = firstObject;
        objectsLeft[index].userData.oldPositionX = value;
        objectsLeft[index].scale.x = 0.0001;
        var lineExist = false;
        for (let l = 0; l < endLines.length; l++) {
          if (
            endLines[l].end ==
              objectsLeft[index].position.z + objectsLeft[index].userData.L &&
            endLines[l].height == objectsLeft[index].position.y
          ) {
            lineExist = true;
            break;
          }
        }
        if (!lineExist) {
          var line = {
            end: objectsLeft[index].position.z + objectsLeft[index].userData.L,
            height: objectsLeft[index].position.y,
          };
          endLines.push(line);
          var heightLine = 0;
          var heightText = 0;

          let loaderr = new FontLoader();
          loaderr.load(
            "fonts/Tajawal Medium_Regular.json",
            function async(font) {
              const color = new Color(0x00000);

              const matLite = new MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6,
                side: DoubleSide,
              });
              let text = objectsLeft[index].userData.L;
              const shapesTop = font.generateShapes(
                "" + Math.ceil(text * 1000),
                100
              );
              const geometryTopBottom = new ShapeGeometry(shapesTop);
              geometryTopBottom.computeBoundingBox();
              geometryTopBottom.translate(
                -0.5 *
                  (geometryTopBottom.boundingBox.max.x -
                    geometryTopBottom.boundingBox.min.x),
                0,
                0
              );

              if (objectsLeft[index].position.y > 1) {
                lengthW += 0.1;
                heightText = maxHW + lengthW + 0.025;
                heightLine = maxHW + lengthW;
              } else {
                lengthB += 0.1;
                heightText = maxHB + lengthB + 0.025;
                heightLine = maxHB + lengthB;
              }
              drawLine(
                firstObject,
                objectsLeft[index].position.z,
                firstObject,
                objectsLeft[index].position.z + objectsLeft[index].userData.L,
                null,
                materialObjects,
                heightLine
              );
              const textTop = new Mesh(geometryTopBottom, matLite);
              textTop.position.set(
                firstObject,
                heightText,
                objectsLeft[index].position.z +
                  objectsLeft[index].userData.L / 2
              );
              textTop.scale.set(0.0006, 0.0006, 0.0006);
              textTop.rotation.x = degrees_to_radians(180);
              textTop.rotation.y = degrees_to_radians(-90);
              textTop.rotation.z = degrees_to_radians(180);
              textTop.userData.type = "Text";

              scene.add(textTop);
              lentext = lentext + 0.1;
              render();
            }
          ); //end load function

          len = len + 0.1;
        }
      }

      camera.position.set(
        measuresXG.min - (firstObjectX < 0 ? 3 : 1.8),
        tallerObject / 2,
        firstObjectZ + maxL / 2
      );
      controls.target.set(
        measuresXG.min,
        tallerObject / 2,
        firstObjectZ + maxL / 2
      );

      controls.enabled = false;

      controls.update();

      document.getElementById("myCanvas").style.cursor = "not-allowed";
      document.getElementById("myCanvas").style.pointerEvents = "none";

      planeBack.visible = false;
      planeFront.visible = false;
      planeLeft.visible = false;
      planeRight.visible = false;
      planeBottom.visible = false;
      planeTop.visible = false;
      var objNO = await changeScale(
        180,
        wall,
        measuresXG.min + 0.1,
        "positionZ",
        "a"
      );
      var objNO = 1;

      for (let index = 0; index < finishTops.length; index++) {
        finishTops[index].userData.oldValue = finishTops[index].scale.z;

        finishTops[index].visible = false;
      }

      //  if(objNO>0 || wall){

      //  let distanceTop = 0.1;

      // }

      setTimeout(async () => {
        let c = document.getElementById("myCanvas");
        if (objNO > 0 || wall) {
          html2canvas(c).then(async (canvas) => {
            var t = canvas.toDataURL().replace("data:image/png;base64,", "");
            downloadBase64File("image/png", t, "image");

            // Delete lines
            await deleteLines();

            planeBack.visible = true;
            planeFront.scale.y = 0.001;
            planeFront.position.y = 0.001;
            planeLeft.visible = true;
            planeRight.visible = true;
            planeBottom.visible = true;
            planeTop.visible = true;
            var zVal = 1;
            for (let index = 0; index < objects.length; index++) {
              //  if (objects[index].rotation.y != degrees_to_radians(180) ) {
              //    objects[index].visible = true;
              //  } else {

              if (objects[index].rotation.y == degrees_to_radians(0))
                objects[index].scale.x = objects[index].userData.oldSizeX;
              if (objects[index].rotation.y == degrees_to_radians(90))
                objects[index].scale.x = objects[index].userData.oldSizeX;
              if (objects[index].rotation.y == degrees_to_radians(-90))
                objects[index].scale.x = objects[index].userData.oldSizeX;
              if (objects[index].rotation.y == degrees_to_radians(180))
                objects[index].scale.x = objects[index].userData.oldSizeX;

              //  objects[index].scale.z = 1;
              //  }
              for (let w = 0; w < objects[index].children.length; w++) {
                if (objects[index].children[w].type == "Mesh")
                  objects[index].children[w].material.wireframe = false;
              }
            }

            //  for (let index = 0; index < leftCovers.length; index++) {
            //   //  if (leftCovers[index].rotation.y != degrees_to_radians(180)) {
            //   //    leftCovers[index].visible = true;
            //   //  } else {
            //     if(leftCovers[index].rotation.y == degrees_to_radians(0))
            //     leftCovers[index].scale.x = zVal;
            //       if(leftCovers[index].rotation.y == degrees_to_radians(90))
            //       leftCovers[index].scale.x = zVal;
            //       if(leftCovers[index].rotation.y == degrees_to_radians(-90))
            //       leftCovers[index].scale.x = zVal;
            //       if(leftCovers[index].rotation.y == degrees_to_radians(180))
            //       leftCovers[index].scale.x = zVal;
            //     //  leftCovers[index].scale.z = 1;
            //   //  }
            //  }
            //  for (let index = 0; index < rightCovers.length; index++) {
            //   //  if (rightCovers[index].rotation.y != degrees_to_radians(180)) {
            //   //    rightCovers[index].visible = true;
            //   //  } else {
            //     if(rightCovers[index].rotation.y == degrees_to_radians(0))
            //     rightCovers[index].scale.x = zVal;
            //       if(rightCovers[index].rotation.y == degrees_to_radians(90))
            //       rightCovers[index].scale.x = zVal;
            //       if(rightCovers[index].rotation.y == degrees_to_radians(-90))
            //       rightCovers[index].scale.x = zVal;
            //       if(rightCovers[index].rotation.y == degrees_to_radians(180))
            //       rightCovers[index].scale.x = zVal;
            //     //  rightCovers[index].scale.z = 1;
            //   //  }
            //  }
            //  for (let index = 0; index < backCovers.length; index++) {
            //   //  if (backCovers[index].rotation.y != degrees_to_radians(180)) {
            //   //    backCovers[index].visible = true;
            //   //  } else {
            //     if(backCovers[index].rotation.y == degrees_to_radians(0))
            //     backCovers[index].scale.x = zVal;
            //       if(backCovers[index].rotation.y == degrees_to_radians(90))
            //       backCovers[index].scale.x = zVal;
            //       if(backCovers[index].rotation.y == degrees_to_radians(-90))
            //       backCovers[index].scale.x = zVal;
            //       if(backCovers[index].rotation.y == degrees_to_radians(180))
            //       backCovers[index].scale.x = zVal;
            //     //  backCovers[index].scale.z = 1;
            //   //  }
            //  }
            //  for (let index = 0; index < wallPanels.length; index++) {
            //   //  if (wallPanels[index].rotation.y != degrees_to_radians(180)) {
            //   //    wallPanels[index].visible = true;
            //   //  } else {
            //     if(wallPanels[index].rotation.y == degrees_to_radians(0))
            //     wallPanels[index].scale.x = zVal;
            //       if(wallPanels[index].rotation.y == degrees_to_radians(90))
            //       wallPanels[index].scale.x = zVal;
            //       if(wallPanels[index].rotation.y == degrees_to_radians(-90))
            //       wallPanels[index].scale.x = zVal;
            //       if(wallPanels[index].rotation.y == degrees_to_radians(180))
            //       wallPanels[index].scale.x = zVal;
            //     //  wallPanels[index].scale.z = 1;
            //   //  }
            //  }

            //  for (let index = 0; index < finishTops.length; index++) {

            //      finishTops[index].visible = true;

            //  }

            //  for (let index = 0; index < Cornices.length; index++) {
            //   //  if (Cornices[index].rotation.y != degrees_to_radians(180)) {
            //   //    Cornices[index].visible = true;
            //   //  } else {
            //     if(Cornices[index].rotation.y == degrees_to_radians(0))
            //     Cornices[index].scale.x = zVal;
            //       if(Cornices[index].rotation.y == degrees_to_radians(90))
            //       Cornices[index].scale.x = zVal;
            //       if(Cornices[index].rotation.y == degrees_to_radians(-90))
            //       Cornices[index].scale.x = zVal;
            //       if(Cornices[index].rotation.y == degrees_to_radians(180))
            //       Cornices[index].scale.x = zVal;

            //     //  Cornices[index].scale.z = 1;
            //   //  }
            //  }
            //  for (let index = 0; index < decoStrips.length; index++) {
            //   //  if (decoStrips[index].rotation.y != degrees_to_radians(180)) {
            //   //    decoStrips[index].visible = true;
            //   //  } else {
            //     if(decoStrips[index].rotation.y == degrees_to_radians(0))
            //     decoStrips[index].scale.x = zVal;
            //       if(decoStrips[index].rotation.y == degrees_to_radians(90))
            //       decoStrips[index].scale.x = zVal;
            //       if(decoStrips[index].rotation.y == degrees_to_radians(-90))
            //       decoStrips[index].scale.x = zVal;
            //       if(decoStrips[index].rotation.y == degrees_to_radians(180))
            //       decoStrips[index].scale.x = zVal;
            //     //  decoStrips[index].scale.z = 1;
            //   //  }
            //  }
            //  for (let index = 0; index < sinks.length; index++) {
            //   //  if (sinks[index].rotation.y != degrees_to_radians(180)) {
            //   //    sinks[index].visible = true;
            //   //  } else {
            //     if(sinks[index].rotation.y == degrees_to_radians(0))
            //     sinks[index].scale.x = zVal;
            //       if(sinks[index].rotation.y == degrees_to_radians(90))
            //       sinks[index].scale.x = zVal;
            //       if(sinks[index].rotation.y == degrees_to_radians(-90))
            //       sinks[index].scale.x = zVal;
            //       if(sinks[index].rotation.y == degrees_to_radians(180))
            //       sinks[index].scale.x = zVal;

            //     //  sinks[index].scale.z = 1;
            //   //  }
            //  }
            //  for (let index = 0; index < ovens.length; index++) {
            //   //  if (ovens[index].rotation.y != degrees_to_radians(180)) {
            //   //    ovens[index].visible = true;
            //   //  } else {
            //     if(ovens[index].rotation.y == degrees_to_radians(0))
            //     ovens[index].scale.x = zVal;
            //       if(ovens[index].rotation.y == degrees_to_radians(90))
            //       ovens[index].scale.x = zVal;
            //       if(ovens[index].rotation.y == degrees_to_radians(-90))
            //       ovens[index].scale.x = zVal;
            //       if(ovens[index].rotation.y == degrees_to_radians(180))
            //       ovens[index].scale.x = zVal;

            //     //  ovens[index].scale.z = 1;
            //   //  }
            //  }
            //  for (let index = 0; index < fillers.length; index++) {
            //   // if (fillers[index].rotation.y != degrees_to_radians(180)) {
            //   //   fillers[index].visible = true;
            //   // } else {
            //     if(fillers[index].rotation.y == degrees_to_radians(0))
            //     fillers[index].scale.x = zVal;
            //       if(fillers[index].rotation.y == degrees_to_radians(90))
            //       fillers[index].scale.x = zVal;
            //       if(fillers[index].rotation.y == degrees_to_radians(-90))
            //       fillers[index].scale.x = zVal;
            //       if(fillers[index].rotation.y == degrees_to_radians(180))
            //       fillers[index].scale.x = zVal;

            //     // fillers[index].scale.z = 1;
            //   // }

            // }

            await deleteLines();

            for (let index = 0; index < objectsLeft.length; index++) {
              // objectsLeft.userData.oldPositionZ = objectsLeft[index].position.z
              objectsLeft[index].position.x =
                objectsLeft[index].userData.oldPositionX;
              objectsLeft[index].userData.oldPositionX = null;
              objectsLeft[index].scale.x = objectsLeft[index].userData.oldSizeX;
              scene.add(objectsLeft[index]);
            }
          });
        }
        await to2D();
      }, time * 1.1);
    } else {
      for (let index = 0; index < objects.length; index++) {
        if (objects[index].visible == false) {
          objects[index].visible = true;
        } else {
          for (let w = 0; w < objects[index].children.length; w++) {
            if (objects[index].children[w].type == "Mesh")
              objects[index].children[w].material.wireframe = true;
          }
        }
      }
    }
  }, time);
}

async function drawBackRight(time, wall) {
  setTimeout(async () => {
    if (is2D) {
      await to2D();
    }
    var maxZ = -10;
    var maxL = -10;
    var maxHW = 0;
    var maxHB = 0;
    var firstObject = {};
    var firstObjectX = 0;
    var firstObjectZ = 0;
    var tallerObject = -1;
    let objectsLeft = [];

    for await (const object of objects) {
      object.userData.oldSizeZ = object.scale.z;
      object.userData.oldSizeX = object.scale.x;

      if (
        object.rotation.y == degrees_to_radians(-90) &&
        object.position.x == measuresXG.max - 0.1
      ) {
        if (maxZ < object.position.z) {
          maxZ = object.position.z;
          firstObject = object.position.z - object.userData.W;
          firstObjectX = object.position.x;
          firstObjectZ = object.position.z;
        }
        if (tallerObject < object.userData.H + object.position.y) {
          tallerObject = object.userData.H + object.position.y;
        }

        if (object.position.y > 1) {
          if (maxHW < object.position.y + object.userData.H)
            maxHW = object.position.y + object.userData.H;
        } else {
          if (maxHB < object.position.y + object.userData.H)
            maxHB = object.position.y + object.userData.H;
        }

        if (maxL < object.userData.L) maxL = object.userData.L;

        objectsLeft.push(object);

        for (let w = 0; w < object.children.length; w++) {
          if (object.children[w].type == "Mesh")
            object.children[w].material.wireframe = true;
        }
      } else {
        object.visible = false;
      }
    }

    if (objectsLeft.length > 0) {
      var lentext = 0.35;
      var len = 0.35;

      let endLines = [];
      var lengthW = 0.1;
      var lengthB = 0.1;
      for (let index = 0; index < objectsLeft.length; index++) {
        var value = objectsLeft[index].position.z;
        objectsLeft[index].position.z = firstObject;
        objectsLeft[index].userData.oldPositionZ = value;
        objectsLeft[index].scale.x = 0.0001;
        var lineExist = false;
        for (let l = 0; l < endLines.length; l++) {
          if (
            endLines[l].end ==
              objectsLeft[index].position.x - objectsLeft[index].userData.L &&
            endLines[l].height == objectsLeft[index].position.y
          ) {
            lineExist = true;
            break;
          }
        }

        if (!lineExist) {
          var line = {
            end: objectsLeft[index].position.x - objectsLeft[index].userData.L,
            height: objectsLeft[index].position.y,
          };

          endLines.push(line);
          var heightLine = 0;
          var heightText = 0;

          let loaderr = new FontLoader();
          loaderr.load(
            "fonts/Tajawal Medium_Regular.json",
            function async(font) {
              const color = new Color(0x00000);

              const matLite = new MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6,
                side: DoubleSide,
              });
              let text = objectsLeft[index].userData.L;
              const shapesTop = font.generateShapes(
                "" + Math.ceil(text * 1000),
                100
              );
              const geometryTopBottom = new ShapeGeometry(shapesTop);
              geometryTopBottom.computeBoundingBox();
              geometryTopBottom.translate(
                -0.5 *
                  (geometryTopBottom.boundingBox.max.x -
                    geometryTopBottom.boundingBox.min.x),
                0,
                0
              );

              if (objectsLeft[index].position.y > 1) {
                lengthW += 0.1;
                heightText = maxHW + lengthW + 0.025;
                heightLine = maxHW + lengthW;
              } else {
                lengthB += 0.1;
                heightText = maxHB + lengthB + 0.025;
                heightLine = maxHB + lengthB;
              }
              const textTop = new Mesh(geometryTopBottom, matLite);
              drawLine(
                objectsLeft[index].position.x,
                firstObject,
                objectsLeft[index].position.x - objectsLeft[index].userData.L,
                firstObject,
                null,
                materialObjects,
                heightLine
              );
              textTop.position.set(
                objectsLeft[index].position.x -
                  objectsLeft[index].userData.L / 2,
                heightText,
                firstObject
              );

              textTop.scale.set(0.0006, 0.0006, 0.0006);

              textTop.rotation.y = degrees_to_radians(0);
              textTop.rotation.x = degrees_to_radians(180);
              textTop.rotation.z = degrees_to_radians(180);

              textTop.userData.type = "Text";

              scene.add(textTop);
              lentext = lentext + 0.1;
              render();
            }
          ); //end load function

          len = len + 0.1;
        }
      }

      camera.position.set(
        firstObjectX - maxL / 2,
        tallerObject / 2,
        measuresZG.min - (firstObjectZ < 0 ? 3 : 0.8)
      );
      controls.target.set(
        firstObjectX - maxL / 2,
        tallerObject / 2,
        measuresZG.max
      );

      controls.enabled = false;

      controls.update();

      document.getElementById("myCanvas").style.cursor = "not-allowed";
      document.getElementById("myCanvas").style.pointerEvents = "none";

      planeBack.visible = false;
      planeFront.visible = false;
      planeLeft.visible = false;
      planeRight.visible = false;
      planeBottom.visible = false;
      planeTop.visible = false;
      var objNO = await changeScale(
        180,
        wall,
        measuresZG.max - 0.1,
        "positionZ",
        "a"
      );
      var objNO = 1;

      for (let index = 0; index < finishTops.length; index++) {
        finishTops[index].userData.oldValue = finishTops[index].scale.z;

        finishTops[index].visible = false;
      }

      setTimeout(async () => {
        let c = document.getElementById("myCanvas");
        if (objNO > 0 || wall) {
          html2canvas(c).then(async (canvas) => {
            var t = canvas.toDataURL().replace("data:image/png;base64,", "");
            downloadBase64File("image/png", t, "image");

            // Delete lines
            await deleteLines();

            planeBack.visible = true;
            planeFront.scale.y = 0.001;
            planeFront.position.y = 0.001;
            planeLeft.visible = true;
            planeRight.visible = true;
            planeBottom.visible = true;
            planeTop.visible = true;
            var zVal = 1;
            for (let index = 0; index < objects.length; index++) {
              //  if (objects[index].rotation.y != degrees_to_radians(180) ) {
              //    objects[index].visible = true;
              //  } else {

              if (objects[index].rotation.y == degrees_to_radians(0))
                objects[index].scale.z = objects[index].userData.oldSizeZ;
              if (objects[index].rotation.y == degrees_to_radians(90))
                objects[index].scale.z = objects[index].userData.oldSizeZ;
              if (objects[index].rotation.y == degrees_to_radians(-90))
                objects[index].scale.z = objects[index].userData.oldSizeZ;
              if (objects[index].rotation.y == degrees_to_radians(180))
                objects[index].scale.z = objects[index].userData.oldSizeZ;

              //  objects[index].scale.z = 1;
              //  }
              for (let w = 0; w < objects[index].children.length; w++) {
                if (objects[index].children[w].type == "Mesh")
                  objects[index].children[w].material.wireframe = false;
              }
            }

            //  for (let index = 0; index < leftCovers.length; index++) {
            //   //  if (leftCovers[index].rotation.y != degrees_to_radians(180)) {
            //   //    leftCovers[index].visible = true;
            //   //  } else {
            //     if(leftCovers[index].rotation.y == degrees_to_radians(0))
            //     leftCovers[index].scale.z = zVal;
            //       if(leftCovers[index].rotation.y == degrees_to_radians(90))
            //       leftCovers[index].scale.z = zVal;
            //       if(leftCovers[index].rotation.y == degrees_to_radians(-90))
            //       leftCovers[index].scale.z = zVal;
            //       if(leftCovers[index].rotation.y == degrees_to_radians(180))
            //       leftCovers[index].scale.z = zVal;
            //     //  leftCovers[index].scale.z = 1;
            //   //  }
            //  }
            //  for (let index = 0; index < rightCovers.length; index++) {
            //   //  if (rightCovers[index].rotation.y != degrees_to_radians(180)) {
            //   //    rightCovers[index].visible = true;
            //   //  } else {
            //     if(rightCovers[index].rotation.y == degrees_to_radians(0))
            //     rightCovers[index].scale.z = zVal;
            //       if(rightCovers[index].rotation.y == degrees_to_radians(90))
            //       rightCovers[index].scale.z = zVal;
            //       if(rightCovers[index].rotation.y == degrees_to_radians(-90))
            //       rightCovers[index].scale.z = zVal;
            //       if(rightCovers[index].rotation.y == degrees_to_radians(180))
            //       rightCovers[index].scale.z = zVal;
            //     //  rightCovers[index].scale.z = 1;
            //   //  }
            //  }
            //  for (let index = 0; index < backCovers.length; index++) {
            //   //  if (backCovers[index].rotation.y != degrees_to_radians(180)) {
            //   //    backCovers[index].visible = true;
            //   //  } else {
            //     if(backCovers[index].rotation.y == degrees_to_radians(0))
            //     backCovers[index].scale.z = zVal;
            //       if(backCovers[index].rotation.y == degrees_to_radians(90))
            //       backCovers[index].scale.z = zVal;
            //       if(backCovers[index].rotation.y == degrees_to_radians(-90))
            //       backCovers[index].scale.z = zVal;
            //       if(backCovers[index].rotation.y == degrees_to_radians(180))
            //       backCovers[index].scale.z = zVal;
            //     //  backCovers[index].scale.z = 1;
            //   //  }
            //  }
            //  for (let index = 0; index < wallPanels.length; index++) {
            //   //  if (wallPanels[index].rotation.y != degrees_to_radians(180)) {
            //   //    wallPanels[index].visible = true;
            //   //  } else {
            //     if(wallPanels[index].rotation.y == degrees_to_radians(0))
            //     wallPanels[index].scale.z = zVal;
            //       if(wallPanels[index].rotation.y == degrees_to_radians(90))
            //       wallPanels[index].scale.z = zVal;
            //       if(wallPanels[index].rotation.y == degrees_to_radians(-90))
            //       wallPanels[index].scale.z = zVal;
            //       if(wallPanels[index].rotation.y == degrees_to_radians(180))
            //       wallPanels[index].scale.z = zVal;
            //     //  wallPanels[index].scale.z = 1;
            //   //  }
            //  }

            // //  for (let index = 0; index < finishTops.length; index++) {

            // //      finishTops[index].visible = true;

            // //  }

            //  for (let index = 0; index < Cornices.length; index++) {
            //   //  if (Cornices[index].rotation.y != degrees_to_radians(180)) {
            //   //    Cornices[index].visible = true;
            //   //  } else {
            //     if(Cornices[index].rotation.y == degrees_to_radians(0))
            //     Cornices[index].scale.z = zVal;
            //       if(Cornices[index].rotation.y == degrees_to_radians(90))
            //       Cornices[index].scale.z = zVal;
            //       if(Cornices[index].rotation.y == degrees_to_radians(-90))
            //       Cornices[index].scale.z = zVal;
            //       if(Cornices[index].rotation.y == degrees_to_radians(180))
            //       Cornices[index].scale.z = zVal;

            //     //  Cornices[index].scale.z = 1;
            //   //  }
            //  }
            //  for (let index = 0; index < decoStrips.length; index++) {
            //   //  if (decoStrips[index].rotation.y != degrees_to_radians(180)) {
            //   //    decoStrips[index].visible = true;
            //   //  } else {
            //     if(decoStrips[index].rotation.y == degrees_to_radians(0))
            //     decoStrips[index].scale.z = zVal;
            //       if(decoStrips[index].rotation.y == degrees_to_radians(90))
            //       decoStrips[index].scale.z = zVal;
            //       if(decoStrips[index].rotation.y == degrees_to_radians(-90))
            //       decoStrips[index].scale.z = zVal;
            //       if(decoStrips[index].rotation.y == degrees_to_radians(180))
            //       decoStrips[index].scale.z = zVal;
            //     //  decoStrips[index].scale.z = 1;
            //   //  }
            //  }
            //  for (let index = 0; index < sinks.length; index++) {
            //   //  if (sinks[index].rotation.y != degrees_to_radians(180)) {
            //   //    sinks[index].visible = true;
            //   //  } else {
            //     if(sinks[index].rotation.y == degrees_to_radians(0))
            //     sinks[index].scale.z = zVal;
            //       if(sinks[index].rotation.y == degrees_to_radians(90))
            //       sinks[index].scale.z = zVal;
            //       if(sinks[index].rotation.y == degrees_to_radians(-90))
            //       sinks[index].scale.z = zVal;
            //       if(sinks[index].rotation.y == degrees_to_radians(180))
            //       sinks[index].scale.z = zVal;

            //     //  sinks[index].scale.z = 1;
            //   //  }
            //  }
            //  for (let index = 0; index < ovens.length; index++) {
            //   //  if (ovens[index].rotation.y != degrees_to_radians(180)) {
            //   //    ovens[index].visible = true;
            //   //  } else {
            //     if(ovens[index].rotation.y == degrees_to_radians(0))
            //     ovens[index].scale.z = zVal;
            //       if(ovens[index].rotation.y == degrees_to_radians(90))
            //       ovens[index].scale.z = zVal;
            //       if(ovens[index].rotation.y == degrees_to_radians(-90))
            //       ovens[index].scale.z = zVal;
            //       if(ovens[index].rotation.y == degrees_to_radians(180))
            //       ovens[index].scale.z = zVal;

            //     //  ovens[index].scale.z = 1;
            //   //  }
            //  }
            //  for (let index = 0; index < fillers.length; index++) {
            //   // if (fillers[index].rotation.y != degrees_to_radians(180)) {
            //   //   fillers[index].visible = true;
            //   // } else {
            //     if(fillers[index].rotation.y == degrees_to_radians(0))
            //     fillers[index].scale.z = zVal;
            //       if(fillers[index].rotation.y == degrees_to_radians(90))
            //       fillers[index].scale.z = zVal;
            //       if(fillers[index].rotation.y == degrees_to_radians(-90))
            //       fillers[index].scale.z = zVal;
            //       if(fillers[index].rotation.y == degrees_to_radians(180))
            //       fillers[index].scale.z = zVal;

            //     // fillers[index].scale.z = 1;
            //   // }

            // }

            await deleteLines();

            for (let index = 0; index < objectsLeft.length; index++) {
              // objectsLeft.userData.oldPositionZ = objectsLeft[index].position.z
              objectsLeft[index].position.z =
                objectsLeft[index].userData.oldPositionZ;
              objectsLeft[index].userData.oldPositionZ = null;
              objectsLeft[index].scale.x = objectsLeft[index].userData.oldSizeX;
              scene.add(objectsLeft[index]);
              //  object.userData.oldSizeZ = object.scale.z
              //  object.userData.oldSizeX = object.scale.x
            }
          });
        }
        await to2D();
      }, time * 1.1);
    } else {
      for (let index = 0; index < objects.length; index++) {
        if (objects[index].visible == false) {
          objects[index].visible = true;
        } else {
          for (let w = 0; w < objects[index].children.length; w++) {
            if (objects[index].children[w].type == "Mesh")
              objects[index].children[w].material.wireframe = true;
          }
        }
      }
    }
  }, time);
}

async function changeScale(angle, wall, referencePoint, position, axis) {
  var zVal = 0.0001;
  var objNO = 0;
  for (let index = 0; index < objects.length; index++) {
    if (axis == "a") {
      // objects[index].visible = false;
      // if(objects[index].rotation.y == degrees_to_radians(0))
      // objects[index].scale.z = zVal;
      // if(objects[index].rotation.y == degrees_to_radians(90))
      // objects[index].scale.z = zVal;
      // if(objects[index].rotation.y == degrees_to_radians(-90))
      // objects[index].scale.z = zVal;
      // if(objects[index].rotation.y == degrees_to_radians(180))
      // objects[index].scale.z = zVal;
    } else if (objects[index].rotation.y != degrees_to_radians(angle)) {
      objects[index].visible = false;
    } else {
      objects[index].userData.oldSizeZ = objects[index].scale.z;
      // console.log("old size z    ", objects[index].scale.z);
      // console.log("oldSizeZ    ", objects[index].userData.oldSizeZ);
      objects[index].userData.oldSizeX = objects[index].scale.x;
      if (wall) {
        if (objects[index].position[axis] == referencePoint) {
          objects[index].scale.z = zVal;
          objNO = objNO + 1;
        } else {
          objects[index].visible = false;
        }
      } else {
        if (objects[index].position[axis] != referencePoint) {
          objects[index].scale.z = zVal;
          objects[index].userData.positionXScreen = objects[index].position.x;
          objects[index].userData.positionZScreen = objects[index].position.z;
          if (angle == 0) {
            objects[index].position.z = measuresZG.min + 0.1;
          } else if (angle == 90) {
            objects[index].position.x = measuresXG.min + 0.1;
          } else if (angle == 180) {
            objects[index].position.z = measuresZG.max - 0.1;
          } else if (angle == -90) {
            objects[index].position.x = measuresXG.max - 0.1;
          }

          objects[index].position.z;

          objNO = objNO + 1;
        } else {
          objects[index].visible = false;
        }
      }
    }

    // for (let o = 0; o <  objects[index].children.length; o++) {
    // // objects[index].children[o].material.wireframe  = true;
    // }
    //  uuidSelected[0] =  objects[index].uuid;
    //  await calcMeasuresFunc()
    // scene.add(objects[index]);
  }
  uuidSelected = [];
  for (let index = 0; index < leftCovers.length; index++) {
    leftCovers[index].visible = false;

    // if(axis == 'a'){
    //   leftCovers[index].visible = false;

    //   // if(leftCovers[index].rotation.y == degrees_to_radians(0))
    //   // leftCovers[index].scale.z = zVal;
    //   // if(leftCovers[index].rotation.y == degrees_to_radians(90))
    //   // leftCovers[index].scale.z = zVal;
    //   // if(leftCovers[index].rotation.y == degrees_to_radians(-90))
    //   // leftCovers[index].scale.z = zVal;
    //   // if(leftCovers[index].rotation.y == degrees_to_radians(180))
    //   // leftCovers[index].scale.z = zVal;
    // }else
    // if (leftCovers[index].rotation.y != degrees_to_radians(angle)) {
    //   leftCovers[index].visible = false;
    // } else {
    //   if(wall){
    //     // console.log("leftCovers[index].position[axis]  " , leftCovers[index].position[axis]);
    //     if(leftCovers[index].position[axis] == referencePoint ){
    //       leftCovers[index].scale.z = zVal;
    //     }else{
    //       leftCovers[index].visible = false;

    //     }

    //   }else{
    //     if(leftCovers[index].position[axis] != referencePoint ){
    //       leftCovers[index].scale.z = zVal;
    //     }else{
    //       leftCovers[index].visible = false;

    //     }
    //   }
    // }
    // console.log("leftCovers  " , leftCovers[index]);
    // for (let o = 1; o <  leftCovers[index].children.length; o++) {
    //   // const element = array[o];
    //   // leftCovers[index].children[o].material.wireframe  = true;

    // }
    // leftCovers[index].material.wireframe  = true;
  }
  for (let index = 0; index < rightCovers.length; index++) {
    rightCovers[index].visible = false;

    // if(axis == 'a'){
    //   rightCovers[index].visible = false;

    //   // if(rightCovers[index].rotation.y == degrees_to_radians(0))
    //   // rightCovers[index].scale.z = zVal;
    //   // if(rightCovers[index].rotation.y == degrees_to_radians(90))
    //   // rightCovers[index].scale.z = zVal;
    //   // if(rightCovers[index].rotation.y == degrees_to_radians(-90))
    //   // rightCovers[index].scale.z = zVal;
    //   // if(rightCovers[index].rotation.y == degrees_to_radians(180))
    //   // rightCovers[index].scale.z = zVal;
    // }else
    // if (rightCovers[index].rotation.y != degrees_to_radians(angle)) {
    //   rightCovers[index].visible = false;
    // } else {
    //   if(wall){

    //     if(rightCovers[index].position[axis] == referencePoint){
    //       rightCovers[index].scale.z = zVal;
    //     }else{
    //       rightCovers[index].visible = false;

    //     }

    //   }else{
    //     if(rightCovers[index].position[axis] != referencePoint){
    //       rightCovers[index].scale.z = zVal;
    //     }else{
    //       rightCovers[index].visible = false;

    //     }
    //   }
    // }
    // // rightCovers[index].material.wireframe  = true;
    // for (let o = 1; o <  rightCovers[index].children.length; o++) {
    //   // const element = array[o];
    //   // rightCovers[index].children[o].material.wireframe  = true;

    // }
  }
  for (let index = 0; index < backCovers.length; index++) {
    backCovers[index].visible = false;

    // if(axis == 'a'){
    //   backCovers[index].visible = false;

    //   // if(backCovers[index].rotation.y == degrees_to_radians(0))
    //   // backCovers[index].scale.z = zVal;
    //   // if(backCovers[index].rotation.y == degrees_to_radians(90))
    //   // backCovers[index].scale.z = zVal;
    //   // if(backCovers[index].rotation.y == degrees_to_radians(-90))
    //   // backCovers[index].scale.z = zVal;
    //   // if(backCovers[index].rotation.y == degrees_to_radians(180))
    //   // backCovers[index].scale.z = zVal;
    // }else
    // if (backCovers[index].rotation.y != degrees_to_radians(angle)) {
    //   backCovers[index].visible = false;
    // } else {
    //   if(wall){
    //     // let s = 'z';
    //     if(backCovers[index].position[axis] == referencePoint){
    //       backCovers[index].scale.z = zVal;
    //     }else{
    //       backCovers[index].visible = false;

    //     }

    //   }else{
    //     if(backCovers[index].position[axis] != referencePoint ){
    //       backCovers[index].scale.z = zVal;

    //     }else{
    //       backCovers[index].visible = false;

    //     }
    //   }
    // }
    // console.log("backCovers  ",backCovers[index]);
    // for (let o = 2; o <  backCovers[index].children.length; o++) {
    //   // const element = array[o];
    //   // backCovers[index].children[o].material.wireframe  = true;

    // }
    // backCovers[index].material.wireframe  = true;
  }
  for (let index = 0; index < wallPanels.length; index++) {
    if (axis == "a") {
      wallPanels[index].visible = false;

      // if(wallPanels[index].rotation.y == degrees_to_radians(0))
      // wallPanels[index].scale.z = zVal;
      // if(wallPanels[index].rotation.y == degrees_to_radians(90))
      // wallPanels[index].scale.z = zVal;
      // if(wallPanels[index].rotation.y == degrees_to_radians(-90))
      // wallPanels[index].scale.z = zVal;
      // if(wallPanels[index].rotation.y == degrees_to_radians(180))
      // wallPanels[index].scale.z = zVal;
    } else if (wallPanels[index].rotation.y != degrees_to_radians(angle)) {
      wallPanels[index].visible = false;
    } else {
      if (wall) {
        if (wallPanels[index].position[axis] == referencePoint) {
          wallPanels[index].scale.z = zVal;
        } else {
          wallPanels[index].visible = false;
        }
      } else {
        // let s = 'z';
        if (wallPanels[index].position[axis] != referencePoint) {
          wallPanels[index].scale.z = zVal;
        } else {
          wallPanels[index].visible = false;
        }
      }
    }
    for (let o = 1; o < wallPanels[index].children.length; o++) {
      // const element = array[o];
      // wallPanels[index].children[o].material.wireframe  = true;
    }
    // wallPanels[index].material.wireframe  = true;
  }
  for (let index = 0; index < directions.length; index++) {
    // if (directions[index].rotation.y != degrees_to_radians(0)) {
    directions[index].visible = false;
    // } else {
    //   directions[index].scale.z = 0.1;
    // }
  }

  for (let index = 0; index < Cornices.length; index++) {
    if (axis == "a") {
      Cornices[index].visible = false;

      // if(Cornices[index].rotation.y == degrees_to_radians(0))
      // Cornices[index].scale.z = zVal;
      // if(Cornices[index].rotation.y == degrees_to_radians(90))
      // Cornices[index].scale.z = zVal;
      // if(Cornices[index].rotation.y == degrees_to_radians(-90))
      // Cornices[index].scale.z = zVal;
      // if(Cornices[index].rotation.y == degrees_to_radians(180))
      // Cornices[index].scale.z = zVal;
    } else if (Cornices[index].rotation.y != degrees_to_radians(angle)) {
      Cornices[index].visible = false;
    } else {
      if (wall) {
        if (Cornices[index].userData[position] == referencePoint) {
          Cornices[index].scale.z = zVal;
        } else {
          Cornices[index].visible = false;
        }
      } else {
        if (Cornices[index].userData[position] != referencePoint) {
          Cornices[index].scale.z = zVal;
        } else {
          Cornices[index].visible = false;
        }
      }
    }
    for (let o = 1; o < Cornices[index].children.length; o++) {
      // const element = array[o];
      // Cornices[index].children[o].material.wireframe  = true;
    }
    // Cornices[index].material.wireframe  = true;
  }
  for (let index = 0; index < decoStrips.length; index++) {
    if (axis == "a") {
      decoStrips[index].visible = false;

      // if(decoStrips[index].rotation.y == degrees_to_radians(0))
      // decoStrips[index].scale.z = zVal;
      // if(decoStrips[index].rotation.y == degrees_to_radians(90))
      // decoStrips[index].scale.z = zVal;
      // if(decoStrips[index].rotation.y == degrees_to_radians(-90))
      // decoStrips[index].scale.z = zVal;
      // if(decoStrips[index].rotation.y == degrees_to_radians(180))
      // decoStrips[index].scale.z = zVal;
    } else if (decoStrips[index].rotation.y != degrees_to_radians(angle)) {
      decoStrips[index].visible = false;
    } else {
      if (wall) {
        if (decoStrips[index].userData[position] == referencePoint) {
          decoStrips[index].scale.z = zVal;
        } else {
          decoStrips[index].visible = false;
        }
      } else {
        if (decoStrips[index].userData[position] != referencePoint) {
          decoStrips[index].scale.z = zVal;
        } else {
          decoStrips[index].visible = false;
        }
      }
      // decoStrips[index].scale.z = 0.1;
    }
    for (let o = 0; o < decoStrips[index].children.length; o++) {
      // const element = array[o];
      // decoStrips[index].children[o].material.wireframe  = true;
    }
    // decoStrips[index].material.wireframe  = true;
  }
  for (let index = 0; index < sinks.length; index++) {
    if (axis == "a") {
      sinks[index].visible = false;

      // if(sinks[index].rotation.y == degrees_to_radians(0))
      // sinks[index].scale.z = zVal;
      // if(sinks[index].rotation.y == degrees_to_radians(90))
      // sinks[index].scale.z = zVal;
      // if(sinks[index].rotation.y == degrees_to_radians(-90))
      // sinks[index].scale.z = zVal;
      // if(sinks[index].rotation.y == degrees_to_radians(180))
      // sinks[index].scale.z = zVal;
    } else if (sinks[index].rotation.y != degrees_to_radians(angle)) {
      sinks[index].visible = false;
    } else {
      //   sinks[index].scale.z = zVal;
      if (wall) {
        if (sinks[index].userData[position] == referencePoint) {
          sinks[index].scale.z = zVal;
        } else {
          sinks[index].visible = false;
        }
      } else {
        if (sinks[index].userData[position] != referencePoint) {
          sinks[index].scale.z = zVal;
        } else {
          sinks[index].visible = false;
        }
      }
    }
    // sinks[index].material.wireframe  = true;
    for (let o = 1; o < sinks[index].children.length; o++) {
      // const element = array[o];
      // sinks[index].children[o].material.wireframe  = true;
    }
  }
  for (let index = 0; index < ovens.length; index++) {
    if (axis == "a") {
      ovens[index].visible = false;

      // if(ovens[index].rotation.y == degrees_to_radians(0))
      // ovens[index].scale.z = zVal;
      // if(ovens[index].rotation.y == degrees_to_radians(90))
      // ovens[index].scale.z = zVal;
      // if(ovens[index].rotation.y == degrees_to_radians(-90))
      // ovens[index].scale.z = zVal;
      // if(ovens[index].rotation.y == degrees_to_radians(180))
      // ovens[index].scale.z = zVal;
    } else if (ovens[index].rotation.y != degrees_to_radians(angle)) {
      ovens[index].visible = false;
    } else {
      if (wall) {
        if (ovens[index].userData[position] == referencePoint) {
          ovens[index].scale.z = zVal;
        } else {
          ovens[index].visible = false;
        }
      } else {
        if (ovens[index].userData[position] != referencePoint) {
          ovens[index].scale.z = zVal;
        } else {
          ovens[index].visible = false;
        }
      }
    }
    // ovens[index].material.wireframe  = true;
    for (let o = 1; o < ovens[index].children.length; o++) {
      // const element = array[o];
      // ovens[index].children[o].material.wireframe  = true;
    }
  }
  for (let index = 0; index < fillers.length; index++) {
    if (axis == "a") {
      fillers[index].visible = false;

      // if(fillers[index].rotation.y == degrees_to_radians(0))
      // fillers[index].scale.z = zVal;
      // if(fillers[index].rotation.y == degrees_to_radians(90))
      // fillers[index].scale.z = zVal;
      // if(fillers[index].rotation.y == degrees_to_radians(-90))
      // fillers[index].scale.z = zVal;
      // if(fillers[index].rotation.y == degrees_to_radians(180))
      // fillers[index].scale.z = zVal;
    } else if (fillers[index].rotation.y != degrees_to_radians(angle)) {
      fillers[index].visible = false;
    } else {
      if (wall) {
        if (fillers[index].position[axis] == referencePoint) {
          fillers[index].scale.z = zVal;
        } else {
          fillers[index].visible = false;
        }
      } else {
        // if(fillers[index].userData[position] != referencePoint){
        //   fillers[index].scale.z = zVal;
        // }else{
        fillers[index].visible = false;
        // }
      }
    }
    for (let o = 1; o < fillers[index].children.length; o++) {
      // const element = array[o];
      // fillers[index].children[o].material.wireframe  = true;
    }
    // fillers[index].material.wireframe  = true;
  }

  return objNO;
}

async function downloadBase64File(contentType, base64Data, fileName) {
  const linkSource = `data:${contentType};base64,${base64Data}`;
  console.log("linkSource   ", linkSource);
  const downloadLink = document.createElement("a");
  downloadLink.href = linkSource;
  downloadLink.download = fileName;
  downloadLink.click();
}

window.exportToObj = () => {
  for (let index = 0; index < objects.length; index++) {
    if (uuidSelected[0] == objects[index].uuid) {
      const exporter = new OBJExporter();
      const result = exporter.parse(objects[index]);
      saveString(result, "newObj.obj");
    }
  }
};

const link = document.createElement("a");
link.style.display = "none";
document.body.appendChild(link);

function save(blob, filename) {
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
}

function saveString(text, filename) {
  save(new Blob([text], { type: "text/plain" }), filename);
}

window.applyLeftCover = (operation) => {
  if (uuidSelected.length > 0) {
    for (let i = 0; i < uuidSelected.length; i++) {
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].uuid === uuidSelected[i]) {
          let Objobject = scene.children[index];

          for (let l = 0; l < leftCovers.length; l++) {
            if (leftCovers[l].uuid == Objobject.userData.uuidLeftCover) {
              scene.children[index].userData.visibleLeftCover =
                operation == "D" ? false : true;
              leftCovers[l].visible = operation == "D" ? false : true;
              break;
            }
          }
        }
      }
    }
  }
};

window.applyRightCover = (operation) => {
  if (uuidSelected.length > 0) {
    for (let i = 0; i < uuidSelected.length; i++) {
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].uuid === uuidSelected[i]) {
          let Objobject = scene.children[index];

          for (let r = 0; r < rightCovers.length; r++) {
            if (rightCovers[r].uuid == Objobject.userData.uuidRightCover) {
              scene.children[index].userData.visibleRightCover =
                operation == "D" ? false : true;
              rightCovers[r].visible = operation == "D" ? false : true;
              break;
            }
          }
        }
      }
    }
  }
};

window.applyBackCover = (operation) => {
  if (uuidSelected.length > 0) {
    for (let i = 0; i < uuidSelected.length; i++) {
      for (let index = 0; index < scene.children.length; index++) {
        if (scene.children[index].uuid === uuidSelected[i]) {
          let Objobject = scene.children[index];

          for (let r = 0; r < backCovers.length; r++) {
            if (backCovers[r].uuid == Objobject.userData.uuidBackCover) {
              scene.children[index].userData.visibleBackCover =
                operation == "D" ? false : true;
              backCovers[r].visible = operation == "D" ? false : true;
              break;
            }
          }
        }
      }
    }
  }
};

var num = 0;
const loop = () => {
  //   // cube.rotation.y += 0.01
  // console.log('num ' , ++num);
  if (planeBottom) {
    if (planeBottom.material != null) planeBottom.material.update();
  }
  //   // controls.update();

  // renderer.render(scene, camera);
  requestAnimationFrame(loop);
};

loop();

function postData() {
  console.log("okay postData");
  var totalPrice = 0;
  let st =
    "<h2>Objects No. \t " + window.objects.length + "</h2> <br>  <br>  \n";
  // st += " <div style='display:flex'> <h3>  Ceiling :     " + colors.ceiling + "           ,       Walls : " + colors.walls + "          ,    Floor :     " + colors.floor + " </h3> </div>  \n";
  // st += '<table class="table"><thead><tr><th scope="col">ID</th><th scope="col">Dimensions</th><th scope="col">Corpus</th><th scope="col">Front</th><th scope="col">Toekick</th><th scope="col">Worktops</th><th scope="col">Door open</th><th scope="col">Drawer Type</th><th scope="col">Handle</th><th scope="col">Wall offset</th><th scope="col">Deco strip</th><th scope="col">Deco strip Light</th><th scope="col">Cornice</th><th scope="col">Cornice Light</th><th scope="col">Wall panel</th><th scope="col">Wall panel Height</th><th scope="col">Oven width</th><th scope="col">Sink width</th><th scope="col">Skirting Light</th><th scope="col">Left Cover</th><th scope="col">Right Cover</th><th scope="col">Back Cover</th></tr></thead><tbody>';

  let data = [];
  data.objects = [];
  data.elements = [];
  // Objects
  var k = 1;
  var skirtingLong = 0.0;
  var decoStripLong = 0.0;
  var corniceLong = 0.0;
  st += " <div style='display:flex'> <h2>  Cabinets </h2> </div>  \n";
  for (let index = 0; index < window.objects.length; index++) {
    if (window.objects[index].name != "Element") {
      var dimensions =
        window.objects[index].userData.W * 1000 +
        " mm x " +
        window.objects[index].userData.L * 1000 +
        " mm x " +
        window.objects[index].userData.H * 1000 +
        " mm";
      //    st += '<tr><th>'+window.objects[index].userData.name+'</th><td>' + dimensions + '</td></tr>';
      //    console.log("window.objects[index].children  " ,window.objects[index].children);
      st +=
        " <div style='display:flex'><h3 style='margin-right:20px;'>" +
        k++ +
        " - </h3> <h3>  " +
        window.objects[index].userData.name +
        "   </h3>  <h5 style='margin-left:35px;'> " +
        dimensions +
        "</h5></div>  \n";
      st += '<table class="table"><thead><tr></tr></thead><tbody>';
      st += '<tr><th scope="col">Part </th><th scope="col">Price</th></tr>';
      for (let ch = 0; ch < window.objects[index].children.length; ch++) {
        if (
          window.objects[index].children[ch].visible == true &&
          window.objects[index].children[ch].type == "Mesh"
        ) {
          st +=
            "<tr><td>" +
            window.objects[index].children[ch].name +
            "</td><td> $30</td> </tr>";
          totalPrice += 30;
        }
      }
      console.log(window.objects[index]);
      if (
        window.objects[index].name != "Element" &&
        window.objects[index].name != "W"
      ) {
     
      
        // if(
        //   window.objects[index].userData.hasBackObject != undefined &&
        //   window.objects[index].userData.hasLeftObject != undefined &&
        //   window.objects[index].userData.hasRightObject != undefined 
        //   ){

        //   }
          console.log('hasBackObject    ' , window.objects[index].userData.hasBackObject);
        
        if (window.objects[index].userData.hasBackObject === true) {
          skirtingLong += window.objects[index].userData.W;
        }
        if (window.objects[index].userData.hasDecoStrip == true  && window.objects[index].userData.hasLeftWallObject === true) {
          decoStripLong += window.objects[index].userData.L;
        }
        if (window.objects[index].userData.hasDecoStrip == true  && window.objects[index].userData.hasRightWallObject === true) {
          decoStripLong += window.objects[index].userData.L;
        }
        if (window.objects[index].userData.hasCornice == true  && window.objects[index].userData.hasLeftWallObject === true) {
          corniceLong += window.objects[index].userData.L;
        }
        if (window.objects[index].userData.hasCornice == true  && window.objects[index].userData.hasRightWallObject === true) {
          corniceLong += window.objects[index].userData.L;
        }
        console.log('hasLeftObject    ' , window.objects[index].userData.hasLeftObject);

        if (window.objects[index].userData.hasLeftObject === false) {
          skirtingLong += window.objects[index].userData.L;
          // console.log('skirtingLong    ' , skirtingLong);

        }
        console.log('hasRightObject    ' , window.objects[index].userData.hasRightObject);

        if (window.objects[index].userData.hasRightObject === false) {
          skirtingLong += window.objects[index].userData.L;
          // console.log('skirtingLong    ' , skirtingLong);

        }

        skirtingLong += window.objects[index].userData.W;
        console.log('skirtingLong    ' , skirtingLong);

      }
    

      st += "</tbody></table>";

      // st+= '</tr>';

      // st += '<tr><th scope="row">' + window.objects[index].userData.name + '</th><td>' + dimensions + '</td><td>' + window.objects[index].userData.corpus + '</td><td>' + window.objects[index].userData.front + '</td><td>' + window.objects[index].userData.toekick + '</td><td>' + window.objects[index].userData.worktops + '</td><td>' + window.objects[index].userData.door + '</td><td>' + window.objects[index].userData.drawer + '</td><td>' + window.objects[index].userData.handle + '</td><td>' + window.objects[index].userData.wallOffset + '</td><td>' + window.objects[index].userData.decoStripColor + '</td><td>' + window.objects[index].userData.decoStripLight + '</td><td>' + window.objects[index].userData.corniceColor + '</td><td>' + window.objects[index].userData.corniceLight + '</td><td>' + window.objects[index].userData.wallPanelColor + '</td><td>' + window.objects[index].userData.wallPanelHeight + '</td><td>' + window.objects[index].userData.ovenWidth * 1000 + '</td><td>' + window.objects[index].userData.sinkWidth * 1000 + '</td><td>' + window.objects[index].userData.hasLightSkirting + '</td><td>' + window.objects[index].userData.visibleLeftCover + '</td><td>' + window.objects[index].userData.visibleRightCover + '</td><td>' + window.objects[index].userData.visibleBackCover + '</td></tr>';

      // <td><img style="width:50px;height:50px;" src="'+window.objects[index].userData.objectImg+'" /></td>
      // st += "Object ID  : " + window.objects[index].userData.name +
      //     "    corpus :  " + window.objects[index].userData.corpus +
      //     "    front :  " + window.objects[index].userData.front +
      //     "    toekick : " + window.objects[index].userData.toekick +
      //     "    worktops :  " + window.objects[index].userData.worktops +
      //     "    Door Open :  " + window.objects[index].userData.door +
      //     "    Drawer Type :  " + window.objects[index].userData.drawer +
      //     "    Handle :  " + window.objects[index].userData.handle +
      //     "\n";
      let component = {};
      component.structure_id = window.objects[index].userData.name;
      component.dimensions = dimensions;
      component.carcass_out = window.objects[index].userData.carcass_out;
      component.carcass_in = window.objects[index].userData.carcass_in;
      component.carcass_edges = window.objects[index].userData.carcass_edges;
      component.shutter_out = window.objects[index].userData.shutter_out;
      component.shutter_in = window.objects[index].userData.shutter_in;
      component.shelf = window.objects[index].userData.shelf;
      component.shelf_edges = window.objects[index].userData.shelf_edges;
      component.toekick = window.objects[index].userData.toekick;
      component.worktops = window.objects[index].userData.worktops;
      component.door = window.objects[index].userData.door;
      component.drawer = window.objects[index].userData.drawer;
      component.handle = window.objects[index].userData.handle;
      component.wall_offset = window.objects[index].userData.wallOffset;
      component.deco_strip_color =
        window.objects[index].userData.decoStripColor;
      component.deco_strip_light =
        window.objects[index].userData.decoStripLight;
      component.cornice_color = window.objects[index].userData.corniceColor;
      component.cornice_light = window.objects[index].userData.corniceLight;
      component.wall_panel_color =
        window.objects[index].userData.wallPanelColor;
      component.wall_panel_light =
        window.objects[index].userData.wallPanelHeight;
      component.ovenWidth = window.objects[index].userData.ovenWidth * 1000;
      component.sinkWidth = window.objects[index].userData.sinkWidth * 1000;
      component.skirting_light =
        window.objects[index].userData.hasLightSkirting;
      component.position = window.objects[index].position;
      // component.position.y = window.objects[index].position.y;
      // component.position.z = window.objects[index].position.z;

      component.left_cover = window.objects[index].userData.visibleLeftCover;
      component.right_cover = window.objects[index].userData.visibleRightCover;
      component.back_cover = window.objects[index].userData.visibleBackCover;

      data.objects.push(component);
    }
  }

  // Elements
  var k = 1;
  st += " <div style='display:flex'> <h2>  Elements </h2> </div>  \n";
  for (let index = 0; index < window.objects.length; index++) {
    if (window.objects[index].name == "Element") {
      var dimensions =
        window.objects[index].userData.W * 1000 +
        " mm x " +
        window.objects[index].userData.L * 1000 +
        " mm x " +
        window.objects[index].userData.H * 1000 +
        " mm";
      //    st += '<tr><th>'+window.objects[index].userData.name+'</th><td>' + dimensions + '</td></tr>';
      //    console.log("window.objects[index].children  " ,window.objects[index].children);
      st +=
        " <div style='display:flex'><h3 style='margin-right:20px;'>" +
        k++ +
        " - </h3> <h3>  " +
        window.objects[index].userData.name +
        "   </h3>  <h5 style='margin-left:35px;'> " +
        dimensions +
        "</h5></div>  \n";
      st += '<table class="table"><thead><tr></tr></thead><tbody>';
      st += '<tr><th scope="col">Part </th><th scope="col">Price</th></tr>';
      for (let ch = 0; ch < window.objects[index].children.length; ch++) {
        if (
          window.objects[index].children[ch].visible == true &&
          window.objects[index].children[ch].type == "Mesh"
        ) {
          st +=
            "<tr><td>" +
            window.objects[index].children[ch].name +
            "</td><td> $30</td> </tr>";
          totalPrice += 30;
        }
      }

      st += "</tbody></table>";

      // st+= '</tr>';

      // st += '<tr><th scope="row">' + window.objects[index].userData.name + '</th><td>' + dimensions + '</td><td>' + window.objects[index].userData.corpus + '</td><td>' + window.objects[index].userData.front + '</td><td>' + window.objects[index].userData.toekick + '</td><td>' + window.objects[index].userData.worktops + '</td><td>' + window.objects[index].userData.door + '</td><td>' + window.objects[index].userData.drawer + '</td><td>' + window.objects[index].userData.handle + '</td><td>' + window.objects[index].userData.wallOffset + '</td><td>' + window.objects[index].userData.decoStripColor + '</td><td>' + window.objects[index].userData.decoStripLight + '</td><td>' + window.objects[index].userData.corniceColor + '</td><td>' + window.objects[index].userData.corniceLight + '</td><td>' + window.objects[index].userData.wallPanelColor + '</td><td>' + window.objects[index].userData.wallPanelHeight + '</td><td>' + window.objects[index].userData.ovenWidth * 1000 + '</td><td>' + window.objects[index].userData.sinkWidth * 1000 + '</td><td>' + window.objects[index].userData.hasLightSkirting + '</td><td>' + window.objects[index].userData.visibleLeftCover + '</td><td>' + window.objects[index].userData.visibleRightCover + '</td><td>' + window.objects[index].userData.visibleBackCover + '</td></tr>';

      // <td><img style="width:50px;height:50px;" src="'+window.objects[index].userData.objectImg+'" /></td>
      // st += "Object ID  : " + window.objects[index].userData.name +
      //     "    corpus :  " + window.objects[index].userData.corpus +
      //     "    front :  " + window.objects[index].userData.front +
      //     "    toekick : " + window.objects[index].userData.toekick +
      //     "    worktops :  " + window.objects[index].userData.worktops +
      //     "    Door Open :  " + window.objects[index].userData.door +
      //     "    Drawer Type :  " + window.objects[index].userData.drawer +
      //     "    Handle :  " + window.objects[index].userData.handle +
      //     "\n";
      let component = {};
      component.structure_id = window.objects[index].userData.name;
      component.dimensions = dimensions;
      // component.corpus = window.objects[index].userData.corpus;
      // component.front = window.objects[index].userData.front;
      // component.toekick = window.objects[index].userData.toekick;
      // component.worktops = window.objects[index].userData.worktops;
      // component.door = window.objects[index].userData.door;
      // component.drawer = window.objects[index].userData.drawer;
      // component.handle = window.objects[index].userData.handle;
      component.wall_offset = window.objects[index].userData.wallOffset;
      // component.deco_strip_color = window.objects[index].userData.decoStripColor;
      // component.deco_strip_light = window.objects[index].userData.decoStripLight;
      // component.cornice_color = window.objects[index].userData.corniceColor;
      // component.cornice_light = window.objects[index].userData.corniceLight;
      // component.wall_panel_color = window.objects[index].userData.wallPanelColor;
      // component.wall_panel_light = window.objects[index].userData.wallPanelHeight;
      // component.ovenWidth = window.objects[index].userData.ovenWidth * 1000;
      // component.sinkWidth = window.objects[index].userData.sinkWidth * 1000;
      component.position = window.objects[index].position;
      // component.position.y = window.objects[index].position.y;
      // component.position.z = window.objects[index].position.z;

      // component.left_cover = window.objects[index].userData.visibleLeftCover;
      // component.right_cover = window.objects[index].userData.visibleRightCover;
      // component.back_cover = window.objects[index].userData.visibleBackCover;

      data.elements.push(component);
    }
    /**
      
      
       * 
      */
  }

  // Left Covers
  if (window.leftCovers.length > 0) {
    st += " <div style='display:flex'> <h2>  Left Covers </h2> </div>  \n";
    st +=
      '<table class="table"><thead><tr><th scope="col">Dimensions</th><th scope="col">Price</th></tr></thead><tbody>';
    data.left_covers = [];
    for (let index = 0; index < window.leftCovers.length; index++) {
      const element = window.leftCovers[index];
      if (window.leftCovers[index].visible == true) {
        var dimensions =
          window.leftCovers[index].scale.x * 1000 +
          " mm x " +
          window.leftCovers[index].scale.y * 1000 +
          " mm x " +
          window.leftCovers[index].scale.z * 1000 +
          " mm";
        st += "<tr><td>" + dimensions + "</td><td>$20 </td></tr>";
        totalPrice += 20;

        let left_cover = {};
        left_cover.uuid = element.uuid;
        left_cover.dimention = element.scale;
        left_cover.position = element.position;
        left_cover.price = 20;
        data.left_covers.push(left_cover);
      }
    }
    st += "</tbody></table>";
  }
  // Right Covers
  if (window.rightCovers.length > 0) {
    st += " <div style='display:flex'> <h2>  Right Covers </h2> </div>  \n";
    st +=
      '<table class="table"><thead><tr><th scope="col">Dimensions</th><th scope="col">Price</th></tr></thead><tbody>';
    data.right_covers = [];

    for (let index = 0; index < window.rightCovers.length; index++) {
      const element = window.rightCovers[index];
      if (element.visible == true) {
        var dimensions =
          element.scale.x * 1000 +
          " mm x " +
          element.scale.y * 1000 +
          " mm x " +
          element.scale.z * 1000 +
          " mm";
        st += "<tr><td>" + dimensions + "</td><td>$20 </td></tr>";
        totalPrice += 20;

        let right_cover = {};
        right_cover.uuid = element.uuid;
        right_cover.dimention = element.scale;
        right_cover.position = element.position;
        right_cover.price = 20;
        data.right_covers.push(right_cover);
      }
    }
    st += "</tbody></table>";
  }
  // Back Covers
  if (window.backCovers.length > 0) {
    st += " <div style='display:flex'> <h2>  Back Covers </h2> </div>  \n";
    st +=
      '<table class="table"><thead><tr><th scope="col">Dimensions</th><th scope="col">Price</th></tr></thead><tbody>';
    data.back_covers = [];

    for (let index = 0; index < window.backCovers.length; index++) {
      const element = window.backCovers[index];
      if (element.visible == true) {
        var dimensions =
          element.scale.x * 1000 +
          " mm x " +
          element.scale.y * 1000 +
          " mm x " +
          element.scale.z * 1000 +
          " mm";
        st += "<tr><td>" + dimensions + "</td><td>$20 </td></tr>";
        totalPrice += 20;
        let back_cover = {};
        back_cover.uuid = element.uuid;
        back_cover.dimention = element.scale;
        back_cover.position = element.position;
        back_cover.price = 20;
        data.back_covers.push(back_cover);
      }
    }
    st += "</tbody></table>";
  }
  // Wall Panels
  if (window.wallPanels.length > 0) {
    st += " <div style='display:flex'> <h2>  Wall Panels </h2> </div>  \n";
    st +=
      '<table class="table"><thead><tr><th scope="col">Dimensions</th><th scope="col">Price</th></tr></thead><tbody>';
    data.wall_panels = [];

    for (let index = 0; index < window.wallPanels.length; index++) {
      const element = window.wallPanels[index];
      if (element.visible == true) {
        var dimensions =
          element.scale.x * 1000 +
          " mm x " +
          element.scale.y * 1000 +
          " mm x " +
          element.scale.z * 1000 +
          " mm";
        st += "<tr><td>" + dimensions + "</td><td>$20 </td></tr>";
        totalPrice += 20;

        let wall_panel = {};
        wall_panel.dimention = element.scale;
        wall_panel.position = element.position;
        wall_panel.price = 20;
        data.wall_panels.push(wall_panel);
      }
    }
    st += "</tbody></table>";
  }

  // Finish top
  // console.log("Finish tops ", window.finishTops);
  if (window.finishTops.length > 0) {
    st += " <div style='display:flex'> <h2>  Finish top </h2> </div>  \n";
    st +=
      '<table class="table"><thead><tr><th scope="col">Dimensions</th><th scope="col">Price</th></tr></thead><tbody>';
    data.finish_tops = [];

    for (let index = 0; index < window.finishTops.length; index++) {
      const element = window.finishTops[index];
      if (element.visible == true && element.parent != null) {
        var dimensions =
          element.scale.x.toFixed(2) * 1000 +
          " mm x " +
          element.scale.y.toFixed(2) * 1000 +
          " mm x " +
          element.scale.z.toFixed(2) * 1000 +
          " mm";
        st += "<tr><td>" + dimensions + "</td><td>$20 </td></tr>";
        totalPrice += 20;

        let finish_top = {};
        finish_top.dimention = element.scale;
        finish_top.position = element.position;
        finish_top.price = 20;
        data.finish_tops.push(finish_top);
      }
    }
    st += "</tbody></table>";
  }

  // decoStrips
  if (window.decoStrips.length > 0) {
    st += " <div style='display:flex'> <h2>  Deco Strip </h2> </div>  \n";
    st +=
      '<table class="table"><thead><tr><th scope="col">Dimensions</th><th scope="col">Price</th></tr></thead><tbody>';
    data.deco_strips = [];
    for (let index = 0; index < window.decoStrips.length; index++) {
      const element = window.decoStrips[index];
      decoStripLong += parseFloat(element.scale.x.toFixed(2));
      if (element.visible == true) {
        var dimensions =
          element.scale.x * 1000 +
          " mm x " +
          element.scale.y * 1000 +
          " mm x " +
          element.scale.z * 1000 +
          " mm";
        st += "<tr><td>" + dimensions + "</td><td>$20 </td></tr>";
        totalPrice += 20;
        let deco_strip = {};
        deco_strip.dimention = element.scale;
        deco_strip.position = element.position;
        deco_strip.price = 20;
        data.deco_strips.push(deco_strip);
      }
    }
    st += "</tbody></table>";
  }

  // Cornices
  if (window.Cornices.length > 0) {
    st += " <div style='display:flex'> <h2>  Cornice </h2> </div>  \n";
    st +=
      '<table class="table"><thead><tr><th scope="col">Dimensions</th><th scope="col">Price</th></tr></thead><tbody>';
    data.cornices = [];
    for (let index = 0; index < window.Cornices.length; index++) {
      const element = window.Cornices[index];
      
      corniceLong += parseFloat(element.scale.x.toFixed(2));

      if (element.visible == true) {
        var dimensions =
          element.scale.x.toFixed(2) * 1000 +
          " mm x " +
          element.scale.y.toFixed(2) * 1000 +
          " mm x " +
          element.scale.z.toFixed(2) * 1000 +
          " mm";
        st += "<tr><td>" + dimensions + "</td><td>$20 </td></tr>";
        totalPrice += 20;
        let cornice = {};
        cornice.dimention = element.scale;
        cornice.position = element.position;
        cornice.price = 20;
        data.cornices.push(cornice);
      }
    }
    st += "</tbody></table>";
  }

  // lightObjects
  if (window.lightObjects.length > 0) {
    st += " <div style='display:flex'> <h2>  Light </h2> </div>  \n";
    st +=
      '<table class="table"><thead><tr><th scope="col">Dimensions</th><th scope="col">Price</th></tr></thead><tbody>';
    data.lights = [];
    for (let index = 0; index < window.lightObjects.length; index++) {
      const element = window.lightObjects[index];
      if (element.visible == true) {
        var dimensions =
          element.scale.x * 1000 +
          " mm x " +
          element.scale.y * 1000 +
          " mm x " +
          element.scale.z * 1000 +
          " mm";
        st += "<tr><td>" + dimensions + "</td><td>$25 </td></tr>";
        totalPrice += 25;
        let light = {};
        light.dimention = element.scale;
        light.position = element.position;
        light.price = 20;
        data.lights.push(light);
      }
    }
    st += "</tbody></table>";
  }

  // Fillers
  if (window.fillers.length > 0) {
    st += " <div style='display:flex'> <h2>  Filler </h2> </div>  \n";
    st +=
      '<table class="table"><thead><tr><th scope="col">Dimensions</th><th scope="col">Price</th></tr></thead><tbody>';
    data.fillers = [];
    for (let index = 0; index < window.fillers.length; index++) {
      const element = window.fillers[index];
      console.log('skirtingLong    ' , skirtingLong);

      skirtingLong += parseFloat(element.scale.x.toFixed(2));
      console.log('Filler    ' , element);
      console.log('skirtingLong    ' , skirtingLong);
      if (element.visible == true) {
        console.log('Active    ');
        var dimensions =
          element.scale.x.toFixed(2) * 1000 +
          " mm x " +
          element.scale.y.toFixed(2) * 1000 +
          " mm x " +
          element.scale.z.toFixed(2) * 1000 +
          " mm";
        st += "<tr><td>" + dimensions + "</td><td>$25 </td></tr>";
        totalPrice += 25;
        let filler = {};
        filler.dimention = element.scale;
        filler.position = element.position;
        filler.price = 20;
        data.fillers.push(filler);
      }
    }
    st += "</tbody></table>";
  }
  // Sinks
  if (window.sinks.length > 0) {
    st += " <div style='display:flex'> <h2>  Sink </h2> </div>  \n";
    st +=
      '<table class="table"><thead><tr><th scope="col">Dimensions</th><th scope="col">Price</th></tr></thead><tbody>';
    data.sinks = [];
    for (let index = 0; index < window.sinks.length; index++) {
      const element = window.sinks[index];
      if (element.visible == true) {
        var dimensions =
          element.scale.x.toFixed(2) * 1000 +
          " mm x " +
          element.scale.y.toFixed(2) * 1000 +
          " mm x " +
          element.scale.z.toFixed(2) * 1000 +
          " mm";
        st += "<tr><td>" + dimensions + "</td><td>$25 </td></tr>";
        totalPrice += 25;
        let sink = {};
        sink.dimention = element.scale;
        sink.position = element.position;
        sink.price = 20;
        data.sinks.push(sink);
      }
    }
    st += "</tbody></table>";
  }
  // Ovens
  if (window.ovens.length > 0) {
    st += " <div style='display:flex'> <h2>  Oven </h2> </div>  \n";
    st +=
      '<table class="table"><thead><tr><th scope="col">Dimensions</th><th scope="col">Price</th></tr></thead><tbody>';
    data.ovens = [];
    for (let index = 0; index < window.ovens.length; index++) {
      const element = window.ovens[index];
      if (element.visible == true) {
        var dimensions =
          element.scale.x.toFixed(2) * 1000 +
          " mm x " +
          element.scale.y.toFixed(2) * 1000 +
          " mm x " +
          element.scale.z.toFixed(2) * 1000 +
          " mm";
        st += "<tr><td>" + dimensions + "</td><td>$25 </td></tr>";
        totalPrice += 25;
        let oven = {};
        oven.dimention = element.scale;
        oven.position = element.position;
        oven.price = 20;
        data.ovens.push(oven);
      }
    }
    st += "</tbody></table>";
  }

  st +=
    " <div style='display:flex;text-align:right'> <h3>  Total price   : </h3>  \t \t <h3>  $" +
    totalPrice +
    "  </h3> </div>";

  // document.getElementById('test').innerHTML = st;

  let objectsData = data.objects.reduce((objects, object) => {
    const { structure_id } = object;
    objects[structure_id] = objects[structure_id] ?? [];
    objects[structure_id].push(object);
    return objects;
  }, {});

  // data.objects = data.objects.groupBy(object => {
  // return object.structure_id;
  // });
  // data.elements = data.elements.groupBy(element => {
  // return element.structure_id;
  // });

  let elementsData = data.elements.reduce((objects, element) => {
    const { structure_id } = element;
    objects[structure_id] = objects[structure_id] ?? [];
    objects[structure_id].push(element);
    return objects;
  }, {});

  // console.log("groupByCategory   " , groupByCategory);S
  // alert(st);
  // colors.ceiling      + "           ,       Walls : " +       colors.walls    + "          ,    Floor :     " +        colors.floor
  console.log(window.objects.length);
  console.log('skirtingLong    ',skirtingLong);
  console.log('decoStripLong    ',decoStripLong);
  console.log('corniceLong    ',corniceLong);
  // console.log(window.objects);
  let data1 = {
    objects: objectsData,
    objectsNO: window.objects.length ?? 0,
    skirtingLong: Math.ceil(skirtingLong/2.4) ?? 0.0,
    decoStripLong: Math.ceil(decoStripLong/2.4) ?? 0.0,
    corniceLong: Math.ceil(corniceLong/2.4) ?? 0.0,
    elements: elementsData,
    left_covers: data.left_covers,
    right_covers: data.right_covers,
    back_covers: data.back_covers,
    wall_panels: data.wall_panels,
    finish_tops: data.finish_tops,
    deco_strips: data.deco_strips,
    cornices: data.cornices,
    lights: data.lights,
    fillers: data.fillers,
    sinks: data.sinks,
    ovens: data.ovens,
  };

  // let finalObject = {
  //     // 'design': {
  //     //     'ceiling': colors.ceiling,
  //     //     'walls': colors.walls,
  //     //     'floor': colors.floor,
  //     // },
  //     'data': data1,

  // }

  console.log(data1);

  let order = { orderData: data1 };

  window.parent.postMessage(JSON.stringify(order), "*");
}




// function postData(input) {
//   // const output = execSync('py alter.py', { encoding: 'utf-8' });  // the default is 'buffer'
//   // var run=new ActiveXObject('WSCRIPT.Shell').Run("py alter.py");
//   // console.log('Output was:\n', run);
//   // document.execCommand("py alter.py");
  
//   // console.log('postData was runned  ');
// //   exec("py alter.py", (error, stdout, stderr) => {
// //     if (error) {
// //         console.log(error);
// //     }
// //     if (stdout) {
// //         console.log(`out of the command : ${stdout}`);
// //     }
// //     if (stderr) {
// //         console.log(`error with cmd : ${stderr}`);
// //         return;
// //     }
// // });
//   // $.ajax({
//   //     type: "GET",
//   //     url: "/alter.py",
//   //     data: { param: input },
//   //     headers: {
//   //       'Access-Control-Allow-Origin': '*',
//   //     },
//   //     success: callbackFunc
//   // });
// }

// function callbackFunc(response) {
//   // do something with the response
//   console.log('Okay');
//   console.log(response);
// }



// function loadXMLDoc() {
//   var xmlhttp = new XMLHttpRequest();
//   // xmlhttp.onreadystatechange = function () {

//   //     // Request finished and response 
//   //     // is ready and Status is "OK"
//   //     if (this.readyState == 4 && this.status == 200) {
//   //         empDetails(this);
//   //     }
//   // };

//   // employee.xml is the external xml file
//   xmlhttp.open("GET", "https://storage.googleapis.com/kitchendata/test1.ghx", true);
//   xmlhttp.send();
//   var xmlData = 
//   console.log('file :   ',xmlhttp);
//   console.log('xml :   ',xmlhttp.responseXML);
//   console.log('text :   ',xmlhttp.responseText);


// }

// function empDetails(xml) {
//   var i;
//   var xmlDoc = xml.responseXML;
//   var table =
//       `<tr><th>Firstname</th><th>Lastname</th>
//           <th>Title</th><th>Division</th>
//           <th>Building</th><th>Room</th>
//       </tr>`;
//   // var x = xmlDoc.getElementsByTagName("employee");
//   console.log(xmlDoc);
//   // Start to fetch the data by using TagName 
//   // for (i = 0; i < x.length; i++) {
//   //     // table += "<tr><td>" +
//   //         // x[i].getElementsByTagName("firstname")[0]
//   //         // .childNodes[0].nodeValue + "</td><td>" +
//   //         // x[i].getElementsByTagName("lastname")[0]
//   //         // .childNodes[0].nodeValue + "</td><td>" +
//   //         // x[i].getElementsByTagName("title")[0]
//   //         // .childNodes[0].nodeValue + "</td><td>" +
//   //         // x[i].getElementsByTagName("division")[0]
//   //         // .childNodes[0].nodeValue + "</td><td>" +
//   //         // x[i].getElementsByTagName("building")[0]
//   //         // .childNodes[0].nodeValue + "</td><td>" +
//   //         // x[i].getElementsByTagName("room")[0]
//   //         // .childNodes[0].nodeValue + "</td></tr>";
//   //         console.log(xmlDoc);
//   // }

//   // Print the xml data in table form
//   // document.getElementById("id").innerHTML = table;
// }


// function postData(input) {
//   $.ajax({
//       type: "POST",
//       url: "/reverse_pca.py",
//       data: { param: input },
//       success: callbackFunc
//   });
// }

// function callbackFunc(response) {
//   // do something with the response
//   console.log(response);
// }

// postData('data to process');